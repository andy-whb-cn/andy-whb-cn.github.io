{"meta":{"title":"Andy's Note","subtitle":"","description":"","author":"Andy","url":"https://andy-whb-cn.github.io","root":"/"},"pages":[{"title":"书单","date":"2024-08-22T09:40:49.988Z","updated":"2024-08-22T09:40:49.988Z","comments":false,"path":"books/index.html","permalink":"https://andy-whb-cn.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-08-22T09:40:49.988Z","updated":"2024-08-22T09:40:49.988Z","comments":false,"path":"about/index.html","permalink":"https://andy-whb-cn.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2024-08-22T09:40:49.988Z","updated":"2024-08-22T09:40:49.988Z","comments":false,"path":"/404.html","permalink":"https://andy-whb-cn.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-08-22T09:40:49.988Z","updated":"2024-08-22T09:40:49.988Z","comments":true,"path":"links/index.html","permalink":"https://andy-whb-cn.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-08-22T09:40:49.988Z","updated":"2024-08-22T09:40:49.988Z","comments":false,"path":"repository/index.html","permalink":"https://andy-whb-cn.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-08-22T09:40:49.989Z","updated":"2024-08-22T09:40:49.989Z","comments":false,"path":"tags/index.html","permalink":"https://andy-whb-cn.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-08-22T09:40:49.988Z","updated":"2024-08-22T09:40:49.988Z","comments":false,"path":"categories/index.html","permalink":"https://andy-whb-cn.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SOA架构vs微服务架构","slug":"架构设计/SOA架构 vs 微服务架构","date":"2024-09-03T01:30:00.000Z","updated":"2024-09-03T02:29:16.772Z","comments":true,"path":"2024/09/03/架构设计/SOA架构 vs 微服务架构/","permalink":"https://andy-whb-cn.github.io/2024/09/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/SOA%E6%9E%B6%E6%9E%84%20vs%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/","excerpt":"","text":"SOA架构和微服务架构最主要的区别：面向的范围不同。SOA架构主要面向企业级服务，微服务架构主要面向应用级服务典型的微服务架构：基础原则： 服务自治：每个服务都拥有独立的数据库和功能，可以独立开发和部署。 去中心化的数据管理：强调服务的数据自主性，减少数据耦合，解决在单体应用中可能出现的数据一致性问题。 技术的异质性：每个服务可以选择最适合的技术栈开发，提升效率和创新。挑战： 分布式服务的复杂性：服务发现、负载均衡、网络延迟、调试和测试。 跨服务数据一致性问题：每个服务都有自己的数据库，数据的完整性和一致性变得复杂，分布式事务比较麻烦且有潜在的性能影响。 业务处理的复杂性：依赖于微服务的良好设计和实现。 监控的必要性：依赖于监控解决方案发现性能瓶颈、错误、异常。 典型的SOA架构： SOA架构可以认为是一种强调模块化和互用性的基础方法。SOA架构图描绘的是互相连接的组件组成系统的结构： Servcie: 完成特定业务功能的服务 Service Repository: 中心化的服务目录，便于服务发现和使用 FrontEnd: 用户接口层，通过契约(Contracts)和服务交互 Service Bus: 用于服务间通讯，建立消息交换。 Contract: 定义服务的交互契约，促使松耦合 Interface: 对外暴露服务功能基本原则： 复用性：模块化的服务，并且可以被多个应用复用。 可发现性：服务注册。 可组合性：可以支持任意方法进行服务的组合。 松耦合：服务之间互相独立，通过标准接口进行通信。挑战： 服务的版本和兼容性 数据的完整性和一致性 业务处理的复杂性 其他差异：SOA 与微服务 SOA 微服务 实施 共享资源的不同服务。 独立且针对特定用途的小型服务。 交流 ESB 使用多种消息协议，例如 SOAP、AMQP 和 MSMQ。 API、Java 消息服务、发布&#x2F;订阅 数据存储 共享数据存储。 独立的数据存储。 部署 具有挑战性。细微更改也需要全面重构。 易于部署。每个微服务都可以容器化。 可重用性 通过共享公共资源提供可重复使用的服务。 每项服务都有自己的独立资源。您可以通过微服务的 API 重复使用微服务。 速度 速度会随着服务增多而减慢。 可在流量增长时保持稳定的速度。 治理灵活性 跨所有服务进行一致的数据治理。 针对每种存储采用不同的数据治理策略。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"","slug":"SpringBoot/SpringBoot：扩展点","date":"2024-09-02T11:02:01.624Z","updated":"2024-09-02T11:02:20.069Z","comments":true,"path":"2024/09/02/SpringBoot/SpringBoot：扩展点/","permalink":"https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E6%89%A9%E5%B1%95%E7%82%B9/","excerpt":"","text":"背景Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是封装了Spring，遵循约定大于配置，加上自动装配的机制。很多时候我们只要引用了一个依赖，几乎是零配置就能完成一个功能的装配。 我非常喜欢这种自动装配的机制，所以在自己开发中间件和公共依赖工具的时候也会用到这个特性。让使用者以最小的代价接入。想要把自动装配玩的转，就必须要了解spring对于bean的构造生命周期以及各个扩展接口。当然了解了bean的各个生命周期也能促进我们加深对spring的理解。业务代码也能合理利用这些扩展点写出更加漂亮的代码。 在网上搜索Spring扩展点，发现很少有博文说的很全的，只有一些常用的扩展点的说明。 所以在这篇文章里，我总结了几乎Spring &amp; Springboot所有的扩展接口，以及各个扩展点的使用场景。并且整理出了一个bean在spring内部从被加载到最后初始化完成所有可扩展点的顺序调用图。从而我们也能窥探到bean是如何一步步加载到spring容器中的。 可扩展的接口启动调用顺序图以下是我整理的spring容器中Bean的生命周期内所有可扩展的点的调用顺序，下面会一个个分析 1. ApplicationContextInitializer org.springframework.context.ApplicationContextInitializer 这是整个spring容器在刷新之前初始化ConfigurableApplicationContext的回调接口，简单来说，就是在容器刷新之前调用此类的initialize方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。 可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。 1public class TestApplicationContextInitializer implements ApplicationContextInitializer &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(&quot;[ApplicationContextInitializer]&quot;); &#125; &#125; 因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式： 在启动类中用springApplication.addInitializers(new TestApplicationContextInitializer())语句加入 配置文件配置context.initializer.classes=com.example.demo.TestApplicationContextInitializer Spring SPI扩展，在spring.factories中加入org.springframework.context.ApplicationContextInitializer=com.example.demo.TestApplicationContextInitializer 2. BeanDefinitionRegistryPostProcessor org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor 这个接口在读取项目中的beanDefinition之后执行，提供一个补充的扩展点。 使用场景：你可以在这里动态注册自己的beanDefinition，可以加载classpath之外的bean 扩展方式为: 1public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123; @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;); &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;); &#125; &#125; 3. BeanFactoryPostProcessor org.springframework.beans.factory.config.BeanFactoryPostProcessor 这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。 在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。 扩展方式为： 1public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; System.out.println(&quot;[BeanFactoryPostProcessor]&quot;); &#125; &#125; 4. InstantiationAwareBeanPostProcessor org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor 该接口继承了BeanPostProcess接口，区别如下： BeanPostProcess接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而InstantiationAwareBeanPostProcessor接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。 该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：实例化阶段 和初始化阶段 ，下面一起进行说明，按调用顺序为： postProcessBeforeInstantiation：实例化bean之前，相当于new这个bean之前 postProcessAfterInstantiation：实例化bean之后，相当于new这个bean之后 postProcessPropertyValues：bean已经实例化完成，在属性注入时阶段触发，@Autowired,@Resource等注解原理基于此方法实现 postProcessBeforeInitialization：初始化bean之前，相当于把bean注入spring上下文之前 postProcessAfterInitialization：初始化bean之后，相当于把bean注入spring上下文之后 使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。 扩展方式为： 1public class TestInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot; + beanName); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot; + beanName); return bean; &#125; @Override public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123; System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot; + beanName); return null; &#125; @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot; + beanName); return true; &#125; @Override public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot; + beanName); return pvs; &#125; 5. SmartInstantiationAwareBeanPostProcessor org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor 该扩展接口有3个触发点方法： predictBeanType： 该触发点发生在postProcessBeforeInstantiation之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。 determineCandidateConstructors： 该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。 getEarlyBeanReference： 该触发点发生在postProcessAfterInstantiation之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。 扩展方式为： 1public class TestSmartInstantiationAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor &#123; @Override public Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123; System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot; + beanName); return beanClass; &#125; @Override public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123; System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot; + beanName); return null; &#125; @Override public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot; + beanName); return bean; &#125; &#125; 6. BeanFactoryAware org.springframework.beans.factory.BeanFactoryAware 这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为setBeanFactory，可以拿到BeanFactory这个属性。 使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。也或者可以把BeanFactory拿到进行缓存，日后使用。 扩展方式为： 1public class TestBeanFactoryAware implements BeanFactoryAware &#123; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println(&quot;[TestBeanFactoryAware] &quot; + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName()); &#125; &#125; 7. ApplicationContextAwareProcessor org.springframework.context.support.ApplicationContextAwareProcessor 该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前 可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。所以这里应该来说是有6个扩展点 ，这里就放一起来说了 EnvironmentAware： 用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。 EmbeddedValueResolverAware： 用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取，如果实现了这个Aware接口，把StringValueResolver缓存起来，通过这个类去获取String类型的变量，效果是一样的。 ResourceLoaderAware： 用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。 ApplicationEventPublisherAware： 用于获取ApplicationEventPublisher的一个扩展类，ApplicationEventPublisher可以用来发布事件，结合ApplicationListener来共同使用，下文在介绍ApplicationListener时会详细提到。这个对象也可以通过spring注入的方式来获得。 MessageSourceAware： 用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。 ApplicationContextAware： 用来获取ApplicationContext的一个扩展类，ApplicationContext应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时ApplicationContext也实现了BeanFactory，MessageSource，ApplicationEventPublisher等接口，也可以用来做相关接口的事情。 8. BeanNameAware org.springframework.beans.factory.BeanNameAware 可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是postProcessBeforeInitialization之前，这个类的触发点方法只有一个：setBeanName 使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。 扩展方式为： 1public class NormalBeanA implements BeanNameAware&#123; public NormalBeanA() &#123; System.out.println(&quot;NormalBean constructor&quot;); &#125; @Override public void setBeanName(String name) &#123; System.out.println(&quot;[BeanNameAware] &quot; + name); &#125; &#125; 9. @PostConstruct javax.annotation.PostConstruct 这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了@PostConstruct，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在postProcessBeforeInitialization之后，InitializingBean.afterPropertiesSet之前。 使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性 扩展方式为： 1public class NormalBeanA &#123; public NormalBeanA() &#123; System.out.println(&quot;NormalBean constructor&quot;); &#125; @PostConstruct public void init()&#123; System.out.println(&quot;[PostConstruct] NormalBeanA&quot;); &#125; &#125; 10. InitializingBean org.springframework.beans.factory.InitializingBean 这个类，顾名思义，也是用来初始化bean的。InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在postProcessAfterInitialization之前。 使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。 扩展方式为： 1public class NormalBeanA implements InitializingBean&#123; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;[InitializingBean] NormalBeanA&quot;); &#125; &#125; 11. FactoryBean org.springframework.beans.factory.FactoryBean 一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean&lt;T&gt;的形式 使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿ProxyFactoryBean的功能。 扩展方式为： 1public class TestFactoryBean implements FactoryBean&lt;TestFactoryBean.TestFactoryInnerBean&gt; &#123; @Override public TestFactoryBean.TestFactoryInnerBean getObject() throws Exception &#123; System.out.println(&quot;[FactoryBean] getObject&quot;); return new TestFactoryBean.TestFactoryInnerBean(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return TestFactoryBean.TestFactoryInnerBean.class; &#125; @Override public boolean isSingleton() &#123; return true; &#125; public static class TestFactoryInnerBean&#123; &#125; &#125; 12. SmartInitializingSingleton org.springframework.beans.factory.SmartInitializingSingleton 这个接口中只有一个方法afterSingletonsInstantiated，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为postProcessAfterInitialization之后。 使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。 扩展方式为： 1public class TestSmartInitializingSingleton implements SmartInitializingSingleton &#123; @Override public void afterSingletonsInstantiated() &#123; System.out.println(&quot;[TestSmartInitializingSingleton]&quot;); &#125; &#125; 13. CommandLineRunner org.springframework.boot.CommandLineRunner 这个接口也只有一个方法：run(String... args)，触发时机为整个项目启动完毕后，自动执行。如果有多个CommandLineRunner，可以利用@Order来进行排序。 使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。 扩展方式为： 1public class TestCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;[TestCommandLineRunner]&quot;); &#125; &#125; 14. DisposableBean org.springframework.beans.factory.DisposableBean 这个扩展点也只有一个方法：destroy()，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。 扩展方式为： 1public class NormalBeanA implements DisposableBean &#123; @Override public void destroy() throws Exception &#123; System.out.println(&quot;[DisposableBean] NormalBeanA&quot;); &#125; &#125; 15. ApplicationListener org.springframework.context.ApplicationListener 准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，ApplicationListener可以监听某个事件的event，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。 接下来罗列下spring主要的内置事件： ContextRefreshedEvent ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext接口中使用 refresh()方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。 ContextStartedEvent 当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 ContextStoppedEvent 当使用 ConfigurableApplicationContext接口中的 stop()停止ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作 ContextClosedEvent 当使用 ConfigurableApplicationContext接口中的 close()方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启 RequestHandledEvent 这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件 最后我们从这些spring&amp;springboot的扩展点当中，大致可以窥视到整个bean的生命周期。在业务开发或者写中间件业务的时候，可以合理利用spring提供给我们的扩展点，在spring启动的各个阶段内做一些事情。以达到自定义初始化的目的。此篇总结，如果有错误或者疏漏的地方，恳请指正。","categories":[],"tags":[]},{"title":"","slug":"接口设计/面向接口：限流","date":"2024-09-02T10:58:29.715Z","updated":"2024-09-02T10:59:19.508Z","comments":true,"path":"2024/09/02/接口设计/面向接口：限流/","permalink":"https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%99%90%E6%B5%81/","excerpt":"","text":"很早以前，我曾写过两篇介绍如何在SpringBoot中使用Guava和Redis实现接口限流的文章。具体包括： 使用Guava实现单机令牌桶限流 使用Redis实现分布式限流 现在，一个问题摆在我们面前：如何将这两种限流机制整合到同一个组件中，以便用户随时切换呢？ 显然，我们需要定义一个通用的限流组件，将其引入到业务中，并支持通过配置文件自由切换不同的限流机制。举例而言，当使用limit.type=redis时，启用Redis分布式限流组件，当使用limit.type=local时，启用Guava限流组件。这种自由切换机制能够为用户提供更大的灵活性和可维护性。 接下来，让我们开始动手实现吧！ 第一步，创建通用模块cloud-limiter-starter首先在父项目下创建一个模块 然后在pom文件中引入相关依赖 1&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringFramework--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 小提示：通用模块命名最好遵照规则以starter命名结束，同时通用模块引入的依赖最好设置&lt;scope&gt;provided&lt;/scope&gt;属性。 第二步，实现限流功能 创建限流接口 既然有两种限流机制，按照套路肯定得先创建一个限流接口，就叫LimiterManager吧。 1public interface LimiterManager &#123; boolean tryAccess(Limiter limiter);&#125; 分别实现Redis的限流功能和Guava的限流功能，这里只给出核心代码。 Guava限流的核心实现GuavaLimiter 1@Slf4jpublic class GuavaLimiter implements LimiterManager&#123; private final Map&lt;String, RateLimiter&gt; limiterMap = Maps.newConcurrentMap(); @Override public boolean tryAccess(Limiter limiter) &#123; RateLimiter rateLimiter = getRateLimiter(limiter); if (rateLimiter == null) &#123; return false; &#125; boolean access = rateLimiter.tryAcquire(1,100, TimeUnit.MILLISECONDS); log.info(&quot;&#123;&#125; access :&#123;&#125;&quot;,limiter.getKey() , access); return access; &#125;&#125; Redis限流的核心实现RedisLimiter 1@Slf4jpublic class RedisLimiter implements LimiterManager&#123; private final StringRedisTemplate stringRedisTemplate; public RedisLimiter(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean tryAccess(Limiter limiter) &#123; String key = limiter.getKey(); if (StringUtils.isEmpty(key)) &#123; throw new LimiterException( &quot;redis limiter key cannot be null&quot; ); &#125; List&lt;String&gt; keys = new ArrayList&lt;&gt;(); keys.add( key ); int seconds = limiter.getSeconds(); int limitCount = limiter.getLimitNum(); String luaScript = buildLuaScript(); RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(luaScript, Long.class); Long count = stringRedisTemplate.execute( redisScript, keys, &quot;&quot; + limitCount, &quot;&quot; + seconds ); log.info( &quot;Access try count is &#123;&#125; for key=&#123;&#125;&quot;, count, key ); return count != null &amp;&amp; count != 0; &#125;&#125; 第三步，创建配置类编写配置类根据配置文件注入限流实现类，当配置文件中属性 limit.type=local 时启用Guava限流机制，当limit.type=redis 时启用Redis限流机制。 1@Configurationpublic class LimiterConfigure &#123; @Bean @ConditionalOnProperty(name = &quot;limit.type&quot;,havingValue = &quot;local&quot;) public LimiterManager guavaLimiter()&#123; return new GuavaLimiter(); &#125; @Bean @ConditionalOnProperty(name = &quot;limit.type&quot;,havingValue = &quot;redis&quot;) public LimiterManager redisLimiter(StringRedisTemplate stringRedisTemplate)&#123; return new RedisLimiter(stringRedisTemplate); &#125;&#125; 第四步，创建AOP根据前面的两篇文章可知，避免限流功能污染业务逻辑的最好方式是借助Spring AOP，所以很显然还得需要创建一个AOP。 1@Aspect@EnableAspectJAutoProxy(proxyTargetClass = true) //使用CGLIB代理@Conditional(LimitAspectCondition.class)public class LimitAspect &#123; @Setter(onMethod_ = @Autowired) private LimiterManager limiterManager; @Pointcut(&quot;@annotation(com.jianzh5.limit.aop.Limit)&quot;) private void check() &#123; &#125; @Before(&quot;check()&quot;) public void before(JoinPoint joinPoint)&#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); Limit limit = method.getAnnotation(Limit.class); if(limit != null)&#123; Limiter limiter = Limiter.builder().limitNum(limit.limitNum()) .seconds(limit.seconds()) .key(limit.key()).build(); if(!limiterManager.tryAccess(limiter))&#123; throw new LimiterException( &quot;There are currently many people , please try again later!&quot; ); &#125; &#125; &#125;&#125; 注意到类上我加了一行@Conditional(LimitAspectCondition.class)，使用了自定义条件选择器，意思是只有当配置类中出现了limit.type属性时才会加载这个AOP。 1public class LimitAspectCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; //检查配置文件是否包含limit.type属性 return conditionContext.getEnvironment().containsProperty(ConfigConstant.LIMIT_TYPE); &#125;&#125; 第四步，创建spring.factories文件，引导SpringBoot加载配置类1## AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.jianzh5.limit.config.LimiterConfigure,\\ com.jianzh5.limit.aop.LimitAspect 完整目录结构如下： 第五步，在项目中引用限流组件 引入依赖 1&lt;dependency&gt; &lt;groupId&gt;com.jianzh5&lt;/groupId&gt; &lt;artifactId&gt;cloud-limit-starter&lt;/artifactId&gt;&lt;/dependency&gt; 在application.properties中设置加载的限流组件 1limit.type = redis 如果不配置此属性则不加载对应限流功能。 在需要限流的接口上加上注解1@Limit(key = &quot;Limiter:test&quot;,limitNum = 3,seconds = 1) 小结通过上述步骤，我们已经成功实现了一个通用限流组件。在实际应用中，只需要根据场景需求选择对应的限流机制，即可非常方便的进行限流操作。这种灵活性和便捷性，也是SpringBoot中定义Starter的一般套路。","categories":[],"tags":[]},{"title":"SpringBoot GraphQL","slug":"SpringBoot/SpringBoot：GraphQL","date":"2024-09-02T10:36:22.017Z","updated":"2024-09-02T10:41:42.844Z","comments":true,"path":"2024/09/02/SpringBoot/SpringBoot：GraphQL/","permalink":"https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9AGraphQL/","excerpt":"","text":"概述REST作为一种现代网络应用非常流行的软件架构风格受到广大WEB开发者的喜爱，在目前软件架构设计模式中随处可见REST的身影，但是随着REST的流行与发展，它的一个最大的缺点开始暴露出来： 在很多时候客户端需要的数据往往在不同的地方具有相似性，但却又不尽相同。 如同样的用户信息，在有的场景下前端只需要用户的简要信息（名称、头像），在其他场景下又需要用户的详细信息。当这样的相似但又不同的地方多的时候，就需要开发更多的接口来满足前端的需要。 随着这样的场景越来越多，接口越来越多，文档越来越臃肿，前后端沟通成本呈指数增加。 基于上面的场景，我们迫切需要有一种解决方案或框架，可以使得在使用同一个领域模型（DO、DTO）的数据接口时可以由前端指定需要的接口字段，而后端根据前端的需求自动适配并返回对应的字段。 这就是我们今天的主角GraphQL。 场景模拟考虑下面的场景： 用户 与 文章 是一对多的关系，一个用户可以发表多篇文章，同时又可以根据文章找到对应的作者。 我们需要构建以下几个Graphql查询： 根据用户ID获取用户详情，并获取此用户发表的所有文章 根据文章ID获取文章详情，并获取文章作者的信息 当然项目是基于SpringBoot开发的。 开发实战在正式开发之前我推荐你在IDEA上安装一下 JS GraphQL插件，这个插件方便我们编写Schema，语法纠错，代码高亮等等。。。 创建一个SpringBoot项目通过IDEA创建一个SpringBoot项目，并引入对应的jar 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--graphql start--&gt;&lt;dependency&gt; &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;&lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;5.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.graphql-java&lt;/groupId&gt; &lt;artifactId&gt;graphql-java-tools&lt;/artifactId&gt; &lt;version&gt;5.2.4&lt;/version&gt;&lt;/dependency&gt; &lt;!--graphql end--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这里主要需要引入 graphql-spring-boot-starter和 graphql-java-tools。 建立Java实体类User 1@Datapublic class User &#123; private int userId; private String userName; private String realName; private String email; private List&lt;Post&gt; posts; public User() &#123; &#125; public User(int userId, String userName, String realName, String email) &#123; this.userId = userId; this.userName = userName; this.realName = realName; this.email = email; &#125;&#125; Post 1@Datapublic class Post &#123; private int postId; private String title ; private String text; private String category; private User user; public Post() &#123; &#125; public Post(int postId, String title, String text, String category) &#123; this.postId = postId; this.title = title; this.text = text; this.category = category; &#125;&#125; 定义了两个JAVA实体：Post，User。 编写Schema文件在resources&#x2F;schema目录下创建GraphQL Schema文件 123456789101112131415161718192021222324252627schema &#123; query: Query,&#125;type Query &#123; # 获取具体的用户 getUserById(id:Int) : User # 获取具体的博客 getPostById(id:Int) : Post&#125;type User &#123; userId : ID!, userName : String, realName : String, email : String, posts : [Post],&#125;type Post &#123; postId : ID!, title : String!, text : String, category: String user: User,&#125; 如上，我们通过 type关键字定义了两个对象，User与Post。在属性后面添加！表明这是一个非空属性，通过[Post]表明这是一个Post集合，类似于Java对象中List。 通过Query关键字定义了两个查询对象，getUserById，getPostById，分别返回User对象和Post对象。 关于schema的语法大家可以参考链接：https://graphql.org/learn/schema 编写业务逻辑PostService 1234567891011121314@Servicepublic class PostService implements GraphQLQueryResolver &#123; /** * 为了测试，只查询id为1的结果 */ public Post getPostById(int id)&#123; if(id == 1)&#123; User user = new User(1,&quot;javadaily&quot;,&quot;JAVA日知录&quot;,&quot;zhangsan@qq.com&quot;); Post post = new Post(1,&quot;Hello,Graphql&quot;,&quot;Graphql初体验&quot;,&quot;日记&quot;); post.setUser(user); return post; &#125;else&#123; return null; &#125; &#125;&#125; UserService 12345678910111213141516171819202122232425@Servicepublic class UserService implements GraphQLQueryResolver &#123; List&lt;User&gt; userList = Lists.newArrayList(); public User getUserById(int id)&#123; return userList.stream() .filter(item &gt; item.getUserId() == id) .findAny() .orElse(null); &#125; @PostConstruct public void initUsers()&#123; Post post1 = new Post(1,&quot;Hello,Graphql1&quot;,&quot;Graphql初体验1&quot;,&quot;日记&quot;); Post post2 = new Post(2,&quot;Hello,Graphql2&quot;,&quot;Graphql初体验2&quot;,&quot;日记&quot;); Post post3 = new Post(3,&quot;Hello,Graphql3&quot;,&quot;Graphql初体验3&quot;,&quot;日记&quot;); List&lt;Post&gt; posts = Lists.newArrayList(post1,post2,post3); User user1 = new User(1,&quot;zhangsan&quot;,&quot;张三&quot;,&quot;zhangsan@qq.com&quot;); User user2 = new User(2,&quot;lisi&quot;,&quot;李四&quot;,&quot;lisi@qq.com&quot;); user1.setPosts(posts); user2.setPosts(posts); userList.add(user1); userList.add(user2); &#125;&#125; 基于Graphql的查询需要实现 GraphQLQueryResolver接口，由于为了便于演示我们并没有引入数据层，请大家知悉。 配置Graphql 端点1234server.port = 8080graphql.servlet.corsEnabled=true# 配置端点graphql.servlet.mapping=/graphqlgraphql.servlet.enabled=true 配置完端口和端点后我们就可以对我们编写的Graphql接口进行测试了。 接口地址为：localhost:8080/graphql 测试这里我使用的是Chrome浏览器的 Altair Graphal Client插件，当然你还可以使用其他的客户端工具，如：graphql-playground。 安装插件浏览器输入chrome:&#x2F;&#x2F;extensions&#x2F;，在扩展中心搜索Altair后即可添加至浏览器。 查询启动SpringBoot项目，然后在打开的Altair插件界面，输入Graphql端点 http://localhost:8080/graphql，然后点击 Docs，将鼠标移至需要的查询上，点击 ADD QUERY 即可添加对应的查询。 点击Send Request 即可看到查询结果： 然后我们在Query中可以根据我们的需要新增或删除接口字段并重新请求接口，会看到响应结果中也会根据我们的请求自动返回结果： 小结Graphql支持的数据操作有： 查询（Query）：获取数据的基本查询。 变更（Mutation）：支持对数据的增删改等操作。 订阅（Subscription）：用于监听数据变动、并靠websocket等协议推送变动的消息给对方。 本节内容我们基于SpringBoot完成了Query的数据操作，实现过程还是相对比较简单。希望此文能让大家对Graphql有一个整体的了解，如果大家对Graphql感兴趣后面还会更新此系列文章，完成对其他数据操作的整合。","categories":[],"tags":[]},{"title":"SpringBoot: 启动参数","slug":"SpringBoot/SpringBoot：容器参数优化","date":"2024-09-02T09:02:25.399Z","updated":"2024-09-02T10:11:44.630Z","comments":true,"path":"2024/09/02/SpringBoot/SpringBoot：容器参数优化/","permalink":"https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/","excerpt":"","text":"12345server: tomcat: min-spare-threads: 20 max-threads: 100 connection-timeout: 5000 目前的容器优化，目前来说没有太多地方，需要考虑如下几个点 线程数 超时时间 这块对tomcat进行了一个优化配置，最大线程数是100，初始化线程是20, 超时时间是5000ms 默认tomcat最大线程数200，初始化线程10, 连接超时时间20s ⚠️upload failed, check dev console ⚠️upload failed, check dev console","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://andy-whb-cn.github.io/tags/SpringBoot/"}]},{"title":"Restful API 版本控制","slug":"接口设计/面向接口：Restful API 版本控制","date":"2024-09-02T08:47:53.483Z","updated":"2024-09-02T08:57:11.861Z","comments":true,"path":"2024/09/02/接口设计/面向接口：Restful API 版本控制/","permalink":"https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9ARestful%20API%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","excerpt":"","text":"在实际项目开发中我们经常需要对接口进行版本管理。那今天我们就来聊聊为什么需要版本控制，以及如何对REST API进行版本控制。我们将讨论4种版本控制的方法，并比较不同的方法。 通过此文您将学到 为什么我们需要对RESTful API 进行版本控制? 可用的版本控制有哪些? 如何实现基于 Restful 的版本控制? 为什么我们需要对RESTful API进行版本化最好的版本控制方法是不进行版本控制。 构建向后兼容的服务，以便尽可能避免版本控制！ 然而，在许多情况下我们都需要进行版本控制，然我们看看下面具体的例子：最初，你有个这个版本的Student服务，返回数据如下：&#123; &quot;name&quot;: &quot;Bob Charlie&quot; &#125; 后来，您希望将学生的名字拆分，因此创建了这个版本的服务。&#123; &quot;name&quot;: &#123; &quot;firstName&quot;: &quot;Bob&quot;, &quot;lastName&quot;: &quot;Charlie&quot; &#125; &#125; 您可以从同一个服务支持这两个请求，但是随着每个版本的需求多样化，它会变得越来越复杂。 在这种情况下，版本控制就成必不可少，强制性的了。 接下来让我们创建一个简单的SpringBoot的maven项目，并理解对 RESTful 服务进行版本控制的4种不同方法。 几个用于实现版本控制的Bean 第一个版本的 Bean 12345@Data @AllArgsConstructor public class StudentV1 &#123; private String name; &#125; ` 第二个版本的 Bean 1234@Data public class StudentV2 &#123; private Name name; &#125; StudentV2使用的Name实体 123456@Data @AllArgsConstructor public class Name &#123; private String firstName; private String lastName; &#125; Restful 版本控制的方法我们希望创建两个版本的服务，一个返回 StudentV1，另一个返回 StudentV2。 让我们来看看创建相同服务版本的4种不同方法。 通过 URI 进行版本控制12345678910111213@RestController public class StudentUriController &#123; @GetMapping(&quot;v1/student&quot;) public StudentV1 studentV1() &#123; return new StudentV1(&quot;javadaily&quot;); &#125; @GetMapping(&quot;v2/student&quot;) public StudentV2 studentV2() &#123; return new StudentV2(new Name(&quot;javadaily&quot;, &quot;JAVA日知录&quot;)); &#125; &#125; 请求：http://localhost:8080/v1/student响应：{“name”:”javadaily”} 请求：http://localhost:8080/v2/student响应：{“name”:{“firstName”:”javadaily”,”lastName”:”JAVA日知录”}} 通过请求参数进行版本控制版本控制的第二种方法是使用请求参数来区分版本。请求示例如下所示： http://localhost:8080/student/param?version=1 http://localhost:8080/student/param?version=2 实现方式如下： 12345678910111213@RestController public class StudentParmController &#123; @GetMapping(value=&quot;/student/param&quot;, params = &quot;version=1&quot;) public StudentV1 studentV1() &#123; return new StudentV1(&quot;javadaily&quot;); &#125; @GetMapping(value=&quot;/student/param&quot;, params = &quot;version=2&quot;) public StudentV2 studentV2() &#123; return new StudentV2(new Name(&quot;javadaily&quot;, &quot;JAVA日知录&quot;)); &#125; &#125; 请求：http://localhost:8080/student/param?version=1响应：{“name”:”javadaily”} 请求：http://localhost:8080/student/param?version=2响应：{“name”:{“firstName”:”javadaily”,”lastName”:”JAVA日知录”}} 通过自定义Header进行版本控制版本控制的第三种方法是使用请求头来区分版本，请求示例如下： http://localhost:8080/student/header headers&#x3D;[X-API-VERSION&#x3D;1] http://localhost:8080/student/header headers&#x3D;[X-API-VERSION&#x3D;2] 实现方式如下所示： 123456789101112@RestController public class StudentHeaderController &#123; @GetMapping(value=&quot;/student/header&quot;,headers = &quot;X-API-VERSION=1&quot;) public StudentV1 studentV1() &#123; return new StudentV1(&quot;javadaily&quot;); &#125; @GetMapping(value=&quot;/student/header&quot;,headers = &quot;X-API-VERSION=2&quot;) public StudentV2 studentV2() &#123; return new StudentV2(new Name(&quot;javadaily&quot;, &quot;JAVA日知录&quot;)); &#125; &#125; 下图展示了我们如何使用Postman执行带有请求头的Get请求方法。 请求：http://localhost:8080/student/headerheader：X-API-VERSION = 1 请求：http://localhost:8080/student/headerheader：X-API-VERSION = 2 通过媒体类型进行版本控制最后一种版本控制方法是在请求中使用Accept Header，请求示例如下： http://localhost:8080/student/produce headers=[Accept=application/api-v1+json] http://localhost:8080/student/produce headers=[Accept=application/api-v2+json] 实现方式如下： 1234567891011@RestController public class StudentProduceController &#123; @GetMapping(value=&quot;/student/produce&quot;,produces = &quot;application/api-v1+json&quot;) public StudentV1 studentV1() &#123; return new StudentV1(&quot;javadaily&quot;); &#125; @GetMapping(value=&quot;/student/produce&quot;,produces = &quot;application/api-v2+json&quot;) public StudentV2 studentV2() &#123; return new StudentV2(new Name(&quot;javadaily&quot;, &quot;JAVA日知录&quot;)); &#125; &#125; 下图展示了我们如何使用Postman执行带有请求Accept的Get方法。 请求：http://localhost:8080/student/produceheader：Accept = application/api-v1+json 请求：http://localhost:8080/student/produceheader：Accept = application/api-v2+json 影响版本选择的因素以下因素影响版本控制的选择 URI 污染 - URL版本和请求参数版本控制会污染URI空间。 滥用请求头 - Accept 请求头并不是为版本控制而设计的。 缓存 - 如果你使用基于头的版本控制，我们不能仅仅基于URL缓存，你需要考虑特定的请求头。 是否能在浏览器直接执行 ? - 如果您有非技术消费者，那么基于URL的版本将更容易使用，因为它们可以直接在浏览器上执行。 API文档 - 如何让文档生成理解两个不同的url是同一服务的版本？ 事实上，并没有完美的版本控制解决方案，你需要根据项目实际情况进行选择。 下面列表展示了主要API提供商使用的不同版本控制方法： 媒体类型的版本控制 Github 自定义Header Microsoft URI路径 Twitter，百度，知乎 请求参数控制 Amazon 好了，今天的文章就到这里了，希望能对你有所帮助。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"微服务","slug":"微服务","permalink":"https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"SpringBoot：参数校验","slug":"SpringBoot/SpringBoot：输入参数校验","date":"2024-09-02T07:13:41.928Z","updated":"2024-09-02T08:40:22.474Z","comments":true,"path":"2024/09/02/SpringBoot/SpringBoot：输入参数校验/","permalink":"https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"https://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247512866&amp;idx=1&amp;sn=f9d1549dc312c48a9fde14fb1fdb5d07&amp;chksm=9ad3a963ada420756be6f848faef228d08b2ea49d87d2c083eabd6a2cf184cefa2ed8fa05964&amp;cur_album_id=1517924978380308484&amp;scene=189#wechat_redirect 首先我们来看看什么是Validator参数校验器，为什么需要参数校验？ 为什么需要参数校验在日常的接口开发中，为了防止非法参数对业务造成影响，经常需要对接口的参数做校验，例如登录的时候需要校验用户名密码是否为空，创建用户的时候需要校验邮件、手机号码格式是否准确。靠代码对接口参数一个个校验的话就太繁琐了，代码可读性极差。 Validator框架就是为了解决开发人员在开发的时候少写代码，提升开发效率；Validator专门用来进行接口参数校验，例如常见的必填校验，email格式校验，用户名必须位于6到12之间 等等… Validator校验框架遵循了JSR-303验证规范（参数校验规范）, JSR是Java Specification Requests的缩写。接下来我们看看在SpringbBoot中如何集成参数校验框架。 SpringBoot中集成参数校验第一步，引入依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 注：从springboot-2.3开始，校验包被独立成了一个starter组件，所以需要引入validation和web，而springboot-2.3之前的版本只需要引入 web 依赖就可以了。 第二步，定义要参数校验的实体类12345678910111213141516171819@Data public class ValidVO &#123; private String id; @Length(min = 6,max = 12,message = &quot;appId长度必须位于6到12之间&quot;) private String appId; @NotBlank(message = &quot;名字为必填项&quot;) private String name; @Email(message = &quot;请填写正确的邮箱地址&quot;) private String email; private String sex; @NotEmpty(message = &quot;级别不能为空&quot;) private String level; &#125; 在实际开发中对于需要校验的字段都需要设置对应的业务提示，即message属性。常见的约束注解如下： 注解 功能 @AssertFalse 可以为null,如果不为null的话必须为false @AssertTrue 可以为null,如果不为null的话必须为true @DecimalMax 设置不能超过最大值 @DecimalMin 设置不能超过最小值 @Digits 设置必须是数字且数字整数的位数和小数的位数必须在指定范围内 @Future 日期必须在当前日期的未来 @Past 日期必须在当前日期的过去 @Max 最大不得超过此最大值 @Min 最大不得小于此最小值 @NotNull 不能为null，可以是空 @Null 必须为null @Pattern 必须满足指定的正则表达式 @Size 集合、数组、map等的size()值必须在指定范围内 @Email 必须是email格式 @Length 长度必须在指定范围内 @NotBlank 字符串不能为null,字符串trim()后也不能等于“” @NotEmpty 不能为null，集合、数组、map等size()不能为0；字符串trim()后可以等于“” @Range 值必须在指定范围内 @URL 必须是一个URL 注：此表格只是简单的对注解功能的说明，并没有对每一个注解的属性进行说明；可详见源码。 在Controller层对需要参数校验的方法加上@Validated注解 参数校验一般分为两类：在Controller使用模型接收数据时， @Validated注解直接放在该模型参数前即可。 1234567@PostMapping(value = &quot;test1&quot;) public String test1(@Validated @RequestBody ValidEntity validEntity)&#123; return &quot;test1 valid success&quot;; &#125; @PostMapping(value = &quot;test3&quot;) public String test3(@Validated ValidEntity validEntity)&#123; return &quot;test3 valid success&quot;; &#125; 当我们是直接在Controller层中的参数前，使用约束注解时，@Validated要直接放在类上 1234@PostMapping(value = &quot;test2&quot;) public String test2(@Email String email)&#123; return &quot;test2 valid success&quot;; &#125; 此时需要在主类上增加@Validated注解 123456@Validated @RestController @RequestMapping(&quot;/demo/valid&quot;) public class ValidController &#123; ... &#125; 在参数校验时我们既可以使用@Validated也可以使用@Valid注解，两者功能大部分类似；主要区别在于：@Valid属于javax下的，而@Validated属于spring下；@Valid支持嵌套校验、而@Validated不支持，@Validated支持分组，而@Valid不支持。@Validated： 用在类、方法和方法参数上，但不能用于成员属性。@Valid：可以用在方法、构造函数、方法参数和成员属性上@Validated和@Valid支持混合使用 第三步，定义校验类进行测试1234567891011121314151617181920212223242526@RestController @Slf4j @Validated public class ValidController &#123; @ApiOperation(&quot;RequestBody校验&quot;) @PostMapping(&quot;/valid/test1&quot;) public String test1(@Validated @RequestBody ValidVO validVO)&#123; log.info(&quot;validEntity is &#123;&#125;&quot;, validVO); return &quot;test1 valid success&quot;; &#125; @ApiOperation(&quot;Form校验&quot;) @PostMapping(value = &quot;/valid/test2&quot;) public String test2(@Validated ValidVO validVO)&#123; log.info(&quot;validEntity is &#123;&#125;&quot;, validVO); return &quot;test2 valid success&quot;; &#125; @ApiOperation(&quot;单参数校验&quot;) @PostMapping(value = &quot;/valid/test3&quot;) public String test3(@Email String email)&#123; log.info(&quot;email is &#123;&#125;&quot;, email); return &quot;email valid success&quot;; &#125; &#125; 这里我们先定义三个方法test1，test2，test3，test1使用了@RequestBody注解，用于接受前端发送的json数据，test2模拟表单提交，test3模拟单参数提交。注意，当使用单参数校验时需要在Controller上加上@Validated注解，否则不生效。 第四步，体验效果 调用test1方法，提示的是org.springframework.web.bind.MethodArgumentNotValidException异常POST http://localhost:8080/valid/test1 Content-Type: application/json &#123; &quot;id&quot;: 1, &quot;level&quot;: &quot;12&quot;, &quot;email&quot;: &quot;47693899&quot;, &quot;appId&quot;: &quot;ab1c&quot; &#125; 123456&#123; &quot;status&quot;: 500, &quot;message&quot;: &quot;Validation failed for argument [0] in public java.lang.String com.jianzh5.blog.valid.ValidController.test1(com.jianzh5.blog.valid.ValidVO) with 3 errors: [Field error in object &#x27;validVO&#x27; on field &#x27;email&#x27;: rejected value [47693899]; codes [Email.validVO.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [validVO.email,email]; arguments []; default message [email],[Ljavax.validation.constraints.Pattern$Flag;@26139123,.*]; default message [不是一个合法的电子邮件地址]]...&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1628239624332 &#125; 调用test2方法，提示的是org.springframework.validation.BindException异常POST http://localhost:8080/valid/test2 Content-Type: application/x-www-form-urlencoded id=1&amp;level=12&amp;email=476938977&amp;appId=ab1c 1234567891011121314151617&#123; &quot;status&quot;: 500, &quot;message&quot;: &quot;org.springframework.validation.BeanPropertyBindingResult: 3 errors\\nField error in object &#x27;validVO&#x27; on field &#x27;name&#x27;: rejected value [null]; codes [NotBlank.validVO.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [validVO.name,name]; arguments []; default message [name]]; default message [名字为必填项]...&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1628239301951 &#125; ```3. 调用test3方法，提示的是`javax.validation.ConstraintViolationException`异常`POST http://localhost:8080/valid/test3 Content-Type: application/x-www-form-urlencoded email=476938977 ````json &#123; &quot;status&quot;: 500, &quot;message&quot;: &quot;test3.email: 不是一个合法的电子邮件地址&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1628239281022 &#125; 通过加入Validator校验框架可以帮助我们自动实现参数的校验。 参数异常加入全局异常处理器虽然我们之前定义了全局异常拦截器，也看到了拦截器确实生效了，但是Validator校验框架返回的错误提示太臃肿了，不便于阅读，为了方便前端提示，我们需要将其简化一下。 直接修改之前定义的RestExceptionHandler，单独拦截参数校验的三个异常：javax.validation.ConstraintViolationException，org.springframework.validation.BindException，org.springframework.web.bind.MethodArgumentNotValidException，代码如下： 12345678910111213141516171819202122@ExceptionHandler(value = &#123;BindException.class, ValidationException.class, MethodArgumentNotValidException.class&#125;) public ResponseEntity&lt;ResultData&lt;String&gt;&gt; handleValidatedException(Exception e) &#123; ResultData&lt;String&gt; resp = null; if (e instanceof MethodArgumentNotValidException) &#123; // BeanValidation exception MethodArgumentNotValidException ex = (MethodArgumentNotValidException) e; resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(), ex.getBindingResult().getAllErrors().stream() .map(ObjectError::getDefaultMessage) .collect(Collectors.joining(&quot;; &quot;)) ); &#125; else if (e instanceof ConstraintViolationException) &#123; // BeanValidation GET simple param ConstraintViolationException ex = (ConstraintViolationException) e; resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(), ex.getConstraintViolations().stream() .map(ConstraintViolation::getMessage) .collect(Collectors.joining(&quot;; &quot;)) ); &#125; else if (e instanceof BindException) &#123; // BeanValidation GET object param BindException ex = (BindException) e; resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(), ex.getAllErrors().stream() .map(ObjectError::getDefaultMessage) .collect(Collectors.joining(&quot;; &quot;)) ); &#125; return new ResponseEntity&lt;&gt;(resp,HttpStatus.BAD_REQUEST); &#125; 默认情况下在对参数进行校验时Spring Validation会校验完所有字段然后才抛出异常，可以通过配置开启 Fali Fast模式，一旦校验失败就立即返回。 12345678910111213@Configuration public class ValidatedConfig &#123; @Bean public Validator validator() &#123; ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class) .configure() // 快速失败模式 .failFast(true) .buildValidatorFactory(); return validatorFactory.getValidator(); &#125; &#125; 体验效果POST http://localhost:8080/valid/test1 Content-Type: application/json &#123; &quot;id&quot;: 1, &quot;level&quot;: &quot;12&quot;, &quot;email&quot;: &quot;47693899&quot;, &quot;appId&quot;: &quot;ab1c&quot; &#125; 123456&#123; &quot;status&quot;: 400, &quot;message&quot;: &quot;名字为必填项; 不是一个合法的电子邮件地址; appId长度必须位于6到12之间&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1628435116680 &#125; 是不是感觉清爽多了？ 自定义参数校验虽然Spring Validation 提供的注解基本上够用，但是面对复杂的定义，我们还是需要自己定义相关注解来实现自动校验。 比如上面实体类中的sex性别属性，只允许前端传递传 M，F 这2个枚举值，如何实现呢？ 第一步，创建自定义注解1234567891011121314151617181920@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;) @Retention(RUNTIME) @Repeatable(EnumString.List.class) @Documented @Constraint(validatedBy = EnumStringValidator.class)public @interface EnumString &#123; String message() default &quot;value not in enum values.&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; String[] value(); @Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;) @Retention(RUNTIME) @Documented @interface List &#123; EnumString[] value(); &#125; &#125; 第二步，自定义校验逻辑12345678910111213141516public class EnumStringValidator implements ConstraintValidator&lt;EnumString, String&gt; &#123; private List&lt;String&gt; enumStringList; @Override public void initialize(EnumString constraintAnnotation) &#123; enumStringList = Arrays.asList(constraintAnnotation.value()); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; if(value == null)&#123; return true; &#125; return enumStringList.contains(value); &#125; &#125; 第三步，在字段上增加注解123@ApiModelProperty(value = &quot;性别&quot;) @EnumString(value = &#123;&quot;F&quot;,&quot;M&quot;&#125;, message=&quot;性别只允许为F或M&quot;) private String sex; 第四步，体验效果POST http://localhost:8080/valid/test2 Content-Type: application/x-www-form-urlencoded id=1&amp;name=javadaily&amp;level=12&amp;email=476938977@qq.com&amp;appId=ab1cdddd&amp;sex=N 123456&#123; &quot;status&quot;: 400, &quot;message&quot;: &quot;性别只允许为F或M&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1628435243723 &#125; 分组校验一个VO对象在新增的时候某些字段为必填，在更新的时候又非必填。如上面的ValidVO中 id 和 appId 属性在新增操作时都是非必填，而在编辑操作时都为必填，name在新增操作时为必填，面对这种场景你会怎么处理呢？ 在实际开发中我见到很多同学都是建立两个VO对象，ValidCreateVO，ValidEditVO来处理这种场景，这样确实也能实现效果，但是会造成类膨胀，而且极其容易被开发老鸟们嘲笑。 其实Validator校验框架已经考虑到了这种场景并且提供了解决方案，就是分组校验，只不过很多同学不知道而已。要使用分组校验，只需要三个步骤： 第一步：定义分组接口12345678public interface ValidGroup extends Default &#123; interface Crud extends ValidGroup&#123; interface Create extends Crud&#123;&#125; interface Update extends Crud&#123;&#125; interface Query extends Crud&#123;&#125; interface Delete extends Crud&#123;&#125; &#125; &#125; 这里我们定义一个分组接口ValidGroup让其继承javax.validation.groups.Default，再在分组接口中定义出多个不同的操作类型，Create，Update，Query，Delete。至于为什么需要继承Default我们稍后再说。 第二步，在模型中给参数分配分组1234567891011121314151617181920212223@Data @ApiModel(value = &quot;参数校验类&quot;) public class ValidVO &#123; @ApiModelProperty(&quot;ID&quot;) @Null(groups = ValidGroup.Crud.Create.class) @NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;) private String id; @Null(groups = ValidGroup.Crud.Create.class) @NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;) @ApiModelProperty(value = &quot;应用ID&quot;,example = &quot;cloud&quot;) private String appId; @ApiModelProperty(value = &quot;名字&quot;) @NotBlank(groups = ValidGroup.Crud.Create.class,message = &quot;名字为必填项&quot;) private String name; @ApiModelProperty(value = &quot;邮箱&quot;) @Email(message = &quot;请填写正取的邮箱地址&quot;) private String email; ... &#125; 给参数指定分组，对于未指定分组的则使用的是默认分组。 第三步，给需要参数校验的方法指定分组123456789101112131415161718192021@RestController @Api(&quot;参数校验&quot;) @Slf4j @Validated public class ValidController &#123; @ApiOperation(&quot;新增&quot;) @PostMapping(value = &quot;/valid/add&quot;) public String add(@Validated(value = ValidGroup.Crud.Create.class) ValidVO validVO) &#123; log.info(&quot;validEntity is &#123;&#125;&quot;, validVO); return &quot;test3 valid success&quot;; &#125; @ApiOperation(&quot;更新&quot;) @PostMapping(value = &quot;/valid/update&quot;) public String update(@Validated(value = ValidGroup.Crud.Update.class) ValidVO validVO) &#123; log.info(&quot;validEntity is &#123;&#125;&quot;, validVO); return &quot;test4 valid success&quot;; &#125; &#125; 这里我们通过value属性给add()和update()方法分别指定Create和Update分组。 第四步，体验效果POST http://localhost:8080/valid/add Content-Type: application/x-www-form-urlencoded name=javadaily&amp;level=12&amp;email=476938977@qq.com&amp;sex=F 在Create时我们没有传递id和appId参数，校验通过。 当我们使用同样的参数调用update方法时则提示参数校验错误。 123456&#123; &quot;status&quot;: 400, &quot;message&quot;: &quot;ID不能为空; 应用ID不能为空&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1628492514313 &#125; 由于email属于默认分组，而我们的分组接口ValidGroup已经继承了Default分组，所以也是可以对email字段作参数校验的。如： POST http://localhost:8080/valid/add Content-Type: application/x-www-form-urlencoded name=javadaily&amp;level=12&amp;email=476938977&amp;sex=F 123456&#123; &quot;status&quot;: 400, &quot;message&quot;: &quot;请填写正取的邮箱地址&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1628492637305 &#125; 当然如果你的ValidGroup没有继承Default分组，那在代码属性上就需要加上@Validated(value = &#123;ValidGroup.Crud.Create.class, Default.class&#125;才能让email字段的校验生效。 小结参数校验在实际开发中使用频率非常高，但是很多同学还只是停留在简单的使用上，像分组校验，自定义参数校验这2个高阶技巧基本没怎么用过，经常出现譬如建立多个VO用于接受Create，Update场景的情况，很容易被老鸟被所鄙视嘲笑，希望大家好好掌握。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://andy-whb-cn.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot：统一返回格式","slug":"SpringBoot/SpringBoot：统一返回格式","date":"2024-09-02T06:39:47.310Z","updated":"2024-09-02T07:16:21.033Z","comments":true,"path":"2024/09/02/SpringBoot/SpringBoot：统一返回格式/","permalink":"https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247492641&amp;idx=1&amp;sn=23f42094f442f382581d4bcdd191e12a&amp;chksm=9ad3fe60ada47776313cc10f4b5ed50cfebd9d21bd4bee54698c8e8d3ddf89d1c81e98665743&amp;scene=21#wechat_redirect 基于SpringBoot前后端分离开发模式下，如何友好的返回统一的标准格式以及如何优雅的处理全局异常。首先我们来看看为什么要返回统一的标准格式？ 为什么要对SpringBoot返回统一的标准格式在默认情况下，SpringBoot的返回格式常见的有三种： 第一种：返回 String 1234@GetMapping(&quot;/hello&quot;) public String getStr()&#123; return &quot;hello,javadaily&quot;; &#125; 此时调用接口获取到的返回值是这样： 1hello,javadaily 第二种：返回自定义对象 12345@GetMapping(&quot;/aniaml&quot;) public Aniaml getAniaml()&#123; Aniaml aniaml = new Aniaml(1,&quot;pig&quot;); return aniaml; &#125; 此时调用接口获取到的返回值是这样： 1&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;pig&quot; &#125; 第三种：接口异常 12345@GetMapping(&quot;/error&quot;) public int error()&#123; int i = 9/0; return i; &#125; 此时调用接口获取到的返回值是这样： 123456&#123; &quot;timestamp&quot;: &quot;2021-07-08T08:05:15.423+00:00&quot;, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;path&quot;: &quot;/wrong&quot; &#125; 基于以上种种情况，如果你和前端开发人员联调接口她们就会很懵逼，由于我们没有给他一个统一的格式，前端人员不知道如何处理返回值。 还有甚者，有的同学比如小张喜欢对结果进行封装，他使用了Result对象，小王也喜欢对结果进行包装，但是他却使用的是Response对象，当出现这种情况时我相信前端人员一定会抓狂的。 所以我们项目中是需要定义一个统一的标准返回格式的。 定义返回标准格式一个标准的返回格式至少包含3部分： status 状态值：由后端统一定义各种返回结果的状态码 message 描述：本次接口调用的结果描述 data 数据：本次返回的数据。12345&#123; &quot;status&quot;:&quot;100&quot;, &quot;message&quot;:&quot;操作成功&quot;, &quot;data&quot;:&quot;hello,javadaily&quot; &#125; 当然也可以按需加入其他扩展值，比如接口调用时间 timestamp: 接口调用时间 定义返回对象123456789101112131415161718192021222324252627@Data public class ResultData&lt;T&gt; &#123; /** 结果状态 ,具体状态码参见ResultData.java*/ private int status; private String message; private T data; private long timestamp ; public ResultData ()&#123; this.timestamp = System.currentTimeMillis(); &#125; public static &lt;T&gt; ResultData&lt;T&gt; success(T data) &#123; ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(ReturnCode.RC100.getCode()); resultData.setMessage(ReturnCode.RC100.getMessage()); resultData.setData(data); return resultData; &#125; public static &lt;T&gt; ResultData&lt;T&gt; fail(int code, String message) &#123; ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(code); resultData.setMessage(message); return resultData; &#125;&#125; 定义状态码1234567891011121314151617181920212223242526272829303132public enum ReturnCode &#123; RC100(100,&quot;操作成功&quot;), RC999(999,&quot;操作失败&quot;), RC200(200,&quot;服务开启限流保护,请稍后再试!&quot;), RC201(201,&quot;服务开启降级保护,请稍后再试!&quot;), RC202(202,&quot;热点参数限流,请稍后再试!&quot;), RC203(203,&quot;系统规则不满足要求,请稍后再试!&quot;), RC204(204,&quot;授权规则不通过,请稍后再试!&quot;), RC403(403,&quot;无访问权限,请联系管理员授予权限&quot;), RC401(401,&quot;匿名用户访问无权限资源时的异常&quot;), RC500(500,&quot;系统异常，请稍后重试&quot;), INVALID_TOKEN(2001,&quot;访问令牌不合法&quot;), ACCESS_DENIED(2003,&quot;没有权限访问该资源&quot;), CLIENT_AUTHENTICATION_FAILED(1001,&quot;客户端认证失败&quot;), USERNAME_OR_PASSWORD_ERROR(1002,&quot;用户名或密码错误&quot;), UNSUPPORTED_GRANT_TYPE(1003, &quot;不支持的认证模式&quot;); private final int code; private final String message; ReturnCode(int code, String message)&#123; this.code = code; this.message = message; &#125; public int getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125; &#125; 统一返回格式1234@GetMapping(&quot;/hello&quot;) public ResultData&lt;String&gt; getStr()&#123; return ResultData.success(&quot;hello,javadaily&quot;);&#125; 此时调用接口获取到的返回值是这样： 1234567&#123; &quot;status&quot;: 100, &quot;message&quot;: &quot;hello,javadaily&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625736481648, &quot;httpStatus&quot;: 0 &#125; 这样确实已经实现了我们想要的结果，我在很多项目中看到的都是这种写法，在Controller层通过ResultData.success()对返回结果进行包装后返回给前端。 看到这里我们不妨停下来想想，这样做有什么弊端呢？ 最大的弊端就是我们后面每写一个接口都需要调用ResultData.success()这行代码对结果进行包装，重复劳动，浪费体力； 而且还很容易被其他老鸟给嘲笑。 所以呢我们需要对代码进行优化，目标就是不要每个接口都手工制定ResultData返回值。 高级实现方式要优化这段代码很简单，我们只需要借助SpringBoot提供的ResponseBodyAdvice即可。 ResponseBodyAdvice的作用：拦截Controller方法的返回值，统一处理返回值&#x2F;响应体，一般用来统一返回格式，加解密，签名等等。 先来看下ResponseBodyAdvice的源码： 123456public interface ResponseBodyAdvice&lt;T&gt; &#123; /** * 是否支持advice功能 * true 支持，false 不支持 */ boolean supports(MethodParameter var1, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; var2); /** * 对返回的数据进行处理 */ @Nullable T beforeBodyWrite(@Nullable T var1, MethodParameter var2, MediaType var3, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; var4, ServerHttpRequest var5, ServerHttpResponse var6); &#125; ` 我们只需要编写一个具体实现类即可 1234567891011121314@RestControllerAdvice public class ResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123; @Autowired private ObjectMapper objectMapper; @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) &#123; return true; &#125; @SneakyThrows @Override public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) &#123; if(o instanceof String)&#123; return objectMapper.writeValueAsString(ResultData.success(o)); &#125; return ResultData.success(o); &#125; &#125; 需要注意两个地方： @RestControllerAdvice是@RestController注解的增强，可以实现三个方面的功能： 全局异常处理 全局数据绑定 全局数据预处理 String类型判断123if(o instanceof String)&#123; return objectMapper.writeValueAsString(ResultData.success(o)); &#125; 这段代码一定要加，如果Controller直接返回String的话，SpringBoot是直接返回，故我们需要手动转换成json。经过上面的处理我们就再也不需要通过ResultData.success()来进行转换了，直接返回原始数据格式，SpringBoot自动帮我们实现包装类的封装。 1234@GetMapping(&quot;/hello&quot;) public String getStr()&#123; return &quot;hello,javadaily&quot;; &#125; 此时我们调用接口返回的数据结果为： 12345678910111213141516171819&#123; &quot;status&quot;: 100, &quot;message&quot;: &quot;hello,javadaily&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625736481648, &quot;httpStatus&quot;: 0 &#125; ```是不是感觉很完美，别急，还有个问题在等着你呢。### 接口异常问题此时有个问题，由于我们没对Controller的异常进行处理，当我们调用的方法一旦出现异常，就会出现问题，比如下面这个接口```java@GetMapping(&quot;/wrong&quot;) public int error()&#123; int i = 9/0; return i; &#125; 返回的结果为： 这显然不是我们想要的结果，接口都报错了还返回操作成功的响应码，前端看了会打人的。别急，接下来我们进入第二个议题，如何优雅的处理全局异常。 SpringBoot为什么需要全局异常处理器 不用手写try…catch，由全局异常处理器统一捕获 使用全局异常处理器最大的便利就是程序员在写代码时不再需要手写try...catch了，前面我们讲过，默认情况下SpringBoot出现异常时返回的结果是这样： 123456&#123; &quot;timestamp&quot;: &quot;2021-07-08T08:05:15.423+00:00&quot;, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;path&quot;: &quot;/wrong&quot; &#125; 这种数据格式返回给前端，前端是看不懂的，所以这时候我们一般通过try...catch来处理异常 1234567891011@GetMapping(&quot;/wrong&quot;) public int error()&#123; int i; try&#123; i = 9/0; &#125;catch (Exception e)&#123; log.error(&quot;error:&#123;&#125;&quot;, e); i = 0; &#125; return i; &#125; 我们追求的目标肯定是不需要再手动写try...catch了，而是希望由全局异常处理器处理。 对于自定义异常，只能通过全局异常处理器来处理 1234@GetMapping(&quot;error1&quot;) public void empty()&#123; throw new RuntimeException(&quot;自定义异常&quot;); &#125; 当我们引入Validator参数校验器的时候，参数校验不通过会抛出异常，此时是无法用try...catch捕获的，只能使用全局异常处理器。 如何实现全局异常处理器1234567891011@Slf4j @RestControllerAdvice public class RestExceptionHandler &#123; @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResultData&lt;String&gt; exception(Exception e) &#123; log.error(&quot;全局异常信息 ex=&#123;&#125;&quot;, e.getMessage(), e); return ResultData.fail(ReturnCode.RC500.getCode(), e.getMessage()); &#125; &#125; 有三个细节需要说明一下： @RestControllerAdvice，RestController的增强类，可用于实现全局异常处理器 @ExceptionHandler,统一处理某一类异常，从而减少代码重复率和复杂度，比如要获取自定义异常可以@ExceptionHandler(BusinessException.class) @ResponseStatus指定客户端收到的http状态码 体验效果这时候我们调用如下接口： 1234@GetMapping(&quot;error1&quot;) public void empty()&#123; throw new RuntimeException(&quot;自定义异常&quot;); &#125; 返回的结果如下： 123456&#123; &quot;status&quot;: 500, &quot;message&quot;: &quot;自定义异常&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625795902556 &#125; 基本满足我们的需求了。 但是当我们同时启用统一标准格式封装功能ResponseAdvice和RestExceptionHandler全局异常处理器时又出现了新的问题： 1234567891011&#123; &quot;status&quot;: 100, &quot;message&quot;: &quot;操作成功&quot;, &quot;data&quot;: &#123; &quot;status&quot;: 500, &quot;message&quot;: &quot;自定义异常&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625796167986 &#125;, &quot;timestamp&quot;: 1625796168008 &#125; 此时返回的结果是这样，统一格式增强功能会给返回的异常结果再次封装，所以接下来我们需要解决这个问题。 全局异常接入返回的标准格式要让全局异常接入标准格式很简单，因为全局异常处理器已经帮我们封装好了标准格式，我们只需要直接返回给客户端即可。 123456789101112@SneakyThrows @Override public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) &#123; if(o instanceof String)&#123; return objectMapper.writeValueAsString(ResultData.success(o)); &#125; if(o instanceof ResultData)&#123; return o; &#125; return ResultData.success(o); &#125; 关键代码： 123if(o instanceof ResultData)&#123; return o; &#125; 如果返回的结果是ResultData对象，直接返回即可。 这时候我们再调用上面的错误方法，返回的结果就符合我们的要求了。 123456&#123; &quot;status&quot;: 500, &quot;message&quot;: &quot;自定义异常&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625796580778 &#125; 希望通过这篇文章你能掌握如何在你项目中友好实现统一标准格式到返回并且可以优雅的处理全局异常。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"微服务","slug":"微服务","permalink":"https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Java","slug":"Java","permalink":"https://andy-whb-cn.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://andy-whb-cn.github.io/tags/SpringBoot/"}]},{"title":"面向接口：幂等性","slug":"接口设计/面向接口：幂等性","date":"2024-09-02T02:59:25.925Z","updated":"2024-09-02T10:49:12.127Z","comments":true,"path":"2024/09/02/接口设计/面向接口：幂等性/","permalink":"https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%B9%82%E7%AD%89%E6%80%A7/","excerpt":"","text":"原文（https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg） 一、什么是幂等性幂等是一个数学与计算机学概念，在数学中某一元运算为幂等时，其作用在任一元素两次后会和其作用一次的结果相同。 在计算机中编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数或幂等方法是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。 二、什么是接口幂等性在HTTP&#x2F;1.1中，对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。 这里的副作用是不会对结果产生破坏或者产生不可预料的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。 三、为什么需要实现幂等性在接口调用时一般情况下都能正常返回信息不会重复提交，不过在遇见以下情况时可以就会出现问题，如： 前端重复提交表单： 在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。 用户恶意进行刷单： 例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。 接口超时重复提交： 很多时候 HTTP 客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。 消息进行重复消费： 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。使用幂等性最大的优势在于使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。 四、引入幂等性后对系统的影响幂等性是为了简化客户端逻辑处理，能放置重复提交等操作，但却增加了服务端的逻辑复杂性和成本，其主要是： 把并行执行的功能改为串行执行，降低了执行效率。 增加了额外控制幂等的业务逻辑，复杂化了业务功能；所以在使用时候需要考虑是否引入幂等性的必要性，根据实际业务场景具体分析，除了业务上的特殊要求外，一般情况下不需要引入的接口幂等性。 五、Restful API 接口的幂等性现在流行的 Restful 推荐的几种 HTTP 接口方法中，分别存在幂等行与不能保证幂等的方法，如下： √ 满足幂等 x 不满足幂等 可能满足也可能不满足幂等，根据实际业务逻辑有关 方法类型 是否幂等 描述 Get √ Get 方法用于获取资源。其一般不会也不应当对系统资源进行改变，所以是幂等的。 Post × Post 方法一般用于创建新的资源。其每次执行都会新增数据，所以不是幂等的。 Put - Put 方法一般用于修改资源。该操作则分情况来判断是不是满足幂等，更新操作中直接根据某个值进行更新，也能保持幂等。不过执行累加操作的更新是非幂等。 Delete - Delete 方法一般用于删除资源。该操作则分情况来判断是不是满足幂等，当根据唯一值进行删除时，删除同一个数据多次执行效果一样。不过需要注意，带查询条件的删除则就不一定满足幂等了。例如在根据条件删除一批数据后，这时候新增加了一条数据也满足条件，然后又执行了一次删除，那么将会导致新增加的这条满足条件数据也被删除。 六、如何实现幂等性方案一：数据库唯一主键方案描述数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键（可以参考 Java 中分布式 ID 的设计方案 这篇文章），这样才能能保证在分布式环境下 ID 的全局唯一性。 适用操作： 插入操作 删除操作 使用限制： 需要生成全局唯一主键 ID； 主要流程： 主要流程： ① 客户端执行创建请求，调用服务端接口。 ② 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执数据插入操作，运行对应的 SQL 语句。 ③ 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。 方案二：数据库乐观锁方案描述：数据库乐观锁方案一般只能适用于执行“更新操作”的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。 适用操作： 更新操作 使用限制： 需要数据库对应业务表中添加额外字段； 描述示例： 例如，存在如下的数据表中： id name price 1 小米手机 1000 2 苹果手机 2500 3 华为手机 1600 为了每次执行更新时防止重复更新，确定更新的一定是要更新的内容，我们通常都会添加一个 version 字段记录当前的记录版本，这样在更新时候将该值带上，那么只要执行更新操作就能确定一定更新的是某个对应版本下的信息。 id name price version 1 小米手机 1000 10 2 苹果手机 2500 21 3 华为手机 1600 5 这样每次执行更新时候，都要指定要更新的版本号，如下操作就能准确更新 version&#x3D;5 的信息： 1UPDATE my_table SET price=price+50,version=version+1 WHERE id=1 AND version=5 上面 WHERE 后面跟着条件 id&#x3D;1 AND version&#x3D;5 被执行后，id&#x3D;1 的 version 被更新为 6，所以如果重复执行该条 SQL 语句将不生效，因为 id&#x3D;1 AND version&#x3D;5 的数据已经不存在，这样就能保住更新的幂等，多次更新对结果不会产生影响。 方案三：防重 Token 令牌方案描述：针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 Token 的机制实现防止重复提交。简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，如果 Key 存在且 Value 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作。 适用操作： 插入操作 更新操作 删除操作 使用限制： 需要生成全局唯一 Token 串； 需要使用第三方组件 Redis 进行数据效验； 主要流程： ① 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。 ② 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。 ③ 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。 ④ 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。 ⑤ 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。 ⑥ 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。 ⑦ 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。 注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。 方案四、下游传递唯一序列号方案描述：所谓请求序列号，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个有序 ID，也可以是一个订单号，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 ID。当上游服务器收到请求信息后拿取该 序列号 和下游 认证ID 进行组合，形成用于操作 Redis 的 Key，然后到 Redis 中查询是否存在对应的 Key 的键值对，根据其结果： 如果存在，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。 如果不存在，就以该 Key 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。 适用操作： 插入操作 更新操作 删除操作 使用限制： 要求第三方传递唯一序列号； 需要使用第三方组件 Redis 进行数据效验； 主要流程： 主要步骤： ① 下游服务生成分布式 ID 作为序列号，然后执行请求调用上游接口，并附带“唯一序列号”与请求的“认证凭据ID”。 ② 上游服务进行安全效验，检测下游传递的参数中是否存在“序列号”和“凭据ID”。 ③ 上游服务到 Redis 中检测是否存在对应的“序列号”与“认证ID”组成的 Key，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息。如果不存在就以该“序列号”和“认证ID”组合作为 Key，以下游关键信息作为 Value，进而存储到 Redis 中，然后正常执行接来来的业务逻辑。 上面步骤中插入数据到 Redis 一定要设置过期时间。这样能保证在这个时间范围内，如果重复调用接口，则能够进行判断识别。如果不设置过期时间，很可能导致数据无限量的存入 Redis，致使 Redis 不能正常工作。 七、实现接口幂等示例这里使用防重 Token 令牌方案，该方案能保证在不同请求动作下的幂等性，实现逻辑可以看上面写的”防重 Token 令牌”方案，接下来写下实现这个逻辑的代码。 1、Maven 引入相关依赖这里使用 Maven 工具管理依赖，这里在 pom.xml 中引入 SpringBoot、Redis、lombok 相关依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;mydlq.club&lt;/groupId&gt; &lt;artifactId&gt;springboot-idempotent-token&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;springboot-idempotent-token&lt;/name&gt; &lt;description&gt;Idempotent Demo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--springboot data redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、配置连接 Redis 的参数在 application 配置文件中配置连接 Redis 的参数如下： 1234567891011121314spring: redis: ssl: false host: 127.0.0.1 port: 6379 database: 0 timeout: 1000 password: lettuce: pool: max-active: 100 max-wait: -1 min-idle: 0 max-idle: 20 3、创建与验证 Token 工具类创建用于操作 Token 相关的 Service 类，里面存在 Token 创建与验证方法，其中： Token 创建方法： 使用 UUID 工具创建 Token 串，设置以 “idempotent_token:“+“Token串” 作为 Key，以用户信息当成 Value，将信息存入 Redis 中。 Token 验证方法： 接收 Token 串参数，加上 Key 前缀形成 Key，再传入 value 值，执行 Lua 表达式（Lua 表达式能保证命令执行的原子性）进行查找对应 Key 与删除操作。执行完成后验证命令的返回结果，如果结果不为空且非0，则验证成功，否则失败。 1import java.util.Arrays;import java.util.UUID;import java.util.concurrent.TimeUnit;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.data.redis.core.script.RedisScript;import org.springframework.stereotype.Service;@Slf4j@Servicepublic class TokenUtilService &#123; @Autowired private StringRedisTemplate redisTemplate; /** * 存入 Redis 的 Token 键的前缀 */ private static final String IDEMPOTENT_TOKEN_PREFIX = &quot;idempotent_token:&quot;; /** * 创建 Token 存入 Redis，并返回该 Token * * @param value 用于辅助验证的 value 值 * @return 生成的 Token 串 */ public String generateToken(String value) &#123; // 实例化生成 ID 工具对象 String token = UUID.randomUUID().toString(); // 设置存入 Redis 的 Key String key = IDEMPOTENT_TOKEN_PREFIX + token; // 存储 Token 到 Redis，且设置过期时间为5分钟 redisTemplate.opsForValue().set(key, value, 5, TimeUnit.MINUTES); // 返回 Token return token; &#125; /** * 验证 Token 正确性 * * @param token token 字符串 * @param value value 存储在Redis中的辅助验证信息 * @return 验证结果 */ public boolean validToken(String token, String value) &#123; // 设置 Lua 脚本，其中 KEYS[1] 是 key，KEYS[2] 是 value String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == KEYS[2] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;; RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(script, Long.class); // 根据 Key 前缀拼接 Key String key = IDEMPOTENT_TOKEN_PREFIX + token; // 执行 Lua 脚本 Long result = redisTemplate.execute(redisScript, Arrays.asList(key, value)); // 根据返回结果判断是否成功成功匹配并删除 Redis 键值对，若果结果不为空和0，则验证通过 if (result != null &amp;&amp; result != 0L) &#123; log.info(&quot;验证 token=&#123;&#125;,key=&#123;&#125;,value=&#123;&#125; 成功&quot;, token, key, value); return true; &#125; log.info(&quot;验证 token=&#123;&#125;,key=&#123;&#125;,value=&#123;&#125; 失败&quot;, token, key, value); return false; &#125;&#125; 4、创建测试的 Controller 类创建用于测试的 Controller 类，里面有获取 Token 与测试接口幂等性的接口，内容如下： 1import lombok.extern.slf4j.Slf4j;import mydlq.club.example.service.TokenUtilService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;@Slf4j@RestControllerpublic class TokenController &#123; @Autowired private TokenUtilService tokenService; /** * 获取 Token 接口 * * @return Token 串 */ @GetMapping(&quot;/token&quot;) public String getToken() &#123; // 获取用户信息（这里使用模拟数据） // 注：这里存储该内容只是举例，其作用为辅助验证，使其验证逻辑更安全，如这里存储用户信息，其目的为: // - 1)、使用&quot;token&quot;验证 Redis 中是否存在对应的 Key // - 2)、使用&quot;用户信息&quot;验证 Redis 的 Value 是否匹配。 String userInfo = &quot;mydlq&quot;; // 获取 Token 字符串，并返回 return tokenService.generateToken(userInfo); &#125; /** * 接口幂等性测试接口 * * @param token 幂等 Token 串 * @return 执行结果 */ @PostMapping(&quot;/test&quot;) public String test(@RequestHeader(value = &quot;token&quot;) String token) &#123; // 获取用户信息（这里使用模拟数据） String userInfo = &quot;mydlq&quot;; // 根据 Token 和与用户相关的信息到 Redis 验证是否存在对应的信息 boolean result = tokenService.validToken(token, userInfo); // 根据验证结果响应不同信息 return result ? &quot;正常调用&quot; : &quot;重复调用&quot;; &#125;&#125; 5、创建 SpringBoot 启动类创建启动类，用于启动 SpringBoot 应用。 123456789import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 6、写测试类进行测试写个测试类进行测试，多次访问同一个接口，测试是否只有第一次能否执行成功。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@Slf4j@SpringBootTest@RunWith(SpringRunner.class)public class IdempotenceTest &#123; @Autowired private WebApplicationContext webApplicationContext; @Test public void interfaceIdempotenceTest() throws Exception &#123; // 初始化 MockMvc MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); // 调用获取 Token 接口 String token = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/token&quot;) .accept(MediaType.TEXT_HTML)) .andReturn() .getResponse() .getContentAsString(); log.info(&quot;获取的 Token 串：&#123;&#125;&quot;, token); // 循环调用 5 次进行测试 for (int i = 1; i &lt;= 5; i++) &#123; log.info(&quot;第&#123;&#125;次调用测试接口&quot;, i); // 调用验证接口并打印结果 String result = mockMvc.perform(MockMvcRequestBuilders.post(&quot;/test&quot;) .header(&quot;token&quot;, token) .accept(MediaType.TEXT_HTML)) .andReturn() .getResponse() .getContentAsString(); log.info(result); // 结果断言 if (i == 0) &#123; Assert.assertEquals(result, &quot;正常调用&quot;); &#125; else &#123; Assert.assertEquals(result, &quot;重复调用&quot;); &#125; &#125; &#125;&#125; 显示如下： 1[main] IdempotenceTest: 获取的 Token 串：980ea707-ce2e-456e-a059-0a03332110b4[main] IdempotenceTest: 第1次调用测试接口[main] IdempotenceTest: 正常调用[main] IdempotenceTest: 第2次调用测试接口[main] IdempotenceTest: 重复调用[main] IdempotenceTest: 第3次调用测试接口[main] IdempotenceTest: 重复调用[main] IdempotenceTest: 第4次调用测试接口[main] IdempotenceTest: 重复调用[main] IdempotenceTest: 第5次调用测试接口[main] IdempotenceTest: 重复调用 八、最后总结幂等性是开发当中很常见也很重要的一个需求，尤其是支付、订单等与金钱挂钩的服务，保证接口幂等性尤其重要。在实际开发中，我们需要针对不同的业务场景我们需要灵活的选择幂等性的实现方式： 对于下单等存在唯一主键的，可以使用“唯一主键方案”的方式实现。 对于更新订单状态等相关的更新场景操作，使用“乐观锁方案”实现更为简单。 对于上下游这种，下游请求上游，上游服务可以使用“下游传递唯一序列号方案”更为合理。 类似于前端重复提交、重复下单、没有唯一ID号的场景，可以通过 Token 与 Redis 配合的“防重 Token 方案”实现更为快捷。 上面只是给与一些建议，再次强调一下，实现幂等性需要先理解自身业务需求，根据业务逻辑来实现这样才合理，处理好其中的每一个结点细节，完善整体的业务流程设计，才能更好的保证系统的正常运行。最后做一个简单总结 方案名称 适用方法 实现复杂度 方案缺点 数据库唯一主键 插入操作 删除操作 简单 - 只能用于插入操作；- 只能用于存在唯一主键场景； 数据库乐观锁 更新操作 简单 - 只能用于更新操作；- 表中需要额外添加字段； 请求序列号 插入操作 更新操作 删除操作 简单 - 需要保证下游生成唯一序列号；- 需要 Redis 第三方存储已经请求的序列号； 防重 Token 令牌 插入操作 更新操作 删除操作 适中 - 需要 Redis 第三方存储生成的 Token 串；","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"微服务","slug":"微服务","permalink":"https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Java","slug":"Java","permalink":"https://andy-whb-cn.github.io/tags/Java/"}]},{"title":"Java：应用启动脚本","slug":"JVM/Java：应用启动脚本","date":"2024-08-27T08:10:51.500Z","updated":"2024-09-03T00:46:02.387Z","comments":true,"path":"2024/08/27/JVM/Java：应用启动脚本/","permalink":"https://andy-whb-cn.github.io/2024/08/27/JVM/Java%EF%BC%9A%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/","excerpt":"","text":"常见的Java应用启停脚本reboot_jar_shell.sh 123456789101112131415161718#!/bin/shbootClassPath=$*appName=$1echo &quot;==========================&quot;echo &quot;stop $&#123;appName&#125;&quot;PID=`ps axu | grep java | grep &quot;$&#123;appName&#125;&quot; |grep -v grep| awk &#x27;&#123;printf $2&#125;&#x27;`if [ -n &quot;$&#123;PID&#125;&quot; ]; then echo &quot;kill process $&#123;PID&#125;&quot; kill -9 $&#123;PID&#125;fiecho &quot;$&#123;appName&#125; stopped&quot;echo &quot;start $&#123;appName&#125;&quot;echo &quot;boot classpath: $&#123;bootClassPath&#125;&quot;nohup java server $bootClassPath &gt;nohup.log 2&gt;&amp;1 &amp;echo &quot;$appName started&quot;echo &quot;==========================&quot; restart.sh 123456#!/bin/shecho &quot;--------xxx 开始启动--------------&quot; sh reboot_jar_shell.sh -DappName=xxx -Xms1024m -Xmx1024m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/xxxx/logs -Djava.io.tmpdir=/data/tmp/xxxx -Xbootclasspath/a:/data/xxxx/config -Dspring.profiles.active=&lt;env&gt; -Dfile.encoding=utf-8 -jar xxx.jar sleep 10echo &quot;--------xxx 启动成功--------------&quot; JVM heap参数设置建议：1、JVM默认会根据运行机器的配置情况自动设置heap大小；2、尽可能通过选择GC算法调优，而不是调整heap大小，除非应用需要的heap大小超过了默认值；3、通常情况下，heap大小设置可以参考Full GC后老年代存活对象大小的3-4倍；4、如果明确知道应用需要用到的heap大小，可以将Xms和Xmx设置为相同值，避免heap resize，会让GC更高效。相关建议来源参考书籍《Java Performance, 2nd Edition》 by Scott Oaks Jvm优化这块主要不是谈如何优化，jvm优化是一个需要场景化的，没有什么太多特定参数，一般来说在server端运行都会指定如下参数 初始内存和最大内存基本会设置成一样的，具体大小根据场景设置，-server是一个必须要用的参数，至于收集器这些使用默认的就可以了，除非有特定需求。 1.使用-server模式设置JVM使用server模式。64位JDK默认启动该模式 java -server -jar springboot-1.0.jar 2.指定堆参数这个根据服务器的内存大小，来设置堆参数。 -Xms :设置Java堆栈的初始化大小 -Xmx :设置最大的java堆大小 java -server -Xms512m -Xmx768m -jar springboot-1.0.jar 设置初始化堆内存为512MB，最大为768MB。 3.远程Debug在服务器上将启动参数修改为： 1java -Djavax.net.debug=ssl -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8888 -jar springboot-1.0.jar 这个时候服务端远程Debug模式开启，端口号为8888。 在IDEA中，点击Edit Configuration按钮。 出现弹窗，点击+按钮，找到Remote选项。 在【1】中填入Remote项目名称，在【2】中填IP地址和端口号，在【3】选择远程调试的项目module，配置完成后点击OK即可 如果碰到连接超时的情况，很有可能服务器的防火墙的问题，举例CentOs7,关闭防火墙 1systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 点击debug按钮，IDEA控制台打印信息： 说明远程调试成功。 JVM工具远程连接jconsole与Jvisualvm远程连接通常我们的web服务都输部署在服务器上的，在window使用jconsole是很方便的，相对于Linux就有一些麻烦了，需要进行一些设置。 1.查看hostname,首先使用hostname -i 查看，服务器的hostname为127.0.0.1，这个是不对的，需要进行修改 2.修改hostname修改&#x2F;etc&#x2F;hosts文件，将其第一行的“127.0.0.1 localhost.localdomain localhost”，修改为：“192.168.44.128 localhost.localdomain localhost”.“192.168.44.128”为实际的服务器的IP 3.重启Linux，在服务器上输入hostname -i，查看实际设置的IP地址是否为你设置的 4.启动服务，参数为：java -jar -Djava.rmi.server.hostname=192.168.44.128 - Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=911 - Dcom.sun.management.jmxremote.ssl=false - Dcom.sun.management.jmxremote.authenticate=false jantent-1.0-SNAPSHOT.jar ip为192.168.44.128，端口为911 。 5.打开Jconsole，进行远程连接,输入IP和端口即可点击连接，经过稍稍等待之后，即可完成连接，如下图所示： 同理，JvisualVm的远程连接是同样的，启动参数也是一样。 然后在本机JvisualVm输入IP：PORT，即可进行远程连接：如下图所示： 相比较Jvisualvm功能更加强大一下，界面也更美观。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://andy-whb-cn.github.io/tags/Java/"},{"name":"脚本","slug":"脚本","permalink":"https://andy-whb-cn.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"前端版本更新检测","slug":"前端/前端：版本更新检测","date":"2024-08-22T08:33:34.000Z","updated":"2024-09-03T00:47:17.267Z","comments":true,"path":"2024/08/22/前端/前端：版本更新检测/","permalink":"https://andy-whb-cn.github.io/2024/08/22/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%EF%BC%9A%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B/","excerpt":"","text":"前端版本更新检测方案采用Etag比较https://blog.csdn.net/qq_38951259/article/details/136739490 采用前后端Version比较1、后台提供轻量级version api；2、前端页面初始化或定时，比较本地version和服务端version是否有变更，设置local vesion变更变量；3、前端在进入router前，判断有local vesion变更变量，刷新本地缓存并删除local vesion变更变量； 引申：为避免频繁去请求后台的version，可以考虑按时间戳（每日）去检查远端version更新。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://andy-whb-cn.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://andy-whb-cn.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Flink 处理复杂的Json格式","slug":"大数据/大数据：Flink-Nested-Json","date":"2024-08-22T08:33:34.000Z","updated":"2024-09-03T00:49:05.032Z","comments":true,"path":"2024/08/22/大数据/大数据：Flink-Nested-Json/","permalink":"https://andy-whb-cn.github.io/2024/08/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%9AFlink-Nested-Json/","excerpt":"","text":"Flink 复杂Json格式处理Flink 官方文档：https://nightlies.apache.org/flink/flink-docs-release-1.20/zh/docs/connectors/table/formats/json/ Flink 对于单层Json的处理，可以支持直接转换，但对于复杂的嵌套Json则需要在类型定义上做一些处理。 以下是结合ROW、ARRAY、MAP的简单示例介绍（原文： https://blog.csdn.net/m0_67400972/article/details/123923656 ） 123456789101112131415161718192021222324252627282930&#123; &quot;id&quot;:1238123899121, &quot;name&quot;:&quot;asdlkjasjkdla998y1122&quot;, &quot;date&quot;:&quot;1990-10-14&quot;, &quot;obj&quot;:&#123; &quot;time1&quot;:&quot;12:12:43Z&quot;, &quot;str&quot;:&quot;sfasfafs&quot;, &quot;lg&quot;:2324342345 &#125;, &quot;arr&quot;:[ &#123; &quot;f1&quot;:&quot;f1str11&quot;, &quot;f2&quot;:134 &#125;, &#123; &quot;f1&quot;:&quot;f1str22&quot;, &quot;f2&quot;:555 &#125; ], &quot;time&quot;:&quot;12:12:43Z&quot;, &quot;timestamp&quot;:&quot;1990-10-14T12:12:43Z&quot;, &quot;map&quot;:&#123; &quot;flink&quot;:123 &#125;, &quot;mapinmap&quot;:&#123; &quot;inner_map&quot;:&#123; &quot;key&quot;:234 &#125; &#125;&#125; 123456789101112131415161718192021CREATE TABLE json_source ( id BIGINT, name STRING, `date` DATE, obj ROW&lt;time1 TIME,str STRING,lg BIGINT&gt;, arr ARRAY&lt;ROW&lt;f1 STRING,f2 INT&gt;&gt;, `time` TIME, `timestamp` TIMESTAMP(3), `map` MAP&lt;STRING,BIGINT&gt;, mapinmap MAP&lt;STRING,MAP&lt;STRING,INT&gt;&gt;, proctime as PROCTIME() ) WITH ( &#x27;connector.type&#x27; = &#x27;kafka&#x27;, &#x27;connector.topic&#x27; = &#x27;test&#x27;, &#x27;connector.properties.zookeeper.connect&#x27; = &#x27;localhost:2181&#x27;, &#x27;connector.properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;, &#x27;connector.properties.group.id&#x27; = &#x27;testGroup&#x27;, &#x27;connector.version&#x27;=&#x27;universal&#x27;, &#x27;format.type&#x27; = &#x27;json&#x27;, &#x27;connector.startup-mode&#x27;=&#x27;latest-offset&#x27; ); 12345-- 构造insert into json_source select 111 as id,&#x27;name&#x27; as name,Row(CURRENT_TIME,&#x27;ss&#x27;,123) as obj,Array[Row(&#x27;f&#x27;,1),Row(&#x27;s&#x27;,2)] as arr,Map[&#x27;k1&#x27;,&#x27;v1&#x27;,&#x27;k2&#x27;,&#x27;v2&#x27;] as `map`,Map[&#x27;inner_map&#x27;,Map[&#x27;k&#x27;,&#x27;v&#x27;]] as mapinmap;-- 获取，注意数组index从1开始select id, name,`date`,obj.str,arr[1].f1,`map`[&#x27;flink&#x27;],mapinmap[&#x27;inner_map&#x27;][&#x27;key&#x27;] from json_source;","categories":[],"tags":[{"name":"Flink","slug":"Flink","permalink":"https://andy-whb-cn.github.io/tags/Flink/"}]},{"title":"面向接口：防篡改&防重放","slug":"接口设计/面向接口：防篡改&防重放","date":"2024-08-22T08:33:34.000Z","updated":"2024-09-03T00:44:41.798Z","comments":true,"path":"2024/08/22/接口设计/面向接口：防篡改&防重放/","permalink":"https://andy-whb-cn.github.io/2024/08/22/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%98%B2%E7%AF%A1%E6%94%B9&%E9%98%B2%E9%87%8D%E6%94%BE/","excerpt":"","text":"对于互联网来说，只要你系统的接口暴露在外网，就避免不了接口安全问题。如果你的接口在外网裸奔，只要让黑客知道接口的地址和参数就可以调用，那简直就是灾难。 举个例子：你的网站用户注册的时候，需要填写手机号，发送手机验证码，如果这个发送验证码的接口没有经过特殊安全处理，那这个短信接口早就被人盗刷不知道浪费多少钱了。 那如何保证接口安全呢？ 一般来说，暴露在外网的api接口需要做到防篡改和防重放才能称之为安全的接口。 防篡改我们知道http 是一种无状态的协议，服务端并不知道客户端发送的请求是否合法，也并不知道请求中的参数是否正确。 举个例子, 现在有个充值的接口，调用后可以给用户增加对应的余额。 1http://localhost/api/user/recharge?user_id=1001&amp;amount=10 如果非法用户通过抓包获取到接口参数后，修改user_id 或 amount的值就可以实现给任意账户添加余额的目的。 如何解决采用https协议可以将传输的明文进行加密，但是黑客仍然可以截获传输的数据包，进一步伪造请求进行重放攻击。如果黑客使用特殊手段让请求方设备使用了伪造的证书进行通信，那么https加密的内容也会被解密。 一般的做法有2种： 采用https方式把接口的数据进行加密传输，即便是被黑客破解，黑客也花费大量的时间和精力去破解。 接口后台对接口的请求参数进行验证，防止被黑客篡改； 步骤1：客户端使用约定好的秘钥对传输的参数进行加密，得到签名值sign1，并且将签名值也放入请求的参数中，发送请求给服务端 步骤2：服务端接收到客户端的请求，然后使用约定好的秘钥对请求的参数再次进行签名，得到签名值sign2。 步骤3：服务端比对sign1和sign2的值，如果不一致，就认定为被篡改，非法请求。 防重放防重放也叫防复用。简单来说就是我获取到这个请求的信息之后什么也不改,，直接拿着接口的参数 重复请求这个充值的接口。此时我的请求是合法的, 因为所有参数都是跟合法请求一模一样的。 重放攻击会造成两种后果： 针对插入数据库接口：重放攻击，会出现大量重复数据，甚至垃圾数据会把数据库撑爆。 针对查询的接口：黑客一般是重点攻击慢查询接口，例如一个慢查询接口1s，只要黑客发起重放攻击，就必然造成系统被拖垮，数据库查询被阻塞死。 对于重放攻击一般有两种做法： 基于timestamp的方案每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间比较，是否超过了60s，如果超过了则认为是非法请求。 一般情况下，黑客从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了。如果黑客修改timestamp参数为当前的时间戳，则sign1参数对应的数字签名就会失效，因为黑客不知道签名秘钥，没有办法生成新的数字签名。 但是这种方式的漏洞也是显而易见，如果在60s之内进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效。 老鸟们一般会采取下面这种方案，既可以解决接口重放问题，又可以解决接口一次请求有效的问题。 基于nonce + timestamp 的方案nonce的意思是仅一次有效的随机字符串，要求每次请求时该参数要保证不同。实际使用用户信息+时间戳+随机数等信息做个哈希之后，作为nonce参数。 此时服务端的处理流程如下： 去 redis 中查找是否有 key 为 nonce:&#123;nonce&#125; 的 string 如果没有，则创建这个 key，把这个 key 失效的时间和验证 timestamp 失效的时间一致，比如是 60s。 如果有，说明这个 key 在 60s 内已经被使用了，那么这个请求就可以判断为重放请求。 这种方案nonce和timestamp参数都作为签名的一部分传到后端，基于timestamp方案可以让黑客只能在60s内进行重放攻击，加上nonce随机数以后可以保证接口只能被调用一次，可以很好的解决重放攻击问题。 代码实现接下来通过实际代码来看看如何实现接口的防篡改和防重放。 1、构建请求头对象1@Data@Builderpublic class RequestHeader &#123; private String sign ; private Long timestamp ; private String nonce;&#125; 2、工具类从HttpServletRequest获取请求参数1@Slf4j@UtilityClasspublic class HttpDataUtil &#123; /** * post请求处理：获取 Body 参数，转换为SortedMap * * @param request */ public SortedMap&lt;String, String&gt; getBodyParams(final HttpServletRequest request) throws IOException &#123; byte[] requestBody = StreamUtils.copyToByteArray(request.getInputStream()); String body = new String(requestBody); return JsonUtil.json2Object(body, SortedMap.class); &#125; /** * get请求处理：将URL请求参数转换成SortedMap */ public static SortedMap&lt;String, String&gt; getUrlParams(HttpServletRequest request) &#123; String param = &quot;&quot;; SortedMap&lt;String, String&gt; result = new TreeMap&lt;&gt;(); if (StringUtils.isEmpty(request.getQueryString())) &#123; return result; &#125; try &#123; param = URLDecoder.decode(request.getQueryString(), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; String[] params = param.split(&quot;&amp;&quot;); for (String s : params) &#123; String[] array=s.split(&quot;=&quot;); result.put(array[0], array[1]); &#125; return result; &#125;&#125; 这里的参数放入SortedMap中对其进行字典排序，前端构建签名时同样需要对参数进行字典排序。 3、签名验证工具类1@Slf4j@UtilityClasspublic class SignUtil &#123; /** * 验证签名 * 验证算法：把timestamp + JsonUtil.object2Json(SortedMap)合成字符串，然后MD5 */ @SneakyThrows public boolean verifySign(SortedMap&lt;String, String&gt; map, RequestHeader requestHeader) &#123; String params = requestHeader.getNonce() + requestHeader.getTimestamp() + JsonUtil.object2Json(map); return verifySign(params, requestHeader); &#125; /** * 验证签名 */ public boolean verifySign(String params, RequestHeader requestHeader) &#123; log.debug(&quot;客户端签名: &#123;&#125;&quot;, requestHeader.getSign()); if (StringUtils.isEmpty(params)) &#123; return false; &#125; log.info(&quot;客户端上传内容: &#123;&#125;&quot;, params); String paramsSign = DigestUtils.md5DigestAsHex(params.getBytes()).toUpperCase(); log.info(&quot;客户端上传内容加密后的签名结果: &#123;&#125;&quot;, paramsSign); return requestHeader.getSign().equals(paramsSign); &#125;&#125; 4、HttpServletRequest包装类1public class SignRequestWrapper extends HttpServletRequestWrapper &#123; //用于将流保存下来 private byte[] requestBody = null; public SignRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); requestBody = StreamUtils.copyToByteArray(request.getInputStream()); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; final ByteArrayInputStream bais = new ByteArrayInputStream(requestBody); return new ServletInputStream() &#123; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener readListener) &#123; &#125; @Override public int read() throws IOException &#123; return bais.read(); &#125; &#125;; &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125;&#125; 防篡改和防重放我们会通过SpringBoot Filter来实现，而编写的filter过滤器需要读取request数据流，但是request数据流只能读取一次，需要自己实现HttpServletRequestWrapper对数据流包装，目的是将request流保存下来。 5、创建过滤器实现安全校验1@Configurationpublic class SignFilterConfiguration &#123; @Value(&quot;$&#123;sign.maxTime&#125;&quot;) private String signMaxTime; //filter中的初始化参数 private Map&lt;String, String&gt; initParametersMap = new HashMap&lt;&gt;(); @Bean public FilterRegistrationBean contextFilterRegistrationBean() &#123; initParametersMap.put(&quot;signMaxTime&quot;,signMaxTime); FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(signFilter()); registration.setInitParameters(initParametersMap); registration.addUrlPatterns(&quot;/sign/*&quot;); registration.setName(&quot;SignFilter&quot;); // 设置过滤器被调用的顺序 registration.setOrder(1); return registration; &#125; @Bean public Filter signFilter() &#123; return new SignFilter(); &#125;&#125; 1@Slf4jpublic class SignFilter implements Filter &#123; @Resource private RedisUtil redisUtil; //从fitler配置中获取sign过期时间 private Long signMaxTime; private static final String NONCE_KEY = &quot;x-nonce-&quot;; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpRequest = (HttpServletRequest) servletRequest; HttpServletResponse httpResponse = (HttpServletResponse) servletResponse; log.info(&quot;过滤URL:&#123;&#125;&quot;, httpRequest.getRequestURI()); HttpServletRequestWrapper requestWrapper = new SignRequestWrapper(httpRequest); //构建请求头 RequestHeader requestHeader = RequestHeader.builder() .nonce(httpRequest.getHeader(&quot;x-Nonce&quot;)) .timestamp(Long.parseLong(httpRequest.getHeader(&quot;X-Time&quot;))) .sign(httpRequest.getHeader(&quot;X-Sign&quot;)) .build(); //验证请求头是否存在 if(StringUtils.isEmpty(requestHeader.getSign()) || ObjectUtils.isEmpty(requestHeader.getTimestamp()) || StringUtils.isEmpty(requestHeader.getNonce()))&#123; responseFail(httpResponse, ReturnCode.ILLEGAL_HEADER); return; &#125; /* * 1.重放验证 * 判断timestamp时间戳与当前时间是否操过60s（过期时间根据业务情况设置）,如果超过了就提示签名过期。 */ long now = System.currentTimeMillis() / 1000; if (now - requestHeader.getTimestamp() &gt; signMaxTime) &#123; responseFail(httpResponse,ReturnCode.REPLAY_ERROR); return; &#125; //2. 判断nonce boolean nonceExists = redisUtil.hasKey(NONCE_KEY + requestHeader.getNonce()); if(nonceExists)&#123; //请求重复 responseFail(httpResponse,ReturnCode.REPLAY_ERROR); return; &#125;else &#123; redisUtil.set(NONCE_KEY+requestHeader.getNonce(), requestHeader.getNonce(), signMaxTime); &#125; boolean accept; SortedMap&lt;String, String&gt; paramMap; switch (httpRequest.getMethod())&#123; case &quot;GET&quot;: paramMap = HttpDataUtil.getUrlParams(requestWrapper); accept = SignUtil.verifySign(paramMap, requestHeader); break; case &quot;POST&quot;: paramMap = HttpDataUtil.getBodyParams(requestWrapper); accept = SignUtil.verifySign(paramMap, requestHeader); break; default: accept = true; break; &#125; if (accept) &#123; filterChain.doFilter(requestWrapper, servletResponse); &#125; else &#123; responseFail(httpResponse,ReturnCode.ARGUMENT_ERROR); return; &#125; &#125; private void responseFail(HttpServletResponse httpResponse, ReturnCode returnCode) &#123; ResultData&lt;Object&gt; resultData = ResultData.fail(returnCode.getCode(), returnCode.getMessage()); WebUtils.writeJson(httpResponse,resultData); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; String signTime = filterConfig.getInitParameter(&quot;signMaxTime&quot;); signMaxTime = Long.parseLong(signTime); &#125;&#125; 6、Redis工具类1@Componentpublic class RedisUtil &#123; @Resource private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 判断key是否存在 * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key) &#123; try &#123; return Boolean.TRUE.equals(redisTemplate.hasKey(key)); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125;&#125;","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"接口","slug":"接口","permalink":"https://andy-whb-cn.github.io/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"微服务方案设计","slug":"架构设计/微服务方案设计","date":"2024-08-22T08:33:34.000Z","updated":"2024-09-03T02:30:47.797Z","comments":true,"path":"2024/08/22/架构设计/微服务方案设计/","permalink":"https://andy-whb-cn.github.io/2024/08/22/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"微服务API网关模式链接：https://microservices.io/patterns/apigateway.html","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"微服务","slug":"微服务","permalink":"https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"java","slug":"java","permalink":"https://andy-whb-cn.github.io/tags/java/"}]},{"title":"SpringBoot：对象复制","slug":"SpringBoot/SpringBoot：对象复制","date":"2024-08-22T08:33:34.000Z","updated":"2024-09-03T00:47:21.202Z","comments":true,"path":"2024/08/22/SpringBoot/SpringBoot：对象复制/","permalink":"https://andy-whb-cn.github.io/2024/08/22/SpringBoot/SpringBoot%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/","excerpt":"","text":"今天带来SpringBoot老鸟系列的第四篇，来聊聊在日常开发中如何优雅的实现对象复制。 首先我们看看为什么需要对象复制？ 为什么需要对象复制 如上，是我们平时开发中最常见的三层MVC架构模型，编辑操作时Controller层接收到前端传来的DTO对象，在Service层需要将DTO转换成DO，然后在数据库中保存。查询操作时Service层查询到DO对象后需要将DO对象转换成VO对象，然后通过Controller层返回给前端进行渲染。 这中间会涉及到大量的对象转换，很明显我们不能直接使用getter/setter复制对象属性，这看上去太low了。想象一下你业务逻辑中充斥着大量的getter&amp;setter，代码评审时老鸟们会如何笑话你？ 所以我们必须要找一个第三方工具来帮我们实现对象转换。 看到这里有同学可能会问，为什么不能前后端都统一使用DO对象呢？这样就不存在对象转换呀？ 设想一下如果我们不想定义 DTO 和 VO，直接将 DO 用到数据访问层、服务层、控制层和外部访问接口上。此时该表删除或则修改一个字段，DO 必须同步修改，这种修改将会影响到各层，这并不符合高内聚低耦合的原则。通过定义不同的 DTO 可以控制对不同系统暴露不同的属性，通过属性映射还可以实现具体的字段名称的隐藏。不同业务使用不同的模型，当一个业务发生变更需要修改字段时，不需要考虑对其它业务的影响，如果使用同一个对象则可能因为 “不敢乱改” 而产生很多不优雅的兼容性行为。 对象复制工具类推荐对象复制的类库工具有很多，除了常见的Apache的BeanUtils，Spring的BeanUtils，Cglib BeanCopier，还有重量级组件MapStruct，Orika，Dozer，ModelMapper等。 如果没有特殊要求，这些工具类都可以直接使用，除了Apache的BeanUtils。原因在于Apache BeanUtils底层源码为了追求完美，加了过多的包装，使用了很多反射，做了很多校验，所以导致性能较差，并在阿里巴巴开发手册上强制规定避免使用 Apache BeanUtils。 强制规定避免使用 Apache BeanUtils 至于剩下的重量级组件，综合考虑其性能还有使用的易用性，我这里更推荐使用Orika。Orika底层采用了javassist类库生成Bean映射的字节码，之后直接加载执行生成的字节码文件，在速度上比使用反射进行赋值会快很多。 国外大神 baeldung 已经对常见的组件性能进行过详细测试，大家可以通过 https://www.baeldung.com/java-performance-mapping-frameworks 查看。 Orika基本使用要使用Orika很简单，只需要简单四步： 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;ma.glasnost.orika&lt;/groupId&gt; &lt;artifactId&gt;orika-core&lt;/artifactId&gt; &lt;version&gt;1.5.4&lt;/version&gt;&lt;/dependency&gt; 构造一个MapperFactory 1MapperFactory mapperFactory = new DefaultMapperFactory.Builder().build(); 注册字段映射 12345mapperFactory.classMap(SourceClass.class, TargetClass.class) .field(&quot;firstName&quot;, &quot;givenName&quot;) .field(&quot;lastName&quot;, &quot;sirName&quot;) .byDefault() .register(); 当字段名在两个实体不一致时可以通过.field()方法进行映射，如果字段名都一样则可省略，byDefault()方法用于注册名称相同的属性，如果不希望某个字段参与映射，可以使用exclude方法。 进行映射12345MapperFacade mapper = mapperFactory.getMapperFacade();SourceClass source = new SourceClass(); // set some field values...// map the fields of &#x27;source&#x27; onto a new instance of PersonDestTargetClass target = mapper.map(source, TargetClass.class); 经过上面四步我们就完成了SourceClass到TargetClass的转换。至于Orika的其他使用方法大家可以参考 http://orika-mapper.github.io/orika-docs/index.html 看到这里，肯定有粉丝会说：你这推荐的啥玩意呀，这个Orika使用也不简单呀，每次都要这先创建MapperFactory，建立字段映射关系，才能进行映射转换。 别急，我这里给你准备了一个工具类OrikaUtils，你可以通过文末github仓库获取。 它提供了五个公共方法： 分别对应： 字段一致实体转换 字段不一致实体转换（需要字段映射） 字段一致集合转换 字段不一致集合转换（需要字段映射） 字段属性转换注册 接下来我们通过单元测试案例重点介绍此工具类的使用。 Orika工具类使用文档先准备两个基础实体类，Student，Teacher。 1234567@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; private String id; private String name; private String email;&#125; 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class Teacher &#123; private String id; private String name; private String emailAddress;&#125; TC1，基础实体映射12345678/** * 只拷贝相同的属性 */@Testpublic void convertObject()&#123; Student student = new Student(&quot;1&quot;,&quot;javadaily&quot;,&quot;jianzh5@163.com&quot;); Teacher teacher = OrikaUtils.convert(student, Teacher.class); System.out.println(teacher);&#125; 输出结果： 1Teacher(id=1, name=javadaily, emailAddress=null) 此时由于属性名不一致，无法映射字段email。 TC2，实体映射 - 字段转换123456789/** * 拷贝不同属性 */@Testpublic void convertRefObject()&#123; Student student = new Student(&quot;1&quot;,&quot;javadaily&quot;,&quot;jianzh5@163.com&quot;); Map&lt;String,String&gt; refMap = new HashMap&lt;&gt;(1); //map key 放置 源属性，value 放置 目标属性 refMap.put(&quot;email&quot;,&quot;emailAddress&quot;); Teacher teacher = OrikaUtils.convert(student, Teacher.class, refMap); System.out.println(teacher);&#125; 输出结果： 1Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com) 此时由于对字段做了映射，可以将email映射到emailAddress。注意这里的refMap中key放置的是源实体的属性，而value放置的是目标实体的属性，不要弄反了。 TC3，基础集合映射123456789/** * 只拷贝相同的属性集合 */@Testpublic void convertList()&#123; Student student1 = new Student(&quot;1&quot;,&quot;javadaily&quot;,&quot;jianzh5@163.com&quot;); Student student2 = new Student(&quot;2&quot;,&quot;JAVA日知录&quot;,&quot;jianzh5@xxx.com&quot;); List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2); List&lt;Teacher&gt; teacherList = OrikaUtils.convertList(studentList, Teacher.class); System.out.println(teacherList);&#125; 输出结果： 1[Teacher(id=1, name=javadaily, emailAddress=null), Teacher(id=2, name=JAVA日知录, emailAddress=null)] 此时由于属性名不一致，集合中无法映射字段email。 TC4，集合映射 - 字段映射1234567891011/** * 映射不同属性的集合 */@Testpublic void convertRefList()&#123; Student student1 = new Student(&quot;1&quot;,&quot;javadaily&quot;,&quot;jianzh5@163.com&quot;); Student student2 = new Student(&quot;2&quot;,&quot;JAVA日知录&quot;,&quot;jianzh5@xxx.com&quot;); List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2); Map&lt;String,String&gt; refMap = new HashMap&lt;&gt;(2); //map key 放置 源属性，value 放置 目标属性 refMap.put(&quot;email&quot;,&quot;emailAddress&quot;); List&lt;Teacher&gt; teacherList = OrikaUtils.convertList(studentList, Teacher.class,refMap); System.out.println(teacherList);&#125; 输出结果： 1[Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com), Teacher(id=2, name=JAVA日知录, emailAddress=jianzh5@xxx.com)] 也可以通过这样映射： 123Map&lt;String,String&gt; refMap = new HashMap&lt;&gt;(2);refMap.put(&quot;email&quot;,&quot;emailAddress&quot;);List&lt;Teacher&gt; teacherList = OrikaUtils.classMap(Student.class,Teacher.class,refMap).mapAsList(studentList,Teacher.class); TC5，集合与实体映射有时候我们需要将集合数据映射到实体中，如Person类 12@Datapublic class Person &#123; private List&lt;String&gt; nameParts;&#125; 现在需要将Person类nameParts的值映射到Student中，可以这样做 123456789101112/** * 数组和List的映射 */@Testpublic void convertListObject()&#123; Person person = new Person(); person.setNameParts(Lists.newArrayList(&quot;1&quot;,&quot;javadaily&quot;,&quot;jianzh5@163.com&quot;)); Map&lt;String,String&gt; refMap = new HashMap&lt;&gt;(2); //map key 放置 源属性，value 放置 目标属性 refMap.put(&quot;nameParts[0]&quot;,&quot;id&quot;); refMap.put(&quot;nameParts[1]&quot;,&quot;name&quot;); refMap.put(&quot;nameParts[2]&quot;,&quot;email&quot;); Student student = OrikaUtils.convert(person, Student.class,refMap); System.out.println(student);&#125; 输出结果： 1Student(id=1, name=javadaily, email=jianzh5@163.com) TC6，类类型映射有时候我们需要类类型对象映射，如BasicPerson类 12@Datapublic class BasicPerson &#123; private Student student;&#125; 现在需要将BasicPerson映射到Teacher 12345678910111213/** * 类类型映射 */@Testpublic void convertClassObject()&#123; BasicPerson basicPerson = new BasicPerson(); Student student = new Student(&quot;1&quot;,&quot;javadaily&quot;,&quot;jianzh5@163.com&quot;); basicPerson.setStudent(student); Map&lt;String,String&gt; refMap = new HashMap&lt;&gt;(2); //map key 放置 源属性，value 放置 目标属性 refMap.put(&quot;student.id&quot;,&quot;id&quot;); refMap.put(&quot;student.name&quot;,&quot;name&quot;); refMap.put(&quot;student.email&quot;,&quot;emailAddress&quot;); Teacher teacher = OrikaUtils.convert(basicPerson, Teacher.class,refMap); System.out.println(teacher);&#125; 输出结果： 1Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com) TC7，多重映射有时候我们会遇到多重映射，如将StudentGrade映射到TeacherGrade 1234@Datapublic class StudentGrade &#123; private String studentGradeName; private List&lt;Student&gt; studentList;&#125;@Datapublic class TeacherGrade &#123; private String teacherGradeName; private List&lt;Teacher&gt; teacherList;&#125; 这种场景稍微复杂，Student与Teacher的属性有email字段不相同，需要做转换映射；StudentGrade与TeacherGrade中的属性也需要映射。 1234567891011121314151617181920/** * 一对多映射 */@Testpublic void convertComplexObject()&#123; Student student1 = new Student(&quot;1&quot;,&quot;javadaily&quot;,&quot;jianzh5@163.com&quot;); Student student2 = new Student(&quot;2&quot;,&quot;JAVA日知录&quot;,&quot;jianzh5@xxx.com&quot;); List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2); StudentGrade studentGrade = new StudentGrade(); studentGrade.setStudentGradeName(&quot;硕士&quot;); studentGrade.setStudentList(studentList); Map&lt;String,String&gt; refMap1 = new HashMap&lt;&gt;(1); //map key 放置 源属性，value 放置 目标属性 refMap1.put(&quot;email&quot;,&quot;emailAddress&quot;); OrikaUtils.register(Student.class,Teacher.class,refMap1); Map&lt;String,String&gt; refMap2 = new HashMap&lt;&gt;(2); //map key 放置 源属性，value 放置 目标属性 refMap2.put(&quot;studentGradeName&quot;, &quot;teacherGradeName&quot;); refMap2.put(&quot;studentList&quot;, &quot;teacherList&quot;); TeacherGrade teacherGrade = OrikaUtils.convert(studentGrade,TeacherGrade.class,refMap2); System.out.println(teacherGrade);&#125; 多重映射的场景需要根据情况调用OrikaUtils.register()注册字段映射。 输出结果： 1TeacherGrade(teacherGradeName=硕士, teacherList=[Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com), Teacher(id=2, name=JAVA日知录, emailAddress=jianzh5@xxx.com)]) TC8，MyBaits plus分页映射如果你使用的是mybatis的分页组件，可以这样转换 1234567891011121314public IPage&lt;UserDTO&gt; selectPage(UserDTO userDTO, Integer pageNo, Integer pageSize) &#123; Page page = new Page&lt;&gt;(pageNo, pageSize); LambdaQueryWrapper&lt;User&gt; query = new LambdaQueryWrapper(); if (StringUtils.isNotBlank(userDTO.getName())) &#123; query.like(User::getKindName,userDTO.getName()); &#125; IPage&lt;User&gt; pageList = page(page,query); // 实体转换 SysKind转化为SysKindDto Map&lt;String,String&gt; refMap = new HashMap&lt;&gt;(3); refMap.put(&quot;kindName&quot;,&quot;name&quot;); refMap.put(&quot;createBy&quot;,&quot;createUserName&quot;); refMap.put(&quot;createTime&quot;,&quot;createDate&quot;); return pageList.convert(item &gt; OrikaUtils.convert(item, UserDTO.class, refMap));&#125; 小结在MVC架构中肯定少不了需要用到对象复制，属性转换的功能，借用Orika组件，可以很简单实现这些功能。本文在Orika的基础上封装了工具类，进一步简化了Orika的操作，希望对各位有所帮助。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://andy-whb-cn.github.io/tags/SpringBoot/"}]},{"title":"前端：IFrame自适应高度","slug":"前端/前端：IFrame-Auto-Resize","date":"2024-04-30T06:43:29.847Z","updated":"2024-09-03T00:45:45.976Z","comments":true,"path":"2024/04/30/前端/前端：IFrame-Auto-Resize/","permalink":"https://andy-whb-cn.github.io/2024/04/30/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%EF%BC%9AIFrame-Auto-Resize/","excerpt":"","text":"IFrame子页面自适应高度问题项目中经常会遇到需要通过IFrame集成子页面的情况，比较常见的问题如跨域、自适应页面高度等。 方案一 廖老师这里介绍得很全面，直接引用原文 https://liaoxuefeng.com/blogs/all/2024-02-25-auto-resize-iframe/ 方案二 使用第三方库(Vue), https://github.com/davidjbradshaw/iframe-resizer 安装库1$ npm install iframe-resizer@latest -S IFrame子窗口页面123456789101112131415// directives/iframeResize.jsimport iframeResize from &#x27;iframe-resizer/js/iframeResizer&#x27; export default &#123; beforeMount: (el, &#123; value = &#123;&#125; &#125;) =&gt; &#123; el.addEventListener(&#x27;load&#x27;, () =&gt; iframeResize(value, el)) &#125;, unmounted: (el) =&gt; &#123; el.iFrameResizer.removeListeners() &#125;&#125; // index.jsimport iframeResize from &#x27;./iframeResize&#x27;app.directive(&#x27;resize&#x27;, iframeResize) IFrame父窗口页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;template&gt; &lt;div class=&quot;iframe-wrapper&quot;&gt; &lt;iframe v-resize=&quot;iFrameResizer&quot; id=&quot;Iframe&quot; width=&quot;100%&quot; :src=&quot;url&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;import &#123; jumpOtherSSO &#125; from &#x27;@/utils/sso/sso&#x27;import &#123; openFunc &#125; from &#x27;@/utils/util&#x27;export default &#123; name: &#x27;AppCenter&#x27;, data () &#123; return &#123; iFrameResizer: &#123; log: false, heightCalculationMethod: &#x27;lowestElement&#x27;, warningTimeout: 0 &#125;, ssoUrl: &#x27;&#x27; &#125; &#125;, mounted () &#123; // this.updateIframeHeightFunc() if (this.isUserLogin) &#123; jumpOtherSSO(&#x27;appCenter&#x27;, &#123; page: 1 &#125;).then(res =&gt; &#123; this.ssoUrl = res.data &#125;).catch(() =&gt; &#123; this.ssoUrl = this.$route.query.url &#125;) &#125; window.addEventListener(&#x27;message&#x27;, (e) =&gt; &#123; if (e.data.appId) &#123; const routeData = this.$router.resolve(&#123; name: this.$routerNameMap.appCenterDetails, query: &#123; url: xxx`, id: e.data.appId &#125; &#125;) openFunc(routeData.href) &#125; &#125;) &#125;, computed: &#123; ...mapGetters([&#x27;isUserLogin&#x27;]), url () &#123; return !this.isUserLogin ? this.$route.query.url : this.ssoUrl &#125; &#125;, methods: &#123; updateIframeHeightFunc () &#123; const oIframe = document.getElementById(&#x27;Iframe&#x27;) const deviceHeight = document.documentElement.clientHeight + 2360 oIframe.style.height = `$&#123;deviceHeight&#125;px` &#125; &#125;&#125;&lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt;.iframe-wrapper &#123; width: 100%; height: 100%; border: 0;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://andy-whb-cn.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://andy-whb-cn.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}],"categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://andy-whb-cn.github.io/tags/SpringBoot/"},{"name":"微服务","slug":"微服务","permalink":"https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Java","slug":"Java","permalink":"https://andy-whb-cn.github.io/tags/Java/"},{"name":"脚本","slug":"脚本","permalink":"https://andy-whb-cn.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Vue","slug":"Vue","permalink":"https://andy-whb-cn.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://andy-whb-cn.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Flink","slug":"Flink","permalink":"https://andy-whb-cn.github.io/tags/Flink/"},{"name":"接口","slug":"接口","permalink":"https://andy-whb-cn.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"java","slug":"java","permalink":"https://andy-whb-cn.github.io/tags/java/"}]}