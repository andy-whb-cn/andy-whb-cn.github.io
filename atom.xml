<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andy&#39;s Note</title>
  
  
  <link href="https://andy-whb-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://andy-whb-cn.github.io/"/>
  <updated>2024-09-02T11:02:20.069Z</updated>
  <id>https://andy-whb-cn.github.io/</id>
  
  <author>
    <name>Andy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E6%89%A9%E5%B1%95%E7%82%B9/</id>
    <published>2024-09-02T11:02:01.624Z</published>
    <updated>2024-09-02T11:02:20.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是封装了Spring，遵循约定大于配置，加上自动装配的机制。很多时候我们只要引用了一个依赖，几乎是零配置就能完成一个功能的装配。</p><p>我非常喜欢这种自动装配的机制，所以在自己开发中间件和公共依赖工具的时候也会用到这个特性。让使用者以最小的代价接入。想要把自动装配玩的转，就必须要了解spring对于bean的构造生命周期以及各个扩展接口。当然了解了bean的各个生命周期也能促进我们加深对spring的理解。业务代码也能合理利用这些扩展点写出更加漂亮的代码。</p><p>在网上搜索Spring扩展点，发现很少有博文说的很全的，只有一些常用的扩展点的说明。</p><p>所以在这篇文章里，我总结了几乎Spring &amp; Springboot所有的扩展接口，以及各个扩展点的使用场景。并且整理出了一个bean在spring内部从被加载到最后初始化完成所有可扩展点的顺序调用图。从而我们也能窥探到bean是如何一步步加载到spring容器中的。</p><h2 id="可扩展的接口启动调用顺序图"><a href="#可扩展的接口启动调用顺序图" class="headerlink" title="可扩展的接口启动调用顺序图"></a>可扩展的接口启动调用顺序图</h2><p>以下是我整理的spring容器中Bean的生命周期内所有可扩展的点的调用顺序，下面会一个个分析</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4hB8nHklbQwqMicuD3lsDSHljEIJQOP11Js5oYzt3OgtNuiapvoCnUibkLbINdd3XaHN0S9UoOS3lgzw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="1-ApplicationContextInitializer"><a href="#1-ApplicationContextInitializer" class="headerlink" title="1. ApplicationContextInitializer"></a>1. ApplicationContextInitializer</h2><blockquote><p>org.springframework.context.ApplicationContextInitializer</p></blockquote><p>这是整个spring容器在刷新之前初始化<code>ConfigurableApplicationContext</code>的回调接口，简单来说，就是在容器刷新之前调用此类的<code>initialize</code>方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。</p><p>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestApplicationContextInitializer implements ApplicationContextInitializer &#123;      @Override      public void initialize(ConfigurableApplicationContext applicationContext) &#123;          System.out.println(&quot;[ApplicationContextInitializer]&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><p>因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：</p><ul><li><p>在启动类中用<code>springApplication.addInitializers(new TestApplicationContextInitializer())</code>语句加入</p></li><li><p>配置文件配置<code>context.initializer.classes=com.example.demo.TestApplicationContextInitializer</code></p></li><li><p>Spring SPI扩展，在spring.factories中加入<code>org.springframework.context.ApplicationContextInitializer=com.example.demo.TestApplicationContextInitializer</code></p></li></ul><h2 id="2-BeanDefinitionRegistryPostProcessor"><a href="#2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="2. BeanDefinitionRegistryPostProcessor"></a>2. BeanDefinitionRegistryPostProcessor</h2><blockquote><p>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</p></blockquote><p>这个接口在读取项目中的<code>beanDefinition</code>之后执行，提供一个补充的扩展点。</p><p>使用场景：你可以在这里动态注册自己的<code>beanDefinition</code>，可以加载classpath之外的bean</p><p>扩展方式为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;      @Override      public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;          System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;);      &#125;        @Override      public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;          System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-BeanFactoryPostProcessor"><a href="#3-BeanFactoryPostProcessor" class="headerlink" title="3. BeanFactoryPostProcessor"></a>3. BeanFactoryPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.BeanFactoryPostProcessor</p></blockquote><p>这个接口是<code>beanFactory</code>的扩展接口，调用时机在spring在读取<code>beanDefinition</code>信息之后，实例化bean之前。</p><p>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的<code>beanDefinition</code>的元信息。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;      @Override      public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;          System.out.println(&quot;[BeanFactoryPostProcessor]&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="4-InstantiationAwareBeanPostProcessor"><a href="#4-InstantiationAwareBeanPostProcessor" class="headerlink" title="4. InstantiationAwareBeanPostProcessor"></a>4. InstantiationAwareBeanPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</p></blockquote><p>该接口继承了<code>BeanPostProcess</code>接口，区别如下：</p><p><strong><code>BeanPostProcess</code>接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而<code>InstantiationAwareBeanPostProcessor</code>接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</strong></p><p>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：<strong>实例化阶段</strong> 和<strong>初始化阶段</strong> ，下面一起进行说明，按调用顺序为：</p><ul><li><p><code>postProcessBeforeInstantiation</code>：实例化bean之前，相当于new这个bean之前</p></li><li><p><code>postProcessAfterInstantiation</code>：实例化bean之后，相当于new这个bean之后</p></li><li><p><code>postProcessPropertyValues</code>：bean已经实例化完成，在属性注入时阶段触发，<code>@Autowired</code>,<code>@Resource</code>等注解原理基于此方法实现</p></li><li><p><code>postProcessBeforeInitialization</code>：初始化bean之前，相当于把bean注入spring上下文之前</p></li><li><p><code>postProcessAfterInitialization</code>：初始化bean之后，相当于把bean注入spring上下文之后</p></li></ul><p>使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor &#123;        @Override      public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot; + beanName);          return bean;      &#125;        @Override      public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot; + beanName);          return bean;      &#125;        @Override      public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot; + beanName);          return null;      &#125;        @Override      public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot; + beanName);          return true;      &#125;        @Override      public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot; + beanName);          return pvs;      &#125;</span><br></pre></td></tr></table></figure><h2 id="5-SmartInstantiationAwareBeanPostProcessor"><a href="#5-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="5. SmartInstantiationAwareBeanPostProcessor"></a>5. SmartInstantiationAwareBeanPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</p></blockquote><p>该扩展接口有3个触发点方法：</p><ul><li><p><code>predictBeanType</code>：<br>  该触发点发生在<code>postProcessBeforeInstantiation</code>之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用<code>BeanFactory.getType(name)</code>时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</p></li><li><p><code>determineCandidateConstructors</code>：<br>  该触发点发生在<code>postProcessBeforeInstantiation</code>之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</p></li><li><p><code>getEarlyBeanReference</code>：<br>  该触发点发生在<code>postProcessAfterInstantiation</code>之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。</p></li></ul><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestSmartInstantiationAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor &#123;        @Override      public Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot; + beanName);          return beanClass;      &#125;        @Override      public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot; + beanName);          return null;      &#125;        @Override      public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot; + beanName);          return bean;      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="6-BeanFactoryAware"><a href="#6-BeanFactoryAware" class="headerlink" title="6. BeanFactoryAware"></a>6. BeanFactoryAware</h2><blockquote><p>org.springframework.beans.factory.BeanFactoryAware</p></blockquote><p>这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为<code>setBeanFactory</code>，可以拿到<code>BeanFactory</code>这个属性。</p><p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 <code>BeanFactory</code>，在这个时候，可以对每个bean作特殊化的定制。也或者可以把<code>BeanFactory</code>拿到进行缓存，日后使用。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanFactoryAware implements BeanFactoryAware &#123;      @Override      public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;          System.out.println(&quot;[TestBeanFactoryAware] &quot; + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName());      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="7-ApplicationContextAwareProcessor"><a href="#7-ApplicationContextAwareProcessor" class="headerlink" title="7. ApplicationContextAwareProcessor"></a>7. ApplicationContextAwareProcessor</h2><blockquote><p>org.springframework.context.support.ApplicationContextAwareProcessor</p></blockquote><p>该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWaHkLLxnI5CWkzPIFHHvKmOJASx9aLomwLG0cCsBbJCuicuwfdYX0qo8fYbSLSzWKaSictUTXoGH1A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp" alt="图片"></p><p>可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。<strong>所以这里应该来说是有6个扩展点</strong> ，这里就放一起来说了</p><ul><li><p><code>EnvironmentAware</code>：<br>  用于获取<code>EnviromentAware</code>的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。</p></li><li><p><code>EmbeddedValueResolverAware</code>：<br>  用于获取<code>StringValueResolver</code>的一个扩展类， <code>StringValueResolver</code>用于获取基于<code>String</code>类型的properties的变量，一般我们都用<code>@Value</code>的方式去获取，如果实现了这个Aware接口，把<code>StringValueResolver</code>缓存起来，通过这个类去获取<code>String</code>类型的变量，效果是一样的。</p></li><li><p><code>ResourceLoaderAware</code>：<br>  用于获取<code>ResourceLoader</code>的一个扩展类，<code>ResourceLoader</code>可以用于获取classpath内所有的资源对象，可以扩展此类来拿到<code>ResourceLoader</code>对象。</p></li><li><p><code>ApplicationEventPublisherAware</code>：<br>  用于获取<code>ApplicationEventPublisher</code>的一个扩展类，<code>ApplicationEventPublisher</code>可以用来发布事件，结合<code>ApplicationListener</code>来共同使用，下文在介绍<code>ApplicationListener</code>时会详细提到。这个对象也可以通过spring注入的方式来获得。</p></li><li><p><code>MessageSourceAware</code>：<br>  用于获取<code>MessageSource</code>的一个扩展类，<code>MessageSource</code>主要用来做国际化。</p></li><li><p><code>ApplicationContextAware</code>：<br>  用来获取<code>ApplicationContext</code>的一个扩展类，<code>ApplicationContext</code>应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时<code>ApplicationContext</code>也实现了<code>BeanFactory</code>，<code>MessageSource</code>，<code>ApplicationEventPublisher</code>等接口，也可以用来做相关接口的事情。</p></li></ul><h2 id="8-BeanNameAware"><a href="#8-BeanNameAware" class="headerlink" title="8. BeanNameAware"></a>8. BeanNameAware</h2><blockquote><p>org.springframework.beans.factory.BeanNameAware</p></blockquote><p>可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是<code>postProcessBeforeInitialization</code>之前，这个类的触发点方法只有一个：<code>setBeanName</code></p><p>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class NormalBeanA implements BeanNameAware&#123;      public NormalBeanA() &#123;          System.out.println(&quot;NormalBean constructor&quot;);      &#125;        @Override      public void setBeanName(String name) &#123;          System.out.println(&quot;[BeanNameAware] &quot; + name);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="9-PostConstruct"><a href="#9-PostConstruct" class="headerlink" title="9. @PostConstruct"></a>9. @PostConstruct</h2><blockquote><p>javax.annotation.PostConstruct</p></blockquote><p>这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了<code>@PostConstruct</code>，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在<code>postProcessBeforeInitialization</code>之后，<code>InitializingBean.afterPropertiesSet</code>之前。</p><p>使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class NormalBeanA &#123;      public NormalBeanA() &#123;          System.out.println(&quot;NormalBean constructor&quot;);      &#125;        @PostConstruct      public void init()&#123;          System.out.println(&quot;[PostConstruct] NormalBeanA&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="10-InitializingBean"><a href="#10-InitializingBean" class="headerlink" title="10. InitializingBean"></a>10. InitializingBean</h2><blockquote><p>org.springframework.beans.factory.InitializingBean</p></blockquote><p>这个类，顾名思义，也是用来初始化bean的。<code>InitializingBean</code>接口为bean提供了初始化方法的方式，它只包括<code>afterPropertiesSet</code>方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在<code>postProcessAfterInitialization</code>之前。</p><p>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class NormalBeanA implements InitializingBean&#123;      @Override      public void afterPropertiesSet() throws Exception &#123;          System.out.println(&quot;[InitializingBean] NormalBeanA&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="11-FactoryBean"><a href="#11-FactoryBean" class="headerlink" title="11. FactoryBean"></a>11. FactoryBean</h2><blockquote><p>org.springframework.beans.factory.FactoryBean</p></blockquote><p>一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个<code>org.springframework.bean.factory.FactoryBean</code>的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。<code>FactoryBean</code>接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个<code>FactoryBean</code>的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，<code>FactoryBean</code>开始支持泛型，即接口声明改为<code>FactoryBean&lt;T&gt;</code>的形式</p><p>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿<code>ProxyFactoryBean</code>的功能。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestFactoryBean implements FactoryBean&lt;TestFactoryBean.TestFactoryInnerBean&gt; &#123;        @Override      public TestFactoryBean.TestFactoryInnerBean getObject() throws Exception &#123;          System.out.println(&quot;[FactoryBean] getObject&quot;);          return new TestFactoryBean.TestFactoryInnerBean();      &#125;        @Override      public Class&lt;?&gt; getObjectType() &#123;          return TestFactoryBean.TestFactoryInnerBean.class;      &#125;        @Override      public boolean isSingleton() &#123;          return true;      &#125;        public static class TestFactoryInnerBean&#123;        &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="12-SmartInitializingSingleton"><a href="#12-SmartInitializingSingleton" class="headerlink" title="12. SmartInitializingSingleton"></a>12. SmartInitializingSingleton</h2><blockquote><p>org.springframework.beans.factory.SmartInitializingSingleton</p></blockquote><p>这个接口中只有一个方法<code>afterSingletonsInstantiated</code>，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为<code>postProcessAfterInitialization</code>之后。</p><p>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestSmartInitializingSingleton implements SmartInitializingSingleton &#123;      @Override      public void afterSingletonsInstantiated() &#123;          System.out.println(&quot;[TestSmartInitializingSingleton]&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="13-CommandLineRunner"><a href="#13-CommandLineRunner" class="headerlink" title="13. CommandLineRunner"></a>13. CommandLineRunner</h2><blockquote><p>org.springframework.boot.CommandLineRunner</p></blockquote><p>这个接口也只有一个方法：<code>run(String... args)</code>，触发时机为整个项目启动完毕后，自动执行。如果有多个<code>CommandLineRunner</code>，可以利用<code>@Order</code>来进行排序。</p><p>使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestCommandLineRunner implements CommandLineRunner &#123;        @Override      public void run(String... args) throws Exception &#123;          System.out.println(&quot;[TestCommandLineRunner]&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="14-DisposableBean"><a href="#14-DisposableBean" class="headerlink" title="14. DisposableBean"></a>14. DisposableBean</h2><blockquote><p>org.springframework.beans.factory.DisposableBean</p></blockquote><p>这个扩展点也只有一个方法：<code>destroy()</code>，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行<code>applicationContext.registerShutdownHook</code>时，就会触发这个方法。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class NormalBeanA implements DisposableBean &#123;      @Override      public void destroy() throws Exception &#123;          System.out.println(&quot;[DisposableBean] NormalBeanA&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="15-ApplicationListener"><a href="#15-ApplicationListener" class="headerlink" title="15. ApplicationListener"></a>15. ApplicationListener</h2><blockquote><p>org.springframework.context.ApplicationListener</p></blockquote><p>准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，<code>ApplicationListener</code>可以监听某个事件的<code>event</code>，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。</p><p>接下来罗列下spring主要的内置事件：</p><ul><li><p>ContextRefreshedEvent<br>  ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在<code>ConfigurableApplicationContext</code>接口中使用 <code>refresh()</code>方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，<code>ApplicationContext</code>容器已就绪可用。</p></li><li><p>ContextStartedEvent<br>  当使用 <code>ConfigurableApplicationContext</code> （ApplicationContext子接口）接口中的 start() 方法启动 <code>ApplicationContext</code>时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p></li><li><p>ContextStoppedEvent<br>  当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>stop()</code>停止<code>ApplicationContext</code> 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</p></li><li><p>ContextClosedEvent<br>  当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>close()</code>方法关闭 <code>ApplicationContext</code> 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</p></li><li><p>RequestHandledEvent<br>  这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们从这些spring&amp;springboot的扩展点当中，大致可以窥视到整个bean的生命周期。在业务开发或者写中间件业务的时候，可以合理利用spring提供给我们的扩展点，在spring启动的各个阶段内做一些事情。以达到自定义初始化的目的。此篇总结，如果有错误或者疏漏的地方，恳请指正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%99%90%E6%B5%81/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%99%90%E6%B5%81/</id>
    <published>2024-09-02T10:58:29.715Z</published>
    <updated>2024-09-02T10:59:19.508Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前，我曾写过两篇介绍如何在SpringBoot中使用Guava和Redis实现接口限流的文章。具体包括：</p><ol><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&mid=2247496639&idx=1&sn=4971f8fd16d27eedd81ffc4e0944eed4&chksm=9ad3e9feada460e85f3404e6c86ae2315df0d77c07296a45760cef2e137d0f3cd1d952854029&scene=21#wechat_redirect">使用Guava实现单机令牌桶限流</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&mid=2247505503&idx=1&sn=4b8a0ac1ee6d3362675c46767dd14df1&chksm=9ad3cc1eada445083b4e8e386945db8e7b1113f02a523bde6d4721e5758c4b420d770274535b&scene=21#wechat_redirect">使用Redis实现分布式限流</a></li></ol><p>现在，一个问题摆在我们面前：如何将这两种限流机制整合到同一个组件中，以便用户随时切换呢？</p><p>显然，我们需要定义一个通用的限流组件，将其引入到业务中，并支持通过配置文件自由切换不同的限流机制。举例而言，当使用<code>limit.type=redis</code>时，启用Redis分布式限流组件，当使用<code>limit.type=local</code>时，启用Guava限流组件。这种自由切换机制能够为用户提供更大的灵活性和可维护性。</p><p>接下来，让我们开始动手实现吧！</p><h3 id="第一步，创建通用模块cloud-limiter-starter"><a href="#第一步，创建通用模块cloud-limiter-starter" class="headerlink" title="第一步，创建通用模块cloud-limiter-starter"></a>第一步，创建通用模块cloud-limiter-starter</h3><p>首先在父项目下创建一个模块</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jYuuibyuhu4y8aWlcmziaZicx1n6SHag3GwO5foniafcoibb3Y4wHlS4qKJlXD33S5DknV3qzO2CichY7Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后在pom文件中引入相关依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;!--SpringFramework--&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><blockquote><p>小提示：通用模块命名最好遵照规则以starter命名结束，同时通用模块引入的依赖最好设置<code>&lt;scope&gt;provided&lt;/scope&gt;</code>属性。</p></blockquote><h3 id="第二步，实现限流功能"><a href="#第二步，实现限流功能" class="headerlink" title="第二步，实现限流功能"></a>第二步，实现限流功能</h3><ol><li>创建限流接口</li></ol><p>既然有两种限流机制，按照套路肯定得先创建一个限流接口，就叫<code>LimiterManager</code>吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface LimiterManager &#123;    boolean tryAccess(Limiter limiter);&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>分别实现Redis的限流功能和Guava的限流功能，这里只给出核心代码。</li></ol><p>Guava限流的核心实现GuavaLimiter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Slf4jpublic class GuavaLimiter implements LimiterManager&#123;    private final Map&lt;String, RateLimiter&gt; limiterMap = Maps.newConcurrentMap();    @Override    public boolean tryAccess(Limiter limiter) &#123;        RateLimiter rateLimiter = getRateLimiter(limiter);        if (rateLimiter == null) &#123;            return false;        &#125;        boolean access = rateLimiter.tryAcquire(1,100, TimeUnit.MILLISECONDS);        log.info(&quot;&#123;&#125; access :&#123;&#125;&quot;,limiter.getKey() , access);        return access;    &#125;&#125;    </span><br></pre></td></tr></table></figure><p>Redis限流的核心实现RedisLimiter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Slf4jpublic class RedisLimiter implements LimiterManager&#123;    private final StringRedisTemplate stringRedisTemplate;    public RedisLimiter(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean tryAccess(Limiter limiter) &#123;        String key = limiter.getKey();        if (StringUtils.isEmpty(key)) &#123;            throw new LimiterException( &quot;redis limiter key cannot be null&quot; );        &#125;        List&lt;String&gt; keys = new ArrayList&lt;&gt;();        keys.add( key );        int seconds = limiter.getSeconds();        int limitCount = limiter.getLimitNum();        String luaScript = buildLuaScript();        RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(luaScript, Long.class);        Long count = stringRedisTemplate.execute( redisScript, keys, &quot;&quot; + limitCount, &quot;&quot; + seconds );        log.info( &quot;Access try count is &#123;&#125; for key=&#123;&#125;&quot;, count, key );        return count != null &amp;&amp; count != 0;    &#125;&#125;    </span><br></pre></td></tr></table></figure><h3 id="第三步，创建配置类"><a href="#第三步，创建配置类" class="headerlink" title="第三步，创建配置类"></a>第三步，创建配置类</h3><p>编写配置类根据配置文件注入限流实现类，当配置文件中属性 <code>limit.type=local</code> 时启用Guava限流机制，当<code>limit.type=redis</code> 时启用Redis限流机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Configurationpublic class LimiterConfigure &#123;    @Bean    @ConditionalOnProperty(name = &quot;limit.type&quot;,havingValue = &quot;local&quot;)    public LimiterManager guavaLimiter()&#123;        return new GuavaLimiter();    &#125;    @Bean    @ConditionalOnProperty(name = &quot;limit.type&quot;,havingValue = &quot;redis&quot;)    public LimiterManager redisLimiter(StringRedisTemplate stringRedisTemplate)&#123;        return new RedisLimiter(stringRedisTemplate);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="第四步，创建AOP"><a href="#第四步，创建AOP" class="headerlink" title="第四步，创建AOP"></a>第四步，创建AOP</h3><p>根据前面的两篇文章可知，避免限流功能污染业务逻辑的最好方式是借助Spring AOP，所以很显然还得需要创建一个AOP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Aspect@EnableAspectJAutoProxy(proxyTargetClass = true) //使用CGLIB代理@Conditional(LimitAspectCondition.class)public class LimitAspect &#123;    @Setter(onMethod_ = @Autowired)    private LimiterManager limiterManager;    @Pointcut(&quot;@annotation(com.jianzh5.limit.aop.Limit)&quot;)    private void check() &#123;    &#125;    @Before(&quot;check()&quot;)    public void before(JoinPoint joinPoint)&#123;        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        Method method = signature.getMethod();        Limit limit = method.getAnnotation(Limit.class);        if(limit != null)&#123;            Limiter limiter = Limiter.builder().limitNum(limit.limitNum())                    .seconds(limit.seconds())                    .key(limit.key()).build();            if(!limiterManager.tryAccess(limiter))&#123;                throw new LimiterException( &quot;There are currently many people , please try again later!&quot; );            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>注意到类上我加了一行<code>@Conditional(LimitAspectCondition.class)</code>，使用了自定义条件选择器，意思是只有当配置类中出现了<code>limit.type</code>属性时才会加载这个AOP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class LimitAspectCondition implements Condition &#123;    @Override    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;        //检查配置文件是否包含limit.type属性        return conditionContext.getEnvironment().containsProperty(ConfigConstant.LIMIT_TYPE);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="第四步，创建spring-factories文件，引导SpringBoot加载配置类"><a href="#第四步，创建spring-factories文件，引导SpringBoot加载配置类" class="headerlink" title="第四步，创建spring.factories文件，引导SpringBoot加载配置类"></a>第四步，创建spring.factories文件，引导SpringBoot加载配置类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\  com.jianzh5.limit.config.LimiterConfigure,\  com.jianzh5.limit.aop.LimitAspect</span><br></pre></td></tr></table></figure><p>完整目录结构如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jYuuibyuhu4y8aWlcmziaZicxddAyDsicibHiaibhA7IarQAPmugnuRghR9jSzAGJ1Bqqe8eA2SVaMHcWIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="第五步，在项目中引用限流组件"><a href="#第五步，在项目中引用限流组件" class="headerlink" title="第五步，在项目中引用限流组件"></a>第五步，在项目中引用限流组件</h3><ol><li><p>引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;    &lt;groupId&gt;com.jianzh5&lt;/groupId&gt;    &lt;artifactId&gt;cloud-limit-starter&lt;/artifactId&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在application.properties中设置加载的限流组件</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit.type = redis</span><br></pre></td></tr></table></figure><p>如果不配置此属性则不加载对应限流功能。</p><ol start="3"><li>在需要限流的接口上加上注解<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Limit(key = &quot;Limiter:test&quot;,limitNum = 3,seconds = 1)</span><br></pre></td></tr></table></figure></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过上述步骤，我们已经成功实现了一个通用限流组件。在实际应用中，只需要根据场景需求选择对应的限流机制，即可非常方便的进行限流操作。这种灵活性和便捷性，也是SpringBoot中定义Starter的一般套路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很早以前，我曾写过两篇介绍如何在SpringBoot中使用Guava和Redis实现接口限流的文章。具体包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=224749</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot GraphQL</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9AGraphQL/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9AGraphQL/</id>
    <published>2024-09-02T10:36:22.017Z</published>
    <updated>2024-09-02T10:41:42.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>REST作为一种现代网络应用非常流行的软件架构风格受到广大WEB开发者的喜爱，在目前软件架构设计模式中随处可见REST的身影，但是随着REST的流行与发展，它的一个最大的缺点开始暴露出来：</p><blockquote><p>在很多时候客户端需要的数据往往在不同的地方具有相似性，但却又不尽相同。</p><p>如同样的用户信息，在有的场景下前端只需要用户的简要信息（名称、头像），在其他场景下又需要用户的详细信息。当这样的相似但又不同的地方多的时候，就需要开发更多的接口来满足前端的需要。</p><p>随着这样的场景越来越多，接口越来越多，文档越来越臃肿，前后端沟通成本呈指数增加。</p></blockquote><p>基于上面的场景，我们迫切需要有一种解决方案或框架，可以使得在使用同一个领域模型（DO、DTO）的数据接口时可以由前端指定需要的接口字段，而后端根据前端的需求自动适配并返回对应的字段。</p><p>这就是我们今天的主角GraphQL。</p><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><p>考虑下面的场景：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1u3gJl6YBstESJE1iciaLLvicGmXLtFuIyfuzN2OoRRhUlTgujVgciatvXZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>用户 与 文章 是一对多的关系，一个用户可以发表多篇文章，同时又可以根据文章找到对应的作者。</p><p>我们需要构建以下几个Graphql查询：</p><ul><li>根据用户ID获取用户详情，并获取此用户发表的所有文章</li><li>根据文章ID获取文章详情，并获取文章作者的信息</li></ul><p>当然项目是基于SpringBoot开发的。</p><h2 id="开发实战"><a href="#开发实战" class="headerlink" title="开发实战"></a>开发实战</h2><p>在正式开发之前我推荐你在IDEA上安装一下 JS GraphQL插件，这个插件方便我们编写Schema，语法纠错，代码高亮等等。。。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uBPkL45bhWrKgWkOnQNUME0VLI5CevxknxPbyAAF5WCmIia8fdCMJJeg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="创建一个SpringBoot项目"><a href="#创建一个SpringBoot项目" class="headerlink" title="创建一个SpringBoot项目"></a>创建一个SpringBoot项目</h3><p>通过IDEA创建一个SpringBoot项目，并引入对应的jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--graphql start--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java-tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--graphql end--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里主要需要引入 <code>graphql-spring-boot-starter</code>和 <code>graphql-java-tools</code>。</p><h3 id="建立Java实体类"><a href="#建立Java实体类" class="headerlink" title="建立Java实体类"></a>建立Java实体类</h3><p>User</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Datapublic class User &#123;    private int userId;    private String userName;    private String realName;    private String email;    private List&lt;Post&gt; posts;    public User() &#123;    &#125;    public User(int userId, String userName, String realName, String email) &#123;        this.userId = userId;        this.userName = userName;        this.realName = realName;        this.email = email;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>Post</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Datapublic class Post &#123;    private int postId;    private String title ;    private String text;    private String  category;    private User user;    public Post() &#123;    &#125;    public Post(int postId, String title, String text, String category) &#123;        this.postId = postId;        this.title = title;        this.text = text;        this.category = category;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>定义了两个JAVA实体：Post，User。</p><h3 id="编写Schema文件"><a href="#编写Schema文件" class="headerlink" title="编写Schema文件"></a>编写Schema文件</h3><p>在resources&#x2F;schema目录下创建GraphQL Schema文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">schema <span class="punctuation">&#123;</span> </span><br><span class="line">query<span class="punctuation">:</span> Query<span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">type Query <span class="punctuation">&#123;</span> </span><br><span class="line"># 获取具体的用户   </span><br><span class="line">getUserById(id<span class="punctuation">:</span>Int) <span class="punctuation">:</span> User    </span><br><span class="line"># 获取具体的博客    </span><br><span class="line">getPostById(id<span class="punctuation">:</span>Int) <span class="punctuation">:</span> Post</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">type User </span><br><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">userId <span class="punctuation">:</span> ID!<span class="punctuation">,</span> </span><br><span class="line">userName <span class="punctuation">:</span> String<span class="punctuation">,</span></span><br><span class="line">realName <span class="punctuation">:</span> String<span class="punctuation">,</span>   </span><br><span class="line">email <span class="punctuation">:</span> String<span class="punctuation">,</span>   </span><br><span class="line">posts <span class="punctuation">:</span> <span class="punctuation">[</span>Post<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">type Post <span class="punctuation">&#123;</span>   </span><br><span class="line">postId <span class="punctuation">:</span> ID!<span class="punctuation">,</span>  </span><br><span class="line">title <span class="punctuation">:</span> String!<span class="punctuation">,</span>   </span><br><span class="line">text <span class="punctuation">:</span> String<span class="punctuation">,</span> </span><br><span class="line">category<span class="punctuation">:</span> String    </span><br><span class="line">user<span class="punctuation">:</span> User<span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如上，我们通过 <code>type</code>关键字定义了两个对象，User与Post。在属性后面添加！表明这是一个非空属性，通过[Post]表明这是一个Post集合，类似于Java对象中List。</p><p>通过Query关键字定义了两个查询对象，getUserById，getPostById，分别返回User对象和Post对象。</p><p>关于schema的语法大家可以参考链接：<code>https://graphql.org/learn/schema</code></p><h3 id="编写业务逻辑"><a href="#编写业务逻辑" class="headerlink" title="编写业务逻辑"></a>编写业务逻辑</h3><p>PostService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostService</span> <span class="keyword">implements</span> <span class="title class_">GraphQLQueryResolver</span> &#123; </span><br><span class="line"><span class="comment">/**     * 为了测试，只查询id为1的结果     */</span>    </span><br><span class="line"><span class="keyword">public</span> Post <span class="title function_">getPostById</span><span class="params">(<span class="type">int</span> id)</span>&#123;     </span><br><span class="line"><span class="keyword">if</span>(id == <span class="number">1</span>)&#123;        </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;JAVA日知录&quot;</span>,<span class="string">&quot;zhangsan@qq.com&quot;</span>);           </span><br><span class="line"><span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="number">1</span>,<span class="string">&quot;Hello,Graphql&quot;</span>,<span class="string">&quot;Graphql初体验&quot;</span>,<span class="string">&quot;日记&quot;</span>);           </span><br><span class="line">post.setUser(user);         </span><br><span class="line"><span class="keyword">return</span> post;       </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;       </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> <span class="keyword">implements</span> <span class="title class_">GraphQLQueryResolver</span> &#123; </span><br><span class="line">List&lt;User&gt; userList = Lists.newArrayList(); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>&#123;        </span><br><span class="line"><span class="keyword">return</span> userList.stream()</span><br><span class="line">.filter(item &gt; item.getUserId() == id)</span><br><span class="line">.findAny()</span><br><span class="line">.orElse(<span class="literal">null</span>);  </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">initUsers</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="type">Post</span> <span class="variable">post1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="number">1</span>,<span class="string">&quot;Hello,Graphql1&quot;</span>,<span class="string">&quot;Graphql初体验1&quot;</span>,<span class="string">&quot;日记&quot;</span>);      </span><br><span class="line"><span class="type">Post</span> <span class="variable">post2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="number">2</span>,<span class="string">&quot;Hello,Graphql2&quot;</span>,<span class="string">&quot;Graphql初体验2&quot;</span>,<span class="string">&quot;日记&quot;</span>);      </span><br><span class="line"><span class="type">Post</span> <span class="variable">post3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="number">3</span>,<span class="string">&quot;Hello,Graphql3&quot;</span>,<span class="string">&quot;Graphql初体验3&quot;</span>,<span class="string">&quot;日记&quot;</span>);      </span><br><span class="line">List&lt;Post&gt; posts = Lists.newArrayList(post1,post2,post3);    </span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;zhangsan@qq.com&quot;</span>);        </span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;lisi@qq.com&quot;</span>);        </span><br><span class="line">user1.setPosts(posts);        </span><br><span class="line">user2.setPosts(posts);        </span><br><span class="line">userList.add(user1);      </span><br><span class="line">userList.add(user2);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于Graphql的查询需要实现 <code>GraphQLQueryResolver</code>接口，由于为了便于演示我们并没有引入数据层，请大家知悉。</p><h3 id="配置Graphql-端点"><a href="#配置Graphql-端点" class="headerlink" title="配置Graphql 端点"></a>配置Graphql 端点</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port </span>=<span class="string"> 8080</span></span><br><span class="line"><span class="attr">graphql.servlet.corsEnabled</span>=<span class="string">true# 配置端点</span></span><br><span class="line"><span class="attr">graphql.servlet.mapping</span>=<span class="string">/graphql</span></span><br><span class="line"><span class="attr">graphql.servlet.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>配置完端口和端点后我们就可以对我们编写的Graphql接口进行测试了。</p><p>接口地址为：<code>localhost:8080/graphql</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这里我使用的是Chrome浏览器的 <code>Altair Graphal Client</code>插件，当然你还可以使用其他的客户端工具，如：graphql-playground。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>浏览器输入chrome:&#x2F;&#x2F;extensions&#x2F;，在扩展中心搜索Altair后即可添加至浏览器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uxnfmDuJRqzO2vicjlZzLvdiaLAB3X4rr0bMezgfbicEicvhXjuYE5QctdA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>启动SpringBoot项目，然后在打开的Altair插件界面，输入Graphql端点 <a href="http://localhost:8080/graphql%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB">http://localhost:8080/graphql，然后点击</a> <code>Docs</code>，将鼠标移至需要的查询上，点击 <code>ADD QUERY</code> 即可添加对应的查询。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uIkduYW1CQ0r4f8py1oOQQ76TZqsTfiacGicLEYxqg3dmfNkgvHost3rA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>点击Send Request 即可看到查询结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uMNlCkgiauNp7aiav2vSiclkBywh5H9vMGFyF9t5FOdrTaybVt87JCq1mA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后我们在Query中可以根据我们的需要新增或删除接口字段并重新请求接口，会看到响应结果中也会根据我们的请求自动返回结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1u7QatEVdg9FutWzOo5vicRTVnqfRMHt2GGLNgDyx19WHNWVW3PgJURiaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Graphql支持的数据操作有：</p><ul><li>查询（Query）：获取数据的基本查询。</li><li>变更（Mutation）：支持对数据的增删改等操作。</li><li>订阅（Subscription）：用于监听数据变动、并靠websocket等协议推送变动的消息给对方。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uUGM03Go1mnHjOxvOY0jDHMIk5ouprdcWG3WlVHibJXSeF2snsfAa3vQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>本节内容我们基于SpringBoot完成了Query的数据操作，实现过程还是相对比较简单。希望此文能让大家对Graphql有一个整体的了解，如果大家对Graphql感兴趣后面还会更新此系列文章，完成对其他数据操作的整合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;REST作为一种现代网络应用非常流行的软件架构风格受到广大WEB开发者的喜爱，在目前软件架构设计模式中随处可见REST的身影，但是随着RES</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot：对象复制</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/</id>
    <published>2024-09-02T10:16:15.267Z</published>
    <updated>2024-09-02T10:28:00.613Z</updated>
    
    <content type="html"><![CDATA[<p>今天带来SpringBoot老鸟系列的第四篇，来聊聊在日常开发中如何优雅的实现对象复制。</p><p>首先我们看看为什么需要对象复制？</p><h2 id="为什么需要对象复制"><a href="#为什么需要对象复制" class="headerlink" title="为什么需要对象复制"></a>为什么需要对象复制</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gBVFX960VSFkYxMfAPwTAEHQtPUThRTsfjgibRSOCd5pRdVNvh4AIbak04GwxJEX7libic3libBgqFuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>如上，是我们平时开发中最常见的三层MVC架构模型，编辑操作时Controller层接收到前端传来的DTO对象，在Service层需要将<code>DTO</code>转换成<code>DO</code>，然后在数据库中保存。查询操作时Service层查询到DO对象后需要将<code>DO</code>对象转换成<code>VO</code>对象，然后通过Controller层返回给前端进行渲染。</p><p>这中间会涉及到大量的对象转换，很明显我们不能直接使用<code>getter/setter</code>复制对象属性，这看上去太low了。想象一下你业务逻辑中充斥着大量的<code>getter&amp;setter</code>，代码评审时老鸟们会如何笑话你？</p><p>所以我们必须要找一个第三方工具来帮我们实现对象转换。</p><blockquote><p>看到这里有同学可能会问，为什么不能前后端都统一使用DO对象呢？这样就不存在对象转换呀？</p><p>设想一下如果我们不想定义 DTO 和 VO，直接将 DO 用到数据访问层、服务层、控制层和外部访问接口上。此时该表删除或则修改一个字段，DO 必须同步修改，这种修改将会影响到各层，这并不符合高内聚低耦合的原则。通过定义不同的 DTO 可以控制对不同系统暴露不同的属性，通过属性映射还可以实现具体的字段名称的隐藏。不同业务使用不同的模型，当一个业务发生变更需要修改字段时，不需要考虑对其它业务的影响，如果使用同一个对象则可能因为 “不敢乱改” 而产生很多不优雅的兼容性行为。</p></blockquote><h2 id="对象复制工具类推荐"><a href="#对象复制工具类推荐" class="headerlink" title="对象复制工具类推荐"></a>对象复制工具类推荐</h2><p>对象复制的类库工具有很多，除了常见的Apache的<code>BeanUtils</code>，Spring的<code>BeanUtils</code>，<code>Cglib BeanCopier</code>，还有重量级组件<code>MapStruct</code>，<code>Orika</code>，<code>Dozer</code>，<code>ModelMapper</code>等。</p><p>如果没有特殊要求，这些工具类都可以直接使用，除了Apache的<code>BeanUtils</code>。原因在于<code>Apache BeanUtils</code>底层源码为了追求完美，加了过多的包装，使用了很多反射，做了很多校验，所以导致性能较差，并在阿里巴巴开发手册上强制规定避免使用 Apache BeanUtils。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4gBVFX960VSFkYxMfAPwTAEbicT7ibC4EZgcMQQD42eE9AfeibXT9P4rutYIEF9ERw74WWE9A6GbN9HQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>强制规定避免使用 Apache BeanUtils</strong></p><p>至于剩下的重量级组件，综合考虑其性能还有使用的易用性，我这里更推荐使用<code>Orika</code>。Orika底层采用了javassist类库生成Bean映射的字节码，之后直接加载执行生成的字节码文件，在速度上比使用反射进行赋值会快很多。</p><blockquote><p>国外大神 baeldung 已经对常见的组件性能进行过详细测试，大家可以通过 <a href="https://www.baeldung.com/java-performance-mapping-frameworks">https://www.baeldung.com/java-performance-mapping-frameworks</a> 查看。</p></blockquote><h2 id="Orika基本使用"><a href="#Orika基本使用" class="headerlink" title="Orika基本使用"></a>Orika基本使用</h2><p>要使用Orika很简单，只需要简单四步：</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ma.glasnost.orika<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>orika-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>构造一个MapperFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MapperFactory</span> <span class="variable">mapperFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMapperFactory</span>.Builder().build();  </span><br></pre></td></tr></table></figure></li><li><p>注册字段映射</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapperFactory.classMap(SourceClass.class, TargetClass.class)    </span><br><span class="line">.field(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;givenName&quot;</span>)   </span><br><span class="line">.field(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;sirName&quot;</span>)   </span><br><span class="line">.byDefault()   </span><br><span class="line">.register();</span><br></pre></td></tr></table></figure><p>当字段名在两个实体不一致时可以通过<code>.field()</code>方法进行映射，如果字段名都一样则可省略，<code>byDefault()</code>方法用于注册名称相同的属性，如果不希望某个字段参与映射，可以使用<code>exclude</code>方法。</p><ol start="4"><li>进行映射<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MapperFacade</span> <span class="variable">mapper</span> <span class="operator">=</span> mapperFactory.getMapperFacade();</span><br><span class="line"><span class="type">SourceClass</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SourceClass</span>();  </span><br><span class="line"><span class="comment">// set some field values...</span></span><br><span class="line"><span class="comment">// map the fields of &#x27;source&#x27; onto a new instance of </span></span><br><span class="line"><span class="type">PersonDestTargetClass</span> <span class="variable">target</span> <span class="operator">=</span> mapper.map(source, TargetClass.class);  </span><br></pre></td></tr></table></figure></li></ol><p>经过上面四步我们就完成了SourceClass到TargetClass的转换。至于Orika的其他使用方法大家可以参考 <code>http://orika-mapper.github.io/orika-docs/index.html</code></p><p>看到这里，肯定有粉丝会说：你这推荐的啥玩意呀，这个Orika使用也不简单呀，每次都要这先创建<code>MapperFactory</code>，建立字段映射关系，才能进行映射转换。</p><p>别急，我这里给你准备了一个工具类<code>OrikaUtils</code>，你可以通过<code>文末github仓库</code>获取。</p><p>它提供了五个公共方法：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gBVFX960VSFkYxMfAPwTAEGWNjiabibrzE07fsCD0pLZgAE1iaTgmlS3fqo2wXjRWsxOXMnAokFEcVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>分别对应：</p><ol><li>字段一致实体转换</li><li>字段不一致实体转换（需要字段映射）</li><li>字段一致集合转换</li><li>字段不一致集合转换（需要字段映射）</li><li>字段属性转换注册</li></ol><p>接下来我们通过单元测试案例重点介绍此工具类的使用。</p><h2 id="Orika工具类使用文档"><a href="#Orika工具类使用文档" class="headerlink" title="Orika工具类使用文档"></a>Orika工具类使用文档</h2><p>先准备两个基础实体类，Student，Teacher。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;   </span><br><span class="line"><span class="keyword">private</span> String id;    </span><br><span class="line"><span class="keyword">private</span> String name;    </span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;    </span><br><span class="line"><span class="keyword">private</span> String id;    </span><br><span class="line"><span class="keyword">private</span> String name;    </span><br><span class="line"><span class="keyword">private</span> String emailAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TC1，基础实体映射"><a href="#TC1，基础实体映射" class="headerlink" title="TC1，基础实体映射"></a>TC1，基础实体映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 只拷贝相同的属性 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertObject</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>); </span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> OrikaUtils.convert(student, Teacher.class);  </span><br><span class="line">System.out.println(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher(id=1, name=javadaily, emailAddress=null)</span><br></pre></td></tr></table></figure><p>此时由于属性名不一致，无法映射字段email。</p><h3 id="TC2，实体映射-字段转换"><a href="#TC2，实体映射-字段转换" class="headerlink" title="TC2，实体映射 - 字段转换"></a>TC2，实体映射 - 字段转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 拷贝不同属性 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertRefObject</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>);  </span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span>);  <span class="comment">//map key 放置 源属性，value 放置 目标属性  </span></span><br><span class="line">refMap.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);  </span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> OrikaUtils.convert(student, Teacher.class, refMap);  </span><br><span class="line">System.out.println(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com)</span><br></pre></td></tr></table></figure><p>此时由于对字段做了映射，可以将email映射到emailAddress。注意这里的refMap中key放置的是源实体的属性，而value放置的是目标实体的属性，不要弄反了。</p><h3 id="TC3，基础集合映射"><a href="#TC3，基础集合映射" class="headerlink" title="TC3，基础集合映射"></a>TC3，基础集合映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  * 只拷贝相同的属性集合  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertList</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>); </span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;JAVA日知录&quot;</span>,<span class="string">&quot;jianzh5@xxx.com&quot;</span>);  </span><br><span class="line">List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2); </span><br><span class="line">List&lt;Teacher&gt; teacherList = OrikaUtils.convertList(studentList, Teacher.class);</span><br><span class="line">System.out.println(teacherList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Teacher(id=1, name=javadaily, emailAddress=null), Teacher(id=2, name=JAVA日知录, emailAddress=null)]</span><br></pre></td></tr></table></figure><p>此时由于属性名不一致，集合中无法映射字段email。</p><h3 id="TC4，集合映射-字段映射"><a href="#TC4，集合映射-字段映射" class="headerlink" title="TC4，集合映射 - 字段映射"></a>TC4，集合映射 - 字段映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 映射不同属性的集合 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertRefList</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>); </span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;JAVA日知录&quot;</span>,<span class="string">&quot;jianzh5@xxx.com&quot;</span>);  </span><br><span class="line">List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2);</span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);  <span class="comment">//map key 放置 源属性，value 放置 目标属性  </span></span><br><span class="line">refMap.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);</span><br><span class="line">List&lt;Teacher&gt; teacherList = OrikaUtils.convertList(studentList, Teacher.class,refMap);  </span><br><span class="line">System.out.println(teacherList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com), Teacher(id=2, name=JAVA日知录, emailAddress=jianzh5@xxx.com)]</span><br></pre></td></tr></table></figure><p>也可以通过这样映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">refMap.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);</span><br><span class="line">List&lt;Teacher&gt; teacherList = OrikaUtils.classMap(Student.class,Teacher.class,refMap).mapAsList(studentList,Teacher.class);</span><br></pre></td></tr></table></figure><h3 id="TC5，集合与实体映射"><a href="#TC5，集合与实体映射" class="headerlink" title="TC5，集合与实体映射"></a>TC5，集合与实体映射</h3><p>有时候我们需要将集合数据映射到实体中，如Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="keyword">private</span> List&lt;String&gt; nameParts;&#125;</span><br></pre></td></tr></table></figure><p>现在需要将Person类nameParts的值映射到Student中，可以这样做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 数组和List的映射 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertListObject</span><span class="params">()</span>&#123;   </span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">person.setNameParts(Lists.newArrayList(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>));   </span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);    <span class="comment">//map key 放置 源属性，value 放置 目标属性   </span></span><br><span class="line">refMap.put(<span class="string">&quot;nameParts[0]&quot;</span>,<span class="string">&quot;id&quot;</span>);   </span><br><span class="line">refMap.put(<span class="string">&quot;nameParts[1]&quot;</span>,<span class="string">&quot;name&quot;</span>);   </span><br><span class="line">refMap.put(<span class="string">&quot;nameParts[2]&quot;</span>,<span class="string">&quot;email&quot;</span>);   </span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> OrikaUtils.convert(person, Student.class,refMap);    </span><br><span class="line">System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(id=1, name=javadaily, email=jianzh5@163.com)</span><br></pre></td></tr></table></figure><h3 id="TC6，类类型映射"><a href="#TC6，类类型映射" class="headerlink" title="TC6，类类型映射"></a>TC6，类类型映射</h3><p>有时候我们需要类类型对象映射，如BasicPerson类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicPerson</span> &#123;    <span class="keyword">private</span> Student student;&#125;</span><br></pre></td></tr></table></figure><p>现在需要将BasicPerson映射到Teacher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 类类型映射 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertClassObject</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">BasicPerson</span> <span class="variable">basicPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicPerson</span>();  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>); </span><br><span class="line">basicPerson.setStudent(student);    </span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);    <span class="comment">//map key 放置 源属性，value 放置 目标属性    </span></span><br><span class="line">refMap.put(<span class="string">&quot;student.id&quot;</span>,<span class="string">&quot;id&quot;</span>);  </span><br><span class="line">refMap.put(<span class="string">&quot;student.name&quot;</span>,<span class="string">&quot;name&quot;</span>);   </span><br><span class="line">refMap.put(<span class="string">&quot;student.email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);   </span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> OrikaUtils.convert(basicPerson, Teacher.class,refMap);</span><br><span class="line">System.out.println(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com)</span><br></pre></td></tr></table></figure><h3 id="TC7，多重映射"><a href="#TC7，多重映射" class="headerlink" title="TC7，多重映射"></a>TC7，多重映射</h3><p>有时候我们会遇到多重映射，如将<code>StudentGrade</code>映射到<code>TeacherGrade</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentGrade</span> &#123;    <span class="keyword">private</span> String studentGradeName;    <span class="keyword">private</span> List&lt;Student&gt; studentList;&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherGrade</span> &#123;    <span class="keyword">private</span> String teacherGradeName;    <span class="keyword">private</span> List&lt;Teacher&gt; teacherList;&#125;</span><br></pre></td></tr></table></figure><p>这种场景稍微复杂，Student与Teacher的属性有email字段不相同，需要做转换映射；StudentGrade与TeacherGrade中的属性也需要映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 一对多映射 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertComplexObject</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>);  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;JAVA日知录&quot;</span>,<span class="string">&quot;jianzh5@xxx.com&quot;</span>);  </span><br><span class="line">List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2); </span><br><span class="line"></span><br><span class="line"><span class="type">StudentGrade</span> <span class="variable">studentGrade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentGrade</span>(); </span><br><span class="line">studentGrade.setStudentGradeName(<span class="string">&quot;硕士&quot;</span>); </span><br><span class="line">studentGrade.setStudentList(studentList);  </span><br><span class="line">Map&lt;String,String&gt; refMap1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span>);  <span class="comment">//map key 放置 源属性，value 放置 目标属性  </span></span><br><span class="line">refMap1.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);  </span><br><span class="line">OrikaUtils.register(Student.class,Teacher.class,refMap1);  </span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; refMap2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);  <span class="comment">//map key 放置 源属性，value 放置 目标属性  </span></span><br><span class="line">refMap2.put(<span class="string">&quot;studentGradeName&quot;</span>, <span class="string">&quot;teacherGradeName&quot;</span>);  </span><br><span class="line">refMap2.put(<span class="string">&quot;studentList&quot;</span>, <span class="string">&quot;teacherList&quot;</span>);  </span><br><span class="line"><span class="type">TeacherGrade</span> <span class="variable">teacherGrade</span> <span class="operator">=</span> OrikaUtils.convert(studentGrade,TeacherGrade.class,refMap2);  </span><br><span class="line">System.out.println(teacherGrade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多重映射的场景需要根据情况调用<code>OrikaUtils.register()</code>注册字段映射。</p><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TeacherGrade(teacherGradeName=硕士, teacherList=[Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com), Teacher(id=2, name=JAVA日知录, emailAddress=jianzh5@xxx.com)])</span><br></pre></td></tr></table></figure><h3 id="TC8，MyBaits-plus分页映射"><a href="#TC8，MyBaits-plus分页映射" class="headerlink" title="TC8，MyBaits plus分页映射"></a>TC8，MyBaits plus分页映射</h3><p>如果你使用的是mybatis的分页组件，可以这样转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IPage&lt;UserDTO&gt; <span class="title function_">selectPage</span><span class="params">(UserDTO userDTO, Integer pageNo, Integer pageSize)</span> &#123;</span><br><span class="line"><span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNo, pageSize);</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; query = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>(); </span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotBlank(userDTO.getName())) &#123;  </span><br><span class="line">query.like(User::getKindName,userDTO.getName());  </span><br><span class="line">&#125;  </span><br><span class="line">IPage&lt;User&gt; pageList = page(page,query);  <span class="comment">// 实体转换 SysKind转化为SysKindDto  </span></span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);  </span><br><span class="line">refMap.put(<span class="string">&quot;kindName&quot;</span>,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">refMap.put(<span class="string">&quot;createBy&quot;</span>,<span class="string">&quot;createUserName&quot;</span>);  </span><br><span class="line">refMap.put(<span class="string">&quot;createTime&quot;</span>,<span class="string">&quot;createDate&quot;</span>);  </span><br><span class="line"><span class="keyword">return</span> pageList.convert(item &gt; OrikaUtils.convert(item, UserDTO.class, refMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在MVC架构中肯定少不了需要用到对象复制，属性转换的功能，借用Orika组件，可以很简单实现这些功能。本文在Orika的基础上封装了工具类，进一步简化了Orika的操作，希望对各位有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天带来SpringBoot老鸟系列的第四篇，来聊聊在日常开发中如何优雅的实现对象复制。&lt;/p&gt;
&lt;p&gt;首先我们看看为什么需要对象复制？&lt;/p&gt;
&lt;h2 id=&quot;为什么需要对象复制&quot;&gt;&lt;a href=&quot;#为什么需要对象复制&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot: 启动参数</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/</id>
    <published>2024-09-02T09:02:25.399Z</published>
    <updated>2024-09-02T10:11:44.630Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span>  </span><br><span class="line">  <span class="attr">tomcat:</span>  </span><br><span class="line">    <span class="string">min-spare-threads:</span> <span class="number">20</span>  </span><br><span class="line">    <span class="string">max-threads:</span> <span class="number">100</span>  </span><br><span class="line">  <span class="string">connection-timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>目前的容器优化，目前来说没有太多地方，需要考虑如下几个点</p><ul><li>线程数</li><li>超时时间</li></ul><p>这块对tomcat进行了一个优化配置，最大线程数是100，初始化线程是20, 超时时间是5000ms</p><p>默认tomcat最大线程数200，初始化线程10, 连接超时时间20s</p><p>⚠️upload failed, check dev console</p><p>⚠️upload failed, check dev console</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Restful API 版本控制</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9ARestful%20API%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9ARestful%20API%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</id>
    <published>2024-09-02T08:47:53.483Z</published>
    <updated>2024-09-02T08:57:11.861Z</updated>
    
    <content type="html"><![CDATA[<p>在实际项目开发中我们经常需要对接口进行版本管理。那今天我们就来聊聊为什么需要版本控制，以及如何对REST API进行版本控制。我们将讨论4种版本控制的方法，并比较不同的方法。</p><p>通过此文您将学到</p><ul><li>为什么我们需要对RESTful API 进行版本控制?</li><li>可用的版本控制有哪些?</li><li>如何实现基于 Restful 的版本控制?</li></ul><h2 id="为什么我们需要对RESTful-API进行版本化"><a href="#为什么我们需要对RESTful-API进行版本化" class="headerlink" title="为什么我们需要对RESTful API进行版本化"></a>为什么我们需要对RESTful API进行版本化</h2><p>最好的版本控制方法是不进行版本控制。</p><blockquote><p>构建向后兼容的服务，以便尽可能避免版本控制！</p></blockquote><p>然而，在许多情况下我们都需要进行版本控制，然我们看看下面具体的例子：<br>最初，你有个这个版本的Student服务，返回数据如下：<br><code>&#123;     &quot;name&quot;: &quot;Bob Charlie&quot;   &#125;   </code></p><p>后来，您希望将学生的名字拆分，因此创建了这个版本的服务。<br><code>&#123;     &quot;name&quot;: &#123;       &quot;firstName&quot;: &quot;Bob&quot;,       &quot;lastName&quot;: &quot;Charlie&quot;     &#125;   &#125;   </code></p><p>您可以从同一个服务支持这两个请求，但是随着每个版本的需求多样化，它会变得越来越复杂。</p><p>在这种情况下，版本控制就成必不可少，强制性的了。</p><p>接下来让我们创建一个简单的SpringBoot的maven项目，并理解对 RESTful 服务进行版本控制的4种不同方法。</p><p><strong>几个用于实现版本控制的Bean</strong></p><p>第一个版本的 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="meta">@AllArgsConstructor</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentV1</span> &#123;      </span><br><span class="line"><span class="keyword">private</span> String name;   </span><br><span class="line">&#125;   `</span><br></pre></td></tr></table></figure><p>第二个版本的 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentV2</span> &#123;       </span><br><span class="line"><span class="keyword">private</span> Name name;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>StudentV2使用的Name实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="meta">@AllArgsConstructor</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Name</span> &#123;       </span><br><span class="line"><span class="keyword">private</span> String firstName;       </span><br><span class="line"><span class="keyword">private</span> String lastName;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="Restful-版本控制的方法"><a href="#Restful-版本控制的方法" class="headerlink" title="Restful 版本控制的方法"></a>Restful 版本控制的方法</h2><p>我们希望创建两个版本的服务，一个返回 StudentV1，另一个返回 StudentV2。</p><p>让我们来看看创建相同服务版本的4种不同方法。</p><h3 id="通过-URI-进行版本控制"><a href="#通过-URI-进行版本控制" class="headerlink" title="通过 URI 进行版本控制"></a>通过 URI 进行版本控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentUriController</span> &#123;       </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;v1/student&quot;)</span>     </span><br><span class="line"><span class="keyword">public</span> StudentV1 <span class="title function_">studentV1</span><span class="params">()</span> &#123;      </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV1</span>(<span class="string">&quot;javadaily&quot;</span>);      </span><br><span class="line">&#125;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;v2/student&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> StudentV2 <span class="title function_">studentV2</span><span class="params">()</span> &#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV2</span>(<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;javadaily&quot;</span>, <span class="string">&quot;JAVA日知录&quot;</span>));     </span><br><span class="line">&#125;      </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>请求：<code>http://localhost:8080/v1/student</code><br>响应：{“name”:”javadaily”}</p><p>请求：<code>http://localhost:8080/v2/student</code><br>响应：{“name”:{“firstName”:”javadaily”,”lastName”:”JAVA日知录”}}</p><h3 id="通过请求参数进行版本控制"><a href="#通过请求参数进行版本控制" class="headerlink" title="通过请求参数进行版本控制"></a>通过请求参数进行版本控制</h3><p>版本控制的第二种方法是使用请求参数来区分版本。请求示例如下所示：</p><ul><li><code>http://localhost:8080/student/param?version=1</code></li><li><code>http://localhost:8080/student/param?version=2</code></li></ul><p>实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentParmController</span> &#123;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/param&quot;, params = &quot;version=1&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> StudentV1 <span class="title function_">studentV1</span><span class="params">()</span> &#123;       </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV1</span>(<span class="string">&quot;javadaily&quot;</span>);       </span><br><span class="line">&#125;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/param&quot;, params = &quot;version=2&quot;)</span>       </span><br><span class="line"><span class="keyword">public</span> StudentV2 <span class="title function_">studentV2</span><span class="params">()</span> &#123;          </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV2</span>(<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;javadaily&quot;</span>, <span class="string">&quot;JAVA日知录&quot;</span>));    </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>请求：<code>http://localhost:8080/student/param?version=1</code><br>响应：{“name”:”javadaily”}</p><p>请求：<code>http://localhost:8080/student/param?version=2</code><br>响应：{“name”:{“firstName”:”javadaily”,”lastName”:”JAVA日知录”}}</p><h3 id="通过自定义Header进行版本控制"><a href="#通过自定义Header进行版本控制" class="headerlink" title="通过自定义Header进行版本控制"></a>通过自定义Header进行版本控制</h3><p>版本控制的第三种方法是使用请求头来区分版本，请求示例如下：</p><ul><li><code>http://localhost:8080/student/header</code><ul><li>headers&#x3D;[X-API-VERSION&#x3D;1]</li></ul></li><li><code>http://localhost:8080/student/header</code><ul><li>headers&#x3D;[X-API-VERSION&#x3D;2]</li></ul></li></ul><p>实现方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHeaderController</span> &#123;          </span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/header&quot;,headers = &quot;X-API-VERSION=1&quot;)</span>       </span><br><span class="line"><span class="keyword">public</span> StudentV1 <span class="title function_">studentV1</span><span class="params">()</span> &#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV1</span>(<span class="string">&quot;javadaily&quot;</span>);      </span><br><span class="line">&#125; </span><br><span class="line">        </span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/header&quot;,headers = &quot;X-API-VERSION=2&quot;)</span>       </span><br><span class="line"><span class="keyword">public</span> StudentV2 <span class="title function_">studentV2</span><span class="params">()</span> &#123;         </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV2</span>(<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;javadaily&quot;</span>, <span class="string">&quot;JAVA日知录&quot;</span>));  </span><br><span class="line">&#125; </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>下图展示了我们如何使用Postman执行带有请求头的Get请求方法。</p><p>请求：<code>http://localhost:8080/student/header</code><br>header：<code>X-API-VERSION = 1</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jqm35NaykhC1aTJn9JvXSrVp9EAUPqZFvz4vymuNoicVQxmlNlcUnTGUiaIQYomw129icfeWz9JTJhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>请求：<code>http://localhost:8080/student/header</code><br>header：<code>X-API-VERSION = 2</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jqm35NaykhC1aTJn9JvXSrSGm9CYoZ0Om5aZhSzk9xwQ4ArSNmiaZNcz4nddcBFsY9sux9RLfonFw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="通过媒体类型进行版本控制"><a href="#通过媒体类型进行版本控制" class="headerlink" title="通过媒体类型进行版本控制"></a>通过媒体类型进行版本控制</h3><p>最后一种版本控制方法是在请求中使用Accept Header，请求示例如下：</p><ul><li><code>http://localhost:8080/student/produce</code><ul><li><code>headers=[Accept=application/api-v1+json]</code></li></ul></li><li><code>http://localhost:8080/student/produce</code><ul><li><code>headers=[Accept=application/api-v2+json]</code></li></ul></li></ul><p>实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentProduceController</span> &#123;          </span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/produce&quot;,produces = &quot;application/api-v1+json&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> StudentV1 <span class="title function_">studentV1</span><span class="params">()</span> &#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV1</span>(<span class="string">&quot;javadaily&quot;</span>);       </span><br><span class="line">&#125;          </span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/produce&quot;,produces = &quot;application/api-v2+json&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> StudentV2 <span class="title function_">studentV2</span><span class="params">()</span> &#123;          </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV2</span>(<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;javadaily&quot;</span>, <span class="string">&quot;JAVA日知录&quot;</span>));     </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>下图展示了我们如何使用Postman执行带有请求Accept的Get方法。</p><p>请求：<code>http://localhost:8080/student/produce</code><br>header：<code>Accept = application/api-v1+json</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jqm35NaykhC1aTJn9JvXSrib4ATp9xWVKnmcEb1C2bgSnnW4C0YZNu0cm12RJbwOf09j46u2Aia8Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>请求：<code>http://localhost:8080/student/produce</code><br>header：<code>Accept = application/api-v2+json</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jqm35NaykhC1aTJn9JvXSrgsjbiag7JvmpDEAqDibzq5Xt06LxYlN5r8E0eY8Gv2rFbvg4X66oLicog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="影响版本选择的因素"><a href="#影响版本选择的因素" class="headerlink" title="影响版本选择的因素"></a>影响版本选择的因素</h2><p>以下因素影响版本控制的选择</p><ul><li>URI 污染 - URL版本和请求参数版本控制会污染URI空间。</li><li>滥用请求头 - Accept 请求头并不是为版本控制而设计的。</li><li>缓存 - 如果你使用基于头的版本控制，我们不能仅仅基于URL缓存，你需要考虑特定的请求头。</li><li>是否能在浏览器直接执行 ? - 如果您有非技术消费者，那么基于URL的版本将更容易使用，因为它们可以直接在浏览器上执行。</li><li>API文档 - 如何让文档生成理解两个不同的url是同一服务的版本？</li></ul><blockquote><p>事实上，并没有完美的版本控制解决方案，你需要根据项目实际情况进行选择。</p></blockquote><p>下面列表展示了主要API提供商使用的不同版本控制方法：</p><ul><li>媒体类型的版本控制<ul><li>Github</li></ul></li><li>自定义Header<ul><li>Microsoft</li></ul></li><li>URI路径<ul><li>Twitter，百度，知乎</li></ul></li><li>请求参数控制<ul><li>Amazon</li></ul></li></ul><p>好了，今天的文章就到这里了，希望能对你有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在实际项目开发中我们经常需要对接口进行版本管理。那今天我们就来聊聊为什么需要版本控制，以及如何对REST API进行版本控制。我们将讨论4种版本控制的方法，并比较不同的方法。&lt;/p&gt;
&lt;p&gt;通过此文您将学到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么我们需要对RESTful API </summary>
      
    
    
    
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot：参数校验</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</id>
    <published>2024-09-02T07:13:41.928Z</published>
    <updated>2024-09-02T08:40:22.474Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&mid=2247512866&idx=1&sn=f9d1549dc312c48a9fde14fb1fdb5d07&chksm=9ad3a963ada420756be6f848faef228d08b2ea49d87d2c083eabd6a2cf184cefa2ed8fa05964&cur_album_id=1517924978380308484&scene=189#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247512866&amp;idx=1&amp;sn=f9d1549dc312c48a9fde14fb1fdb5d07&amp;chksm=9ad3a963ada420756be6f848faef228d08b2ea49d87d2c083eabd6a2cf184cefa2ed8fa05964&amp;cur_album_id=1517924978380308484&amp;scene=189#wechat_redirect</a></p><p>首先我们来看看什么是Validator参数校验器，为什么需要参数校验？</p><h2 id="为什么需要参数校验"><a href="#为什么需要参数校验" class="headerlink" title="为什么需要参数校验"></a>为什么需要参数校验</h2><p>在日常的接口开发中，为了防止非法参数对业务造成影响，经常需要对接口的参数做校验，例如登录的时候需要校验用户名密码是否为空，创建用户的时候需要校验邮件、手机号码格式是否准确。靠代码对接口参数一个个校验的话就太繁琐了，代码可读性极差。</p><p>Validator框架就是为了解决开发人员在开发的时候少写代码，提升开发效率；<br>Validator专门用来进行接口参数校验，例如常见的必填校验，email格式校验，用户名必须位于6到12之间 等等…</p><blockquote><p>Validator校验框架遵循了JSR-303验证规范（参数校验规范）, JSR是<code>Java Specification Requests</code>的缩写。<br>接下来我们看看在SpringbBoot中如何集成参数校验框架。</p></blockquote><h2 id="SpringBoot中集成参数校验"><a href="#SpringBoot中集成参数校验" class="headerlink" title="SpringBoot中集成参数校验"></a>SpringBoot中集成参数校验</h2><h3 id="第一步，引入依赖"><a href="#第一步，引入依赖" class="headerlink" title="第一步，引入依赖"></a>第一步，引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：从<code>springboot-2.3</code>开始，校验包被独立成了一个<code>starter</code>组件，所以需要引入validation和web，而<code>springboot-2.3</code>之前的版本只需要引入 web 依赖就可以了。</p></blockquote><h3 id="第二步，定义要参数校验的实体类"><a href="#第二步，定义要参数校验的实体类" class="headerlink" title="第二步，定义要参数校验的实体类"></a>第二步，定义要参数校验的实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidVO</span> &#123;       </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String id;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@Length(min = 6,max = 12,message = &quot;appId长度必须位于6到12之间&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> String appId;         </span><br><span class="line"></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;名字为必填项&quot;)</span>      </span><br><span class="line"><span class="keyword">private</span> String name;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@Email(message = &quot;请填写正确的邮箱地址&quot;)</span>  </span><br><span class="line"><span class="keyword">private</span> String email;          </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String sex;        </span><br><span class="line"></span><br><span class="line"><span class="meta">@NotEmpty(message = &quot;级别不能为空&quot;)</span>     </span><br><span class="line"><span class="keyword">private</span> String level;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在实际开发中对于需要校验的字段都需要设置对应的业务提示，即message属性。<br>常见的约束注解如下：</p><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>可以为null,如果不为null的话必须为false</td></tr><tr><td>@AssertTrue</td><td>可以为null,如果不为null的话必须为true</td></tr><tr><td>@DecimalMax</td><td>设置不能超过最大值</td></tr><tr><td>@DecimalMin</td><td>设置不能超过最小值</td></tr><tr><td>@Digits</td><td>设置必须是数字且数字整数的位数和小数的位数必须在指定范围内</td></tr><tr><td>@Future</td><td>日期必须在当前日期的未来</td></tr><tr><td>@Past</td><td>日期必须在当前日期的过去</td></tr><tr><td>@Max</td><td>最大不得超过此最大值</td></tr><tr><td>@Min</td><td>最大不得小于此最小值</td></tr><tr><td>@NotNull</td><td>不能为null，可以是空</td></tr><tr><td>@Null</td><td>必须为null</td></tr><tr><td>@Pattern</td><td>必须满足指定的正则表达式</td></tr><tr><td>@Size</td><td>集合、数组、map等的size()值必须在指定范围内</td></tr><tr><td>@Email</td><td>必须是email格式</td></tr><tr><td>@Length</td><td>长度必须在指定范围内</td></tr><tr><td>@NotBlank</td><td>字符串不能为null,字符串trim()后也不能等于“”</td></tr><tr><td>@NotEmpty</td><td>不能为null，集合、数组、map等size()不能为0；字符串trim()后可以等于“”</td></tr><tr><td>@Range</td><td>值必须在指定范围内</td></tr><tr><td>@URL</td><td>必须是一个URL</td></tr></tbody></table><p>注：此表格只是简单的对注解功能的说明，并没有对每一个注解的属性进行说明；可详见源码。</p><p>在Controller层对需要参数校验的方法加上@Validated注解</p><ol><li><p>参数校验一般分为两类：在Controller使用模型接收数据时， @Validated注解直接放在该模型参数前即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;test1&quot;)</span>   <span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> ValidEntity validEntity)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test1 valid success&quot;</span>;  </span><br><span class="line">&#125;      </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;test3&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test3</span><span class="params">(<span class="meta">@Validated</span> ValidEntity validEntity)</span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test3 valid success&quot;</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当我们是直接在Controller层中的参数前，使用约束注解时，@Validated要直接放在类上  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;test2&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(<span class="meta">@Email</span> String email)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test2 valid success&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此时需要在主类上增加@Validated注解  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span>   </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo/valid&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidController</span> &#123;  </span><br><span class="line">...   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在参数校验时我们既可以使用@Validated也可以使用@Valid注解，两者功能大部分类似；<br>主要区别在于：<br>@Valid属于javax下的，而@Validated属于spring下；<br>@Valid支持嵌套校验、而@Validated不支持，@Validated支持分组，而@Valid不支持。<br>@Validated： 用在类、方法和方法参数上，但不能用于成员属性。<br>@Valid：可以用在方法、构造函数、方法参数和成员属性上<br>@Validated和@Valid支持混合使用</p></blockquote><h3 id="第三步，定义校验类进行测试"><a href="#第三步，定义校验类进行测试" class="headerlink" title="第三步，定义校验类进行测试"></a>第三步，定义校验类进行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>   </span><br><span class="line"><span class="meta">@Validated</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidController</span> &#123;         </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(&quot;RequestBody校验&quot;)</span>     </span><br><span class="line"><span class="meta">@PostMapping(&quot;/valid/test1&quot;)</span>          </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> ValidVO validVO)</span>&#123;           </span><br><span class="line">log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);           </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test1 valid success&quot;</span>;       </span><br><span class="line">&#125;    </span><br><span class="line">     </span><br><span class="line"><span class="meta">@ApiOperation(&quot;Form校验&quot;)</span>       </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/test2&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(<span class="meta">@Validated</span> ValidVO validVO)</span>&#123;  </span><br><span class="line">log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);          </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test2 valid success&quot;</span>;       </span><br><span class="line">&#125;         </span><br><span class="line">  </span><br><span class="line"><span class="meta">@ApiOperation(&quot;单参数校验&quot;)</span>       </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/test3&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test3</span><span class="params">(<span class="meta">@Email</span> String email)</span>&#123;   </span><br><span class="line">log.info(<span class="string">&quot;email is &#123;&#125;&quot;</span>, email);          </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;email valid success&quot;</span>;       </span><br><span class="line">&#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里我们先定义三个方法test1，test2，test3，test1使用了<code>@RequestBody</code>注解，用于接受前端发送的json数据，test2模拟表单提交，test3模拟单参数提交。注意，当使用单参数校验时需要在Controller上加上@Validated注解，否则不生效。</p><h3 id="第四步，体验效果"><a href="#第四步，体验效果" class="headerlink" title="第四步，体验效果"></a>第四步，体验效果</h3><ol><li>调用test1方法，提示的是<code>org.springframework.web.bind.MethodArgumentNotValidException</code>异常<br><code>POST http://localhost:8080/valid/test1   Content-Type: application/json      &#123;     &quot;id&quot;: 1,     &quot;level&quot;: &quot;12&quot;,     &quot;email&quot;: &quot;47693899&quot;,     &quot;appId&quot;: &quot;ab1c&quot;   &#125;  </code></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Validation failed for argument [0] in public java.lang.String com.jianzh5.blog.valid.ValidController.test1(com.jianzh5.blog.valid.ValidVO) with 3 errors: [Field error in object &#x27;validVO&#x27; on field &#x27;email&#x27;: rejected value [47693899]; codes [Email.validVO.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [validVO.email,email]; arguments []; default message [email],[Ljavax.validation.constraints.Pattern$Flag;@26139123,.*]; default message [不是一个合法的电子邮件地址]]...&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628239624332</span>  </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><ol start="2"><li>调用test2方法，提示的是<code>org.springframework.validation.BindException</code>异常<br><code>POST http://localhost:8080/valid/test2   Content-Type: application/x-www-form-urlencoded      id=1&amp;level=12&amp;email=476938977&amp;appId=ab1c   </code></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.validation.BeanPropertyBindingResult: 3 errors\nField error in object &#x27;validVO&#x27; on field &#x27;name&#x27;: rejected value [null]; codes [NotBlank.validVO.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [validVO.name,name]; arguments []; default message [name]]; default message [名字为必填项]...&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"> <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"> <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628239301951</span>   </span><br><span class="line"> <span class="punctuation">&#125;</span>  ```</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 调用test3方法，提示的是`javax.validation.ConstraintViolationException`异常</span><br><span class="line">`POST http<span class="punctuation">:</span><span class="comment">//localhost:8080/valid/test3   Content-Type: application/x-www-form-urlencoded      email=476938977   `</span></span><br><span class="line"></span><br><span class="line">```json </span><br><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>   </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test3.email: 不是一个合法的电子邮件地址&quot;</span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628239281022</span>  </span><br><span class="line"> <span class="punctuation">&#125;</span>  </span><br></pre></td></tr></table></figure><p>通过加入<code>Validator</code>校验框架可以帮助我们自动实现参数的校验。</p><h2 id="参数异常加入全局异常处理器"><a href="#参数异常加入全局异常处理器" class="headerlink" title="参数异常加入全局异常处理器"></a>参数异常加入全局异常处理器</h2><p>虽然我们之前定义了全局异常拦截器，也看到了拦截器确实生效了，但是<code>Validator</code>校验框架返回的错误提示太臃肿了，不便于阅读，为了方便前端提示，我们需要将其简化一下。</p><p>直接修改之前定义的<code>RestExceptionHandler</code>，单独拦截参数校验的三个异常：<code>javax.validation.ConstraintViolationException</code>，<code>org.springframework.validation.BindException</code>，<code>org.springframework.web.bind.MethodArgumentNotValidException</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(value = &#123;BindException.class, </span></span><br><span class="line"><span class="meta">ValidationException.class, </span></span><br><span class="line"><span class="meta">MethodArgumentNotValidException.class&#125;)</span>   </span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;ResultData&lt;String&gt;&gt; <span class="title function_">handleValidatedException</span><span class="params">(Exception e)</span> </span><br><span class="line">&#123;  </span><br><span class="line">ResultData&lt;String&gt; resp = <span class="literal">null</span>;       </span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;       </span><br><span class="line"><span class="comment">// BeanValidation exception   </span></span><br><span class="line"><span class="type">MethodArgumentNotValidException</span> <span class="variable">ex</span> <span class="operator">=</span> (MethodArgumentNotValidException) e;</span><br><span class="line"></span><br><span class="line">resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),                              ex.getBindingResult().getAllErrors().stream()                              .map(ObjectError::getDefaultMessage)                              .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))                             );   </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConstraintViolationException) &#123;   </span><br><span class="line">  <span class="comment">// BeanValidation GET simple param       </span></span><br><span class="line">  <span class="type">ConstraintViolationException</span> <span class="variable">ex</span> <span class="operator">=</span> (ConstraintViolationException) e;       </span><br><span class="line">  resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),                              ex.getConstraintViolations().stream()                              .map(ConstraintViolation::getMessage)                              .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))                             );     </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) &#123;       </span><br><span class="line">  <span class="comment">// BeanValidation GET object param   </span></span><br><span class="line">  <span class="type">BindException</span> <span class="variable">ex</span> <span class="operator">=</span> (BindException) e;   </span><br><span class="line">  resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),                              ex.getAllErrors().stream()                              .map(ObjectError::getDefaultMessage)                              .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))                             );    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(resp,HttpStatus.BAD_REQUEST);   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>默认情况下在对参数进行校验时Spring Validation会校验完所有字段然后才抛出异常，可以通过配置开启 <code>Fali Fast</code>模式，一旦校验失败就立即返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidatedConfig</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Validator <span class="title function_">validator</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">ValidatorFactory</span> <span class="variable">validatorFactory</span> <span class="operator">=</span> Validation.byProvider(HibernateValidator.class)  </span><br><span class="line">                .configure()  </span><br><span class="line">                <span class="comment">// 快速失败模式  </span></span><br><span class="line">                .failFast(<span class="literal">true</span>)  </span><br><span class="line">                .buildValidatorFactory();  </span><br><span class="line">        <span class="keyword">return</span> validatorFactory.getValidator();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="体验效果"><a href="#体验效果" class="headerlink" title="体验效果"></a>体验效果</h3><p><code>POST http://localhost:8080/valid/test1   Content-Type: application/json      &#123;     &quot;id&quot;: 1,     &quot;level&quot;: &quot;12&quot;,     &quot;email&quot;: &quot;47693899&quot;,     &quot;appId&quot;: &quot;ab1c&quot;   &#125;   </code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;名字为必填项; 不是一个合法的电子邮件地址; appId长度必须位于6到12之间&quot;</span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628435116680</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>是不是感觉清爽多了？</p><h2 id="自定义参数校验"><a href="#自定义参数校验" class="headerlink" title="自定义参数校验"></a>自定义参数校验</h2><p>虽然Spring Validation 提供的注解基本上够用，但是面对复杂的定义，我们还是需要自己定义相关注解来实现自动校验。</p><p>比如上面实体类中的sex性别属性，只允许前端传递传 M，F 这2个枚举值，如何实现呢？</p><h3 id="第一步，创建自定义注解"><a href="#第一步，创建自定义注解" class="headerlink" title="第一步，创建自定义注解"></a>第一步，创建自定义注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span>   <span class="meta">@Retention(RUNTIME)</span> </span><br><span class="line"><span class="meta">@Repeatable(EnumString.List.class)</span>   </span><br><span class="line"><span class="meta">@Documented</span>  </span><br><span class="line"><span class="meta">@Constraint(validatedBy = EnumStringValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnumString &#123;   </span><br><span class="line"></span><br><span class="line">String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;value not in enum values.&quot;</span>;         </span><br><span class="line">Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;        </span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] value();         </span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span>       </span><br><span class="line"><span class="meta">@Documented</span>       </span><br><span class="line"><span class="meta">@interface</span> List &#123;              </span><br><span class="line">EnumString[] value();       </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="第二步，自定义校验逻辑"><a href="#第二步，自定义校验逻辑" class="headerlink" title="第二步，自定义校验逻辑"></a>第二步，自定义校验逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumStringValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;EnumString, String&gt; &#123;       </span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; enumStringList;       </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Override</span>      </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(EnumString constraintAnnotation)</span> &#123;   </span><br><span class="line">enumStringList = Arrays.asList(constraintAnnotation.value());       </span><br><span class="line">&#125;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;   </span><br><span class="line"><span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;          </span><br><span class="line">&#125;          </span><br><span class="line"><span class="keyword">return</span> enumStringList.contains(value);   </span><br><span class="line">&#125;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="第三步，在字段上增加注解"><a href="#第三步，在字段上增加注解" class="headerlink" title="第三步，在字段上增加注解"></a>第三步，在字段上增加注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;性别&quot;)</span>  </span><br><span class="line"><span class="meta">@EnumString(value = &#123;&quot;F&quot;,&quot;M&quot;&#125;, message=&quot;性别只允许为F或M&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> String sex;   </span><br></pre></td></tr></table></figure><h3 id="第四步，体验效果-1"><a href="#第四步，体验效果-1" class="headerlink" title="第四步，体验效果"></a>第四步，体验效果</h3><p><code>POST http://localhost:8080/valid/test2   Content-Type: application/x-www-form-urlencoded      id=1&amp;name=javadaily&amp;level=12&amp;email=476938977@qq.com&amp;appId=ab1cdddd&amp;sex=N   </code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;性别只允许为F或M&quot;</span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628435243723</span>   </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p>一个VO对象在新增的时候某些字段为必填，在更新的时候又非必填。如上面的<code>ValidVO</code>中 id 和 appId 属性在新增操作时都是非必填，而在编辑操作时都为必填，name在新增操作时为必填，面对这种场景你会怎么处理呢？</p><p>在实际开发中我见到很多同学都是建立两个VO对象，<code>ValidCreateVO</code>，<code>ValidEditVO</code>来处理这种场景，这样确实也能实现效果，但是会造成类膨胀，而且极其容易被开发老鸟们嘲笑。</p><p>其实<code>Validator</code>校验框架已经考虑到了这种场景并且提供了解决方案，就是分组校验，只不过很多同学不知道而已。要使用分组校验，只需要三个步骤：</p><h3 id="第一步：定义分组接口"><a href="#第一步：定义分组接口" class="headerlink" title="第一步：定义分组接口"></a>第一步：定义分组接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidGroup</span> <span class="keyword">extends</span> <span class="title class_">Default</span> &#123;       </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Crud</span> <span class="keyword">extends</span> <span class="title class_">ValidGroup</span>&#123;         </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Create</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;&#125;           </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Update</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;&#125;             </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Query</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;&#125;             </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Delete</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;&#125;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这里我们定义一个分组接口ValidGroup让其继承<code>javax.validation.groups.Default</code>，再在分组接口中定义出多个不同的操作类型，Create，Update，Query，Delete。至于为什么需要继承Default我们稍后再说。</p><h3 id="第二步，在模型中给参数分配分组"><a href="#第二步，在模型中给参数分配分组" class="headerlink" title="第二步，在模型中给参数分配分组"></a>第二步，在模型中给参数分配分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="meta">@ApiModel(value = &quot;参数校验类&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidVO</span> &#123;       </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModelProperty(&quot;ID&quot;)</span>       </span><br><span class="line"><span class="meta">@Null(groups = ValidGroup.Crud.Create.class)</span>  </span><br><span class="line"><span class="meta">@NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> String id;         </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Null(groups = ValidGroup.Crud.Create.class)</span>     </span><br><span class="line"><span class="meta">@NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;)</span>    </span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;应用ID&quot;,example = &quot;cloud&quot;)</span>      </span><br><span class="line"><span class="keyword">private</span> String appId;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;名字&quot;)</span>      </span><br><span class="line"><span class="meta">@NotBlank(groups = ValidGroup.Crud.Create.class,message = &quot;名字为必填项&quot;)</span>      </span><br><span class="line"><span class="keyword">private</span> String name;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;邮箱&quot;)</span>    </span><br><span class="line"><span class="meta">@Email(message = &quot;请填写正取的邮箱地址&quot;)</span>       </span><br><span class="line"><span class="keyword">private</span> String email;        </span><br><span class="line">...      </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>给参数指定分组，对于未指定分组的则使用的是默认分组。</p><h3 id="第三步，给需要参数校验的方法指定分组"><a href="#第三步，给需要参数校验的方法指定分组" class="headerlink" title="第三步，给需要参数校验的方法指定分组"></a>第三步，给需要参数校验的方法指定分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="meta">@Api(&quot;参数校验&quot;)</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>   </span><br><span class="line"><span class="meta">@Validated</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidController</span> &#123;         </span><br><span class="line"><span class="meta">@ApiOperation(&quot;新增&quot;)</span>       </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/add&quot;)</span>       </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Create.class)</span> ValidVO validVO)</span></span><br><span class="line">&#123;          </span><br><span class="line">log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);           </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test3 valid success&quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(&quot;更新&quot;)</span> </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/update&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Update.class)</span> ValidVO validVO)</span></span><br><span class="line">&#123;           </span><br><span class="line">log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO); </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test4 valid success&quot;</span>;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这里我们通过<code>value</code>属性给<code>add()</code>和<code>update()</code>方法分别指定Create和Update分组。</p><h3 id="第四步，体验效果-2"><a href="#第四步，体验效果-2" class="headerlink" title="第四步，体验效果"></a>第四步，体验效果</h3><p><code>POST http://localhost:8080/valid/add   Content-Type: application/x-www-form-urlencoded      name=javadaily&amp;level=12&amp;email=476938977@qq.com&amp;sex=F   </code></p><p>在Create时我们没有传递id和appId参数，校验通过。</p><p>当我们使用同样的参数调用update方法时则提示参数校验错误。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ID不能为空; 应用ID不能为空&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628492514313</span>  </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>由于email属于默认分组，而我们的分组接口<code>ValidGroup</code>已经继承了<code>Default</code>分组，所以也是可以对email字段作参数校验的。如：</p><p><code>POST http://localhost:8080/valid/add   Content-Type: application/x-www-form-urlencoded      name=javadaily&amp;level=12&amp;email=476938977&amp;sex=F   </code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请填写正取的邮箱地址&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628492637305</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>当然如果你的ValidGroup没有继承Default分组，那在代码属性上就需要加上<code>@Validated(value = &#123;ValidGroup.Crud.Create.class, Default.class&#125;</code>才能让<code>email</code>字段的校验生效。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>参数校验在实际开发中使用频率非常高，但是很多同学还只是停留在简单的使用上，像分组校验，自定义参数校验这2个高阶技巧基本没怎么用过，经常出现譬如建立多个VO用于接受Create，Update场景的情况，很容易被老鸟被所鄙视嘲笑，希望大家好好掌握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247512866&amp;idx=1&amp;sn=f9d1549dc312c48a9fde14fb1fdb5d07&amp;chksm=9ad3a963ada4207</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot：统一返回格式</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot%EF%BC%9A%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-09-02T06:39:47.310Z</published>
    <updated>2024-09-02T07:16:21.033Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&mid=2247492641&idx=1&sn=23f42094f442f382581d4bcdd191e12a&chksm=9ad3fe60ada47776313cc10f4b5ed50cfebd9d21bd4bee54698c8e8d3ddf89d1c81e98665743&scene=21#wechat_redirect">http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247492641&amp;idx=1&amp;sn=23f42094f442f382581d4bcdd191e12a&amp;chksm=9ad3fe60ada47776313cc10f4b5ed50cfebd9d21bd4bee54698c8e8d3ddf89d1c81e98665743&amp;scene=21#wechat_redirect</a></p><p>基于SpringBoot前后端分离开发模式下，如何友好的返回统一的标准格式以及如何优雅的处理全局异常。<br>首先我们来看看为什么要返回统一的标准格式？</p><h2 id="为什么要对SpringBoot返回统一的标准格式"><a href="#为什么要对SpringBoot返回统一的标准格式" class="headerlink" title="为什么要对SpringBoot返回统一的标准格式"></a>为什么要对SpringBoot返回统一的标准格式</h2><p>在默认情况下，SpringBoot的返回格式常见的有三种：</p><p>第一种：返回 String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span>&#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello,javadaily&quot;</span>;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>此时调用接口获取到的返回值是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,javadaily   </span><br></pre></td></tr></table></figure><p>第二种：返回自定义对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/aniaml&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> Aniaml <span class="title function_">getAniaml</span><span class="params">()</span>&#123;     </span><br><span class="line"><span class="type">Aniaml</span> <span class="variable">aniaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Aniaml</span>(<span class="number">1</span>,<span class="string">&quot;pig&quot;</span>);     </span><br><span class="line"><span class="keyword">return</span> aniaml;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>此时调用接口获取到的返回值是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pig&quot;</span> <span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>第三种：接口异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/error&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">error</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>/<span class="number">0</span>;       </span><br><span class="line"><span class="keyword">return</span> i;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此时调用接口获取到的返回值是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-07-08T08:05:15.423+00:00&quot;</span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/wrong&quot;</span>   </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>基于以上种种情况，如果你和前端开发人员联调接口她们就会很懵逼，由于我们没有给他一个统一的格式，前端人员不知道如何处理返回值。</p><p>还有甚者，有的同学比如小张喜欢对结果进行封装，他使用了Result对象，小王也喜欢对结果进行包装，但是他却使用的是Response对象，当出现这种情况时我相信前端人员一定会抓狂的。</p><p>所以我们项目中是需要定义一个统一的标准返回格式的。</p><h2 id="定义返回标准格式"><a href="#定义返回标准格式" class="headerlink" title="定义返回标准格式"></a>定义返回标准格式</h2><p>一个标准的返回格式至少包含3部分：</p><ol><li>status 状态值：由后端统一定义各种返回结果的状态码</li><li>message 描述：本次接口调用的结果描述</li><li>data 数据：本次返回的数据。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;100&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;操作成功&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="string">&quot;hello,javadaily&quot;</span>   </span><br><span class="line"><span class="punctuation">&#125;</span>  </span><br></pre></td></tr></table></figure>当然也可以按需加入其他扩展值，比如接口调用时间</li><li>timestamp: 接口调用时间</li></ol><h3 id="定义返回对象"><a href="#定义返回对象" class="headerlink" title="定义返回对象"></a>定义返回对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultData</span>&lt;T&gt; &#123;     </span><br><span class="line"><span class="comment">/** 结果状态 ,具体状态码参见ResultData.java*/</span>     </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> status;     </span><br><span class="line"><span class="keyword">private</span> String message;     </span><br><span class="line"><span class="keyword">private</span> T data;     </span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> timestamp ;           </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ResultData</span> <span class="params">()</span>&#123;       </span><br><span class="line"><span class="built_in">this</span>.timestamp = System.currentTimeMillis();     </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultData&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">ResultData&lt;T&gt; resultData = <span class="keyword">new</span> <span class="title class_">ResultData</span>&lt;&gt;();</span><br><span class="line">resultData.setStatus(ReturnCode.RC100.getCode());</span><br><span class="line">resultData.setMessage(ReturnCode.RC100.getMessage());</span><br><span class="line">resultData.setData(data);</span><br><span class="line"><span class="keyword">return</span> resultData;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultData&lt;T&gt; <span class="title function_">fail</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">ResultData&lt;T&gt; resultData = <span class="keyword">new</span> <span class="title class_">ResultData</span>&lt;&gt;();</span><br><span class="line">resultData.setStatus(code);</span><br><span class="line">resultData.setMessage(message);</span><br><span class="line"><span class="keyword">return</span> resultData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="定义状态码"><a href="#定义状态码" class="headerlink" title="定义状态码"></a>定义状态码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ReturnCode</span> &#123;         </span><br><span class="line">RC100(<span class="number">100</span>,<span class="string">&quot;操作成功&quot;</span>),         </span><br><span class="line">RC999(<span class="number">999</span>,<span class="string">&quot;操作失败&quot;</span>),        </span><br><span class="line">RC200(<span class="number">200</span>,<span class="string">&quot;服务开启限流保护,请稍后再试!&quot;</span>),       </span><br><span class="line">RC201(<span class="number">201</span>,<span class="string">&quot;服务开启降级保护,请稍后再试!&quot;</span>),          </span><br><span class="line">RC202(<span class="number">202</span>,<span class="string">&quot;热点参数限流,请稍后再试!&quot;</span>),         </span><br><span class="line">RC203(<span class="number">203</span>,<span class="string">&quot;系统规则不满足要求,请稍后再试!&quot;</span>),     </span><br><span class="line">RC204(<span class="number">204</span>,<span class="string">&quot;授权规则不通过,请稍后再试!&quot;</span>),    </span><br><span class="line">RC403(<span class="number">403</span>,<span class="string">&quot;无访问权限,请联系管理员授予权限&quot;</span>),      </span><br><span class="line">RC401(<span class="number">401</span>,<span class="string">&quot;匿名用户访问无权限资源时的异常&quot;</span>),   </span><br><span class="line">RC500(<span class="number">500</span>,<span class="string">&quot;系统异常，请稍后重试&quot;</span>),          </span><br><span class="line">INVALID_TOKEN(<span class="number">2001</span>,<span class="string">&quot;访问令牌不合法&quot;</span>),       </span><br><span class="line">ACCESS_DENIED(<span class="number">2003</span>,<span class="string">&quot;没有权限访问该资源&quot;</span>),   </span><br><span class="line">CLIENT_AUTHENTICATION_FAILED(<span class="number">1001</span>,<span class="string">&quot;客户端认证失败&quot;</span>),</span><br><span class="line">USERNAME_OR_PASSWORD_ERROR(<span class="number">1002</span>,<span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line">UNSUPPORTED_GRANT_TYPE(<span class="number">1003</span>, <span class="string">&quot;不支持的认证模式&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String message;          </span><br><span class="line"></span><br><span class="line">ReturnCode(<span class="type">int</span> code, String message)&#123;           </span><br><span class="line"><span class="built_in">this</span>.code = code;           </span><br><span class="line"><span class="built_in">this</span>.message = message;       </span><br><span class="line">&#125;             </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;           </span><br><span class="line"><span class="keyword">return</span> code;       </span><br><span class="line">&#125;         </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;   </span><br><span class="line"><span class="keyword">return</span> message;     </span><br><span class="line">&#125;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="统一返回格式"><a href="#统一返回格式" class="headerlink" title="统一返回格式"></a>统一返回格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> ResultData&lt;String&gt; <span class="title function_">getStr</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ResultData.success(<span class="string">&quot;hello,javadaily&quot;</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此时调用接口获取到的返回值是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello,javadaily&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625736481648</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;httpStatus&quot;</span><span class="punctuation">:</span> <span class="number">0</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>这样确实已经实现了我们想要的结果，我在很多项目中看到的都是这种写法，在Controller层通过<code>ResultData.success()</code>对返回结果进行包装后返回给前端。</p><p>看到这里我们不妨停下来想想，这样做有什么弊端呢？</p><p>最大的弊端就是我们后面每写一个接口都需要调用<code>ResultData.success()</code>这行代码对结果进行包装，重复劳动，浪费体力；  </p><p>而且还很容易被其他老鸟给嘲笑。</p><p>所以呢我们需要对代码进行优化，目标就是不要每个接口都手工制定<code>ResultData</code>返回值。</p><h3 id="高级实现方式"><a href="#高级实现方式" class="headerlink" title="高级实现方式"></a>高级实现方式</h3><p>要优化这段代码很简单，我们只需要借助SpringBoot提供的<code>ResponseBodyAdvice</code>即可。</p><blockquote><p>ResponseBodyAdvice的作用：拦截Controller方法的返回值，统一处理返回值&#x2F;响应体，一般用来统一返回格式，加解密，签名等等。</p></blockquote><p>先来看下<code>ResponseBodyAdvice</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResponseBodyAdvice</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="comment">/**     * 是否支持advice功能     * true 支持，false 不支持     */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter var1, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; var2)</span>;</span><br><span class="line"><span class="comment">/**     * 对返回的数据进行处理     */</span></span><br><span class="line"><span class="meta">@Nullable</span> T <span class="title function_">beforeBodyWrite</span><span class="params">(<span class="meta">@Nullable</span> T var1, MethodParameter var2, MediaType var3, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; var4, ServerHttpRequest var5, ServerHttpResponse var6)</span>;   </span><br><span class="line">&#125;   `</span><br></pre></td></tr></table></figure><p>我们只需要编写一个具体实现类即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span>   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;       <span class="meta">@Autowired</span>       </span><br><span class="line"><span class="keyword">private</span> ObjectMapper objectMapper;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> &#123;          </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="meta">@SneakyThrows</span>       </span><br><span class="line"><span class="meta">@Override</span>       <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> </span><br><span class="line">&#123;           </span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)&#123;               <span class="keyword">return</span> objectMapper.writeValueAsString(ResultData.success(o));           &#125;                   </span><br><span class="line"><span class="keyword">return</span> ResultData.success(o);       </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>需要注意两个地方：</p><ul><li><code>@RestControllerAdvice</code>是<code>@RestController</code>注解的增强，可以实现三个方面的功能：<ol><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ol></li><li>String类型判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line"><span class="keyword">return</span> objectMapper.writeValueAsString(ResultData.success(o));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这段代码一定要加，如果Controller直接返回String的话，SpringBoot是直接返回，故我们需要手动转换成json。<br>经过上面的处理我们就再也不需要通过<code>ResultData.success()</code>来进行转换了，直接返回原始数据格式，SpringBoot自动帮我们实现包装类的封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello,javadaily&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们调用接口返回的数据结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello,javadaily&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625736481648</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;httpStatus&quot;</span><span class="punctuation">:</span> <span class="number">0</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> ```</span><br><span class="line">是不是感觉很完美，别急，还有个问题在等着你呢。</span><br><span class="line"></span><br><span class="line">### 接口异常问题</span><br><span class="line"></span><br><span class="line">此时有个问题，由于我们没对Controller的异常进行处理，当我们调用的方法一旦出现异常，就会出现问题，比如下面这个接口</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@GetMapping(<span class="string">&quot;/wrong&quot;</span>)  </span><br><span class="line">public int error()<span class="punctuation">&#123;</span>       </span><br><span class="line">int i = <span class="number">9</span>/<span class="number">0</span>;       </span><br><span class="line">return i;   </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回的结果为：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gOa4vJmA3Iz2aqv8C4e699F4vXppP4LAnKTsuvSGEfsU3NulReBHdmsX4Vic8n1EeopTPL8OLwwJw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这显然不是我们想要的结果，接口都报错了还返回操作成功的响应码，前端看了会打人的。<br>别急，接下来我们进入第二个议题，如何优雅的处理全局异常。</p><h2 id="SpringBoot为什么需要全局异常处理器"><a href="#SpringBoot为什么需要全局异常处理器" class="headerlink" title="SpringBoot为什么需要全局异常处理器"></a>SpringBoot为什么需要全局异常处理器</h2><ol><li>不用手写try…catch，由全局异常处理器统一捕获</li></ol><p>使用全局异常处理器最大的便利就是程序员在写代码时不再需要手写<code>try...catch</code>了，前面我们讲过，默认情况下SpringBoot出现异常时返回的结果是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-07-08T08:05:15.423+00:00&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/wrong&quot;</span>   </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>这种数据格式返回给前端，前端是看不懂的，所以这时候我们一般通过<code>try...catch</code>来处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/wrong&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">error</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="type">int</span> i;       </span><br><span class="line"><span class="keyword">try</span>&#123;          </span><br><span class="line">i = <span class="number">9</span>/<span class="number">0</span>;       </span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;         </span><br><span class="line">log.error(<span class="string">&quot;error:&#123;&#125;&quot;</span>, e);        </span><br><span class="line">i = <span class="number">0</span>;      </span><br><span class="line">&#125;       </span><br><span class="line"><span class="keyword">return</span> i;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们追求的目标肯定是不需要再手动写<code>try...catch</code>了，而是希望由全局异常处理器处理。</p><ol start="2"><li><p>对于自定义异常，只能通过全局异常处理器来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;error1&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empty</span><span class="params">()</span>&#123;    </span><br><span class="line"><span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;自定义异常&quot;</span>);   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p>当我们引入Validator参数校验器的时候，参数校验不通过会抛出异常，此时是无法用<code>try...catch</code>捕获的，只能使用全局异常处理器。</p></li></ol><h3 id="如何实现全局异常处理器"><a href="#如何实现全局异常处理器" class="headerlink" title="如何实现全局异常处理器"></a>如何实现全局异常处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>   </span><br><span class="line"><span class="meta">@RestControllerAdvice</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestExceptionHandler</span> &#123;       </span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span>       </span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span>       </span><br><span class="line"><span class="keyword">public</span> ResultData&lt;String&gt; <span class="title function_">exception</span><span class="params">(Exception e)</span> &#123;           </span><br><span class="line">log.error(<span class="string">&quot;全局异常信息 ex=&#123;&#125;&quot;</span>, e.getMessage(), e);          </span><br><span class="line"><span class="keyword">return</span> ResultData.fail(ReturnCode.RC500.getCode(), e.getMessage());    </span><br><span class="line">&#125;      </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>有三个细节需要说明一下：</p><ol><li><code>@RestControllerAdvice</code>，RestController的增强类，可用于实现全局异常处理器</li><li><code>@ExceptionHandler</code>,统一处理某一类异常，从而减少代码重复率和复杂度，比如要获取自定义异常可以<code>@ExceptionHandler(BusinessException.class)</code></li><li><code>@ResponseStatus</code>指定客户端收到的http状态码</li></ol><h3 id="体验效果"><a href="#体验效果" class="headerlink" title="体验效果"></a>体验效果</h3><p>这时候我们调用如下接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;error1&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empty</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;自定义异常&quot;</span>);   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>返回的结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义异常&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625795902556</span>  </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>基本满足我们的需求了。</p><p>但是当我们同时启用统一标准格式封装功能<code>ResponseAdvice</code>和<code>RestExceptionHandler</code>全局异常处理器时又出现了新的问题：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;操作成功&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>       </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>       </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义异常&quot;</span><span class="punctuation">,</span>       </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>       </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625796167986</span>     </span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625796168008</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>此时返回的结果是这样，统一格式增强功能会给返回的异常结果再次封装，所以接下来我们需要解决这个问题。</p><h3 id="全局异常接入返回的标准格式"><a href="#全局异常接入返回的标准格式" class="headerlink" title="全局异常接入返回的标准格式"></a>全局异常接入返回的标准格式</h3><p>要让全局异常接入标准格式很简单，因为全局异常处理器已经帮我们封装好了标准格式，我们只需要直接返回给客户端即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span>   </span><br><span class="line"><span class="meta">@Override</span>   </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> </span><br><span class="line">&#123;     </span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)&#123;       </span><br><span class="line"><span class="keyword">return</span> objectMapper.writeValueAsString(ResultData.success(o));     </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> ResultData)&#123;       </span><br><span class="line"><span class="keyword">return</span> o; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> ResultData.success(o); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> ResultData)&#123;     </span><br><span class="line"><span class="keyword">return</span> o;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>如果返回的结果是ResultData对象，直接返回即可。</p><p>这时候我们再调用上面的错误方法，返回的结果就符合我们的要求了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义异常&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625796580778</span>  </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>希望通过这篇文章你能掌握如何在你项目中友好实现统一标准格式到返回并且可以优雅的处理全局异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247492641&amp;idx=1&amp;sn=23f42094f442f382581d4bcdd191e12a&amp;chksm=9ad3fe60ada47776</summary>
      
    
    
    
    
    <category term="Java" scheme="https://andy-whb-cn.github.io/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向接口：幂等性</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2024-09-02T02:59:25.925Z</published>
    <updated>2024-09-02T10:49:12.127Z</updated>
    
    <content type="html"><![CDATA[<p>原文（<a href="https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg%EF%BC%89">https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg）</a></p><h1 id="一、什么是幂等性"><a href="#一、什么是幂等性" class="headerlink" title="一、什么是幂等性"></a>一、什么是幂等性</h1><p>幂等是一个数学与计算机学概念，在数学中某一元运算为幂等时，其作用在任一元素两次后会和其作用一次的结果相同。</p><p>在计算机中编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数或幂等方法是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p><h1 id="二、什么是接口幂等性"><a href="#二、什么是接口幂等性" class="headerlink" title="二、什么是接口幂等性"></a>二、什么是接口幂等性</h1><p>在HTTP&#x2F;1.1中，对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。</p><p>这里的副作用是不会对结果产生破坏或者产生不可预料的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><h1 id="三、为什么需要实现幂等性"><a href="#三、为什么需要实现幂等性" class="headerlink" title="三、为什么需要实现幂等性"></a>三、为什么需要实现幂等性</h1><p>在接口调用时一般情况下都能正常返回信息不会重复提交，不过在遇见以下情况时可以就会出现问题，如：</p><ul><li><strong>前端重复提交表单：</strong> 在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。</li><li><strong>用户恶意进行刷单：</strong> 例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。</li><li><strong>接口超时重复提交：</strong> 很多时候 HTTP 客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。</li><li><strong>消息进行重复消费：</strong> 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。<br>使用幂等性最大的优势在于使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。</li></ul><h1 id="四、引入幂等性后对系统的影响"><a href="#四、引入幂等性后对系统的影响" class="headerlink" title="四、引入幂等性后对系统的影响"></a>四、引入幂等性后对系统的影响</h1><p>幂等性是为了简化客户端逻辑处理，能放置重复提交等操作，但却增加了服务端的逻辑复杂性和成本，其主要是：</p><ul><li>把并行执行的功能改为串行执行，降低了执行效率。</li><li>增加了额外控制幂等的业务逻辑，复杂化了业务功能；<br>所以在使用时候需要考虑是否引入幂等性的必要性，根据实际业务场景具体分析，除了业务上的特殊要求外，一般情况下不需要引入的接口幂等性。</li></ul><h1 id="五、Restful-API-接口的幂等性"><a href="#五、Restful-API-接口的幂等性" class="headerlink" title="五、Restful API 接口的幂等性"></a>五、Restful API 接口的幂等性</h1><p>现在流行的 Restful 推荐的几种 HTTP 接口方法中，分别存在幂等行与不能保证幂等的方法，如下：</p><ul><li>√ 满足幂等</li><li>x 不满足幂等</li><li><ul><li>可能满足也可能不满足幂等，根据实际业务逻辑有关</li></ul></li></ul><table><thead><tr><th>方法类型</th><th>是否幂等</th><th>描述</th></tr></thead><tbody><tr><td>Get</td><td>√</td><td>Get 方法用于获取资源。其一般不会也不应当对系统资源进行改变，所以是幂等的。</td></tr><tr><td>Post</td><td>×</td><td>Post 方法一般用于创建新的资源。其每次执行都会新增数据，所以不是幂等的。</td></tr><tr><td>Put</td><td>-</td><td>Put 方法一般用于修改资源。该操作则分情况来判断是不是满足幂等，更新操作中直接根据某个值进行更新，也能保持幂等。不过执行累加操作的更新是非幂等。</td></tr><tr><td>Delete</td><td>-</td><td>Delete 方法一般用于删除资源。该操作则分情况来判断是不是满足幂等，当根据唯一值进行删除时，删除同一个数据多次执行效果一样。不过需要注意，带查询条件的删除则就不一定满足幂等了。例如在根据条件删除一批数据后，这时候新增加了一条数据也满足条件，然后又执行了一次删除，那么将会导致新增加的这条满足条件数据也被删除。</td></tr></tbody></table><h1 id="六、如何实现幂等性"><a href="#六、如何实现幂等性" class="headerlink" title="六、如何实现幂等性"></a>六、如何实现幂等性</h1><h2 id="方案一：数据库唯一主键"><a href="#方案一：数据库唯一主键" class="headerlink" title="方案一：数据库唯一主键"></a>方案一：数据库唯一主键</h2><p><strong>方案描述</strong><br>数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。<br>使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键（可以参考 Java 中分布式 ID 的设计方案 这篇文章），这样才能能保证在分布式环境下 ID 的全局唯一性。</p><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要生成全局唯一主键 ID；</li></ul><p><strong>主要流程：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwefdI5qGGUJDGHXQS51PWCZCn6gQH0oYx9GVPZ6FIiagFkiakWs9c3cdqCsiaHZhylOJX1yQbXvwibF6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>主要流程：  </p><ul><li>① 客户端执行创建请求，调用服务端接口。</li><li>② 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执数据插入操作，运行对应的 SQL 语句。</li><li>③ 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。</li></ul><h2 id="方案二：数据库乐观锁"><a href="#方案二：数据库乐观锁" class="headerlink" title="方案二：数据库乐观锁"></a>方案二：数据库乐观锁</h2><p><strong>方案描述：</strong><br>数据库乐观锁方案一般只能适用于执行“更新操作”的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。</p><p><strong>适用操作：</strong></p><ul><li>更新操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要数据库对应业务表中添加额外字段；</li></ul><p><strong>描述示例：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwefdI5qGGUJDGHXQS51PWCZlCC8hia9K6zsgUg6Kv4rYCZ3DArAzBN0CujVBK3F0HynqT7H4dfZfBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>例如，存在如下的数据表中：  </p><table><thead><tr><th>id</th><th>name</th><th>price</th></tr></thead><tbody><tr><td>1</td><td>小米手机</td><td>1000</td></tr><tr><td>2</td><td>苹果手机</td><td>2500</td></tr><tr><td>3</td><td>华为手机</td><td>1600</td></tr></tbody></table><p>为了每次执行更新时防止重复更新，确定更新的一定是要更新的内容，我们通常都会添加一个 version 字段记录当前的记录版本，这样在更新时候将该值带上，那么只要执行更新操作就能确定一定更新的是某个对应版本下的信息。</p><table><thead><tr><th>id</th><th>name</th><th>price</th><th>version</th></tr></thead><tbody><tr><td>1</td><td>小米手机</td><td>1000</td><td>10</td></tr><tr><td>2</td><td>苹果手机</td><td>2500</td><td>21</td></tr><tr><td>3</td><td>华为手机</td><td>1600</td><td>5</td></tr></tbody></table><p>这样每次执行更新时候，都要指定要更新的版本号，如下操作就能准确更新 version&#x3D;5 的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> my_table <span class="keyword">SET</span> price<span class="operator">=</span>price<span class="operator">+</span><span class="number">50</span>,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> version<span class="operator">=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面 WHERE 后面跟着条件 id&#x3D;1 AND version&#x3D;5 被执行后，id&#x3D;1 的 version 被更新为 6，所以如果重复执行该条 SQL 语句将不生效，因为 id&#x3D;1 AND version&#x3D;5 的数据已经不存在，这样就能保住更新的幂等，多次更新对结果不会产生影响。</p><h2 id="方案三：防重-Token-令牌"><a href="#方案三：防重-Token-令牌" class="headerlink" title="方案三：防重 Token 令牌"></a>方案三：防重 Token 令牌</h2><p><strong>方案描述：</strong><br>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 Token 的机制实现防止重复提交。简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，如果 Key 存在且 Value 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作。</p><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>更新操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要生成全局唯一 Token 串；</li><li>需要使用第三方组件 Redis 进行数据效验；</li></ul><p><strong>主要流程：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwefdI5qGGUJDGHXQS51PWCZw8tv1YLx13CePmVDlFjxaZsJL1SQd2fyX1xQzIibGFibWI1TYKEgFv5A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>① 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。</li><li>② 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。</li><li>③ 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。</li><li>④ 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。</li><li>⑤ 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。</li><li>⑥ 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。</li><li>⑦ 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。</li></ul><blockquote><p>注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。</p></blockquote><h2 id="方案四、下游传递唯一序列号"><a href="#方案四、下游传递唯一序列号" class="headerlink" title="方案四、下游传递唯一序列号"></a>方案四、下游传递唯一序列号</h2><p><strong>方案描述：</strong><br>所谓请求序列号，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个有序 ID，也可以是一个订单号，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 ID。<br>当上游服务器收到请求信息后拿取该 序列号 和下游 认证ID 进行组合，形成用于操作 Redis 的 Key，然后到 Redis 中查询是否存在对应的 Key 的键值对，根据其结果：</p><ul><li>如果存在，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。</li><li>如果不存在，就以该 Key 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。</li></ul><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>更新操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>要求第三方传递唯一序列号；</li><li>需要使用第三方组件 Redis 进行数据效验；</li></ul><p><strong>主要流程：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwefdI5qGGUJDGHXQS51PWCZoffRxtyeQX337tXwsNjfRbbrX4wicKJnzEhCZib9ibogAHr9eIukanPIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>主要步骤：  </p><ul><li>① 下游服务生成分布式 ID 作为序列号，然后执行请求调用上游接口，并附带“唯一序列号”与请求的“认证凭据ID”。</li><li>② 上游服务进行安全效验，检测下游传递的参数中是否存在“序列号”和“凭据ID”。</li><li>③ 上游服务到 Redis 中检测是否存在对应的“序列号”与“认证ID”组成的 Key，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息。如果不存在就以该“序列号”和“认证ID”组合作为 Key，以下游关键信息作为 Value，进而存储到 Redis 中，然后正常执行接来来的业务逻辑。</li></ul><blockquote><p>上面步骤中插入数据到 Redis 一定要设置过期时间。这样能保证在这个时间范围内，如果重复调用接口，则能够进行判断识别。如果不设置过期时间，很可能导致数据无限量的存入 Redis，致使 Redis 不能正常工作。</p></blockquote><h1 id="七、实现接口幂等示例"><a href="#七、实现接口幂等示例" class="headerlink" title="七、实现接口幂等示例"></a>七、实现接口幂等示例</h1><p>这里使用防重 Token 令牌方案，该方案能保证在不同请求动作下的幂等性，实现逻辑可以看上面写的”防重 Token 令牌”方案，接下来写下实现这个逻辑的代码。</p><h2 id="1、Maven-引入相关依赖"><a href="#1、Maven-引入相关依赖" class="headerlink" title="1、Maven 引入相关依赖"></a>1、Maven 引入相关依赖</h2><p>这里使用 Maven 工具管理依赖，这里在 pom.xml 中引入 SpringBoot、Redis、lombok 相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mydlq.club<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-idempotent-token<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-idempotent-token<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Idempotent Demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springboot web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springboot data redis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、配置连接-Redis-的参数"><a href="#2、配置连接-Redis-的参数" class="headerlink" title="2、配置连接 Redis 的参数"></a>2、配置连接 Redis 的参数</h2><p>在 application 配置文件中配置连接 Redis 的参数如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="string">ssl:</span> <span class="literal">false</span></span><br><span class="line">    <span class="string">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="string">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="string">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="string">timeout:</span> <span class="number">1000</span> </span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="string">max-active:</span> <span class="number">100</span></span><br><span class="line">        <span class="string">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="string">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="string">max-idle:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="3、创建与验证-Token-工具类"><a href="#3、创建与验证-Token-工具类" class="headerlink" title="3、创建与验证 Token 工具类"></a>3、创建与验证 Token 工具类</h2><p>创建用于操作 Token 相关的 Service 类，里面存在 Token 创建与验证方法，其中：</p><ul><li><strong>Token 创建方法：</strong> 使用 UUID 工具创建 Token 串，设置以 “idempotent_token:“+“Token串” 作为 Key，以用户信息当成 Value，将信息存入 Redis 中。</li><li><strong>Token 验证方法：</strong> 接收 Token 串参数，加上 Key 前缀形成 Key，再传入 value 值，执行 Lua 表达式（Lua 表达式能保证命令执行的原子性）进行查找对应 Key 与删除操作。执行完成后验证命令的返回结果，如果结果不为空且非0，则验证成功，否则失败。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;<span class="keyword">import</span> java.util.UUID;<span class="keyword">import</span> java.util.concurrent.TimeUnit;<span class="keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;<span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;<span class="keyword">import</span> org.springframework.data.redis.core.script.RedisScript;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="meta">@Slf4j</span><span class="meta">@Servicepublic</span> <span class="keyword">class</span> <span class="title class_">TokenUtilService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> StringRedisTemplate redisTemplate;    <span class="comment">/**     * 存入 Redis 的 Token 键的前缀     */</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDEMPOTENT_TOKEN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;idempotent_token:&quot;</span>;    <span class="comment">/**     * 创建 Token 存入 Redis，并返回该 Token     *     * <span class="doctag">@param</span> value 用于辅助验证的 value 值     * <span class="doctag">@return</span> 生成的 Token 串     */</span>    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(String value)</span> &#123;        <span class="comment">// 实例化生成 ID 工具对象        String token = UUID.randomUUID().toString();        // 设置存入 Redis 的 Key        String key = IDEMPOTENT_TOKEN_PREFIX + token;        // 存储 Token 到 Redis，且设置过期时间为5分钟        redisTemplate.opsForValue().set(key, value, 5, TimeUnit.MINUTES);        // 返回 Token        return token;    &#125;    /**     * 验证 Token 正确性     *     * @param token token 字符串     * @param value value 存储在Redis中的辅助验证信息     * @return 验证结果     */    public boolean validToken(String token, String value) &#123;        // 设置 Lua 脚本，其中 KEYS[1] 是 key，KEYS[2] 是 value        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == KEYS[2] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;        RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(script, Long.class);        // 根据 Key 前缀拼接 Key        String key = IDEMPOTENT_TOKEN_PREFIX + token;        // 执行 Lua 脚本        Long result = redisTemplate.execute(redisScript, Arrays.asList(key, value));        // 根据返回结果判断是否成功成功匹配并删除 Redis 键值对，若果结果不为空和0，则验证通过        if (result != null &amp;&amp; result != 0L) &#123;            log.info(&quot;验证 token=&#123;&#125;,key=&#123;&#125;,value=&#123;&#125; 成功&quot;, token, key, value);            return true;        &#125;        log.info(&quot;验证 token=&#123;&#125;,key=&#123;&#125;,value=&#123;&#125; 失败&quot;, token, key, value);        return false;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4、创建测试的-Controller-类"><a href="#4、创建测试的-Controller-类" class="headerlink" title="4、创建测试的 Controller 类"></a>4、创建测试的 Controller 类</h2><p>创建用于测试的 Controller 类，里面有获取 Token 与测试接口幂等性的接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="keyword">import</span> mydlq.club.example.service.TokenUtilService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="meta">@Slf4j</span><span class="meta">@RestControllerpublic</span> <span class="keyword">class</span> <span class="title class_">TokenController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> TokenUtilService tokenService;    <span class="comment">/**     * 获取 Token 接口     *     * <span class="doctag">@return</span> Token 串     */</span>    <span class="meta">@GetMapping(&quot;/token&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">()</span> &#123;        <span class="comment">// 获取用户信息（这里使用模拟数据）        // 注：这里存储该内容只是举例，其作用为辅助验证，使其验证逻辑更安全，如这里存储用户信息，其目的为:        // - 1)、使用&quot;token&quot;验证 Redis 中是否存在对应的 Key        // - 2)、使用&quot;用户信息&quot;验证 Redis 的 Value 是否匹配。        String userInfo = &quot;mydlq&quot;;        // 获取 Token 字符串，并返回        return tokenService.generateToken(userInfo);    &#125;    /**     * 接口幂等性测试接口     *     * @param token 幂等 Token 串     * @return 执行结果     */    @PostMapping(&quot;/test&quot;)    public String test(@RequestHeader(value = &quot;token&quot;) String token) &#123;        // 获取用户信息（这里使用模拟数据）        String userInfo = &quot;mydlq&quot;;        // 根据 Token 和与用户相关的信息到 Redis 验证是否存在对应的信息        boolean result = tokenService.validToken(token, userInfo);        // 根据验证结果响应不同信息        return result ? &quot;正常调用&quot; : &quot;重复调用&quot;;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5、创建-SpringBoot-启动类"><a href="#5、创建-SpringBoot-启动类" class="headerlink" title="5、创建 SpringBoot 启动类"></a>5、创建 SpringBoot 启动类</h2><p>创建启动类，用于启动 SpringBoot 应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;       </span><br><span class="line">SpringApplication.run(Application.class, args);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、写测试类进行测试"><a href="#6、写测试类进行测试" class="headerlink" title="6、写测试类进行测试"></a>6、写测试类进行测试</h2><p>写个测试类进行测试，多次访问同一个接口，测试是否只有第一次能否执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdempotenceTest</span> &#123;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line"><span class="keyword">private</span> WebApplicationContext webApplicationContext;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interfaceIdempotenceTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        </span><br><span class="line"><span class="comment">// 初始化 MockMvc       </span></span><br><span class="line"><span class="type">MockMvc</span> <span class="variable">mockMvc</span> <span class="operator">=</span> MockMvcBuilders.webAppContextSetup(webApplicationContext)</span><br><span class="line">.build();        </span><br><span class="line"><span class="comment">// 调用获取 Token 接口        </span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/token&quot;</span>)   .accept(MediaType.TEXT_HTML))                </span><br><span class="line">.andReturn()                </span><br><span class="line">.getResponse()</span><br><span class="line">.getContentAsString();        </span><br><span class="line">log.info(<span class="string">&quot;获取的 Token 串：&#123;&#125;&quot;</span>, token);        </span><br><span class="line"><span class="comment">// 循环调用 5 次进行测试        </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            </span><br><span class="line">log.info(<span class="string">&quot;第&#123;&#125;次调用测试接口&quot;</span>, i);            <span class="comment">// 调用验证接口并打印结果           </span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/test&quot;</span>)             </span><br><span class="line">.header(<span class="string">&quot;token&quot;</span>, token)                    </span><br><span class="line">.accept(MediaType.TEXT_HTML))                    </span><br><span class="line">.andReturn()</span><br><span class="line">.getResponse()</span><br><span class="line">.getContentAsString();       </span><br><span class="line">log.info(result);            </span><br><span class="line"><span class="comment">// 结果断言            </span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;               </span><br><span class="line">Assert.assertEquals(result, <span class="string">&quot;正常调用&quot;</span>);            </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;               </span><br><span class="line">Assert.assertEquals(result, <span class="string">&quot;重复调用&quot;</span>);           </span><br><span class="line">&#125;        </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main] IdempotenceTest:  获取的 Token 串：980ea707-ce2e-456e-a059-0a03332110b4[main] IdempotenceTest:  第1次调用测试接口[main] IdempotenceTest:  正常调用[main] IdempotenceTest:  第2次调用测试接口[main] IdempotenceTest:  重复调用[main] IdempotenceTest:  第3次调用测试接口[main] IdempotenceTest:  重复调用[main] IdempotenceTest:  第4次调用测试接口[main] IdempotenceTest:  重复调用[main] IdempotenceTest:  第5次调用测试接口[main] IdempotenceTest:  重复调用</span><br></pre></td></tr></table></figure><h1 id="八、最后总结"><a href="#八、最后总结" class="headerlink" title="八、最后总结"></a>八、最后总结</h1><p>幂等性是开发当中很常见也很重要的一个需求，尤其是支付、订单等与金钱挂钩的服务，保证接口幂等性尤其重要。在实际开发中，我们需要针对不同的业务场景我们需要灵活的选择幂等性的实现方式：  </p><ul><li>对于下单等存在唯一主键的，可以使用“唯一主键方案”的方式实现。</li><li>对于更新订单状态等相关的更新场景操作，使用“乐观锁方案”实现更为简单。</li><li>对于上下游这种，下游请求上游，上游服务可以使用“下游传递唯一序列号方案”更为合理。</li><li>类似于前端重复提交、重复下单、没有唯一ID号的场景，可以通过 Token 与 Redis 配合的“防重 Token 方案”实现更为快捷。</li></ul><p>上面只是给与一些建议，再次强调一下，实现幂等性需要先理解自身业务需求，根据业务逻辑来实现这样才合理，处理好其中的每一个结点细节，完善整体的业务流程设计，才能更好的保证系统的正常运行。最后做一个简单总结</p><table><thead><tr><th>方案名称</th><th>适用方法</th><th>实现复杂度</th><th>方案缺点</th></tr></thead><tbody><tr><td>数据库唯一主键</td><td>插入操作 删除操作</td><td>简单</td><td>- 只能用于插入操作；- 只能用于存在唯一主键场景；</td></tr><tr><td>数据库乐观锁</td><td>更新操作</td><td>简单</td><td>- 只能用于更新操作；- 表中需要额外添加字段；</td></tr><tr><td>请求序列号</td><td>插入操作 更新操作 删除操作</td><td>简单</td><td>- 需要保证下游生成唯一序列号；- 需要 Redis 第三方存储已经请求的序列号；</td></tr><tr><td>防重 Token 令牌</td><td>插入操作 更新操作 删除操作</td><td>适中</td><td>- 需要 Redis 第三方存储生成的 Token 串；</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文（&lt;a href=&quot;https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg%EF%BC%89&quot;&gt;https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    
    <category term="Java" scheme="https://andy-whb-cn.github.io/tags/Java/"/>
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java：应用启动脚本</title>
    <link href="https://andy-whb-cn.github.io/2024/08/27/Java%EF%BC%9A%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
    <id>https://andy-whb-cn.github.io/2024/08/27/Java%EF%BC%9A%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</id>
    <published>2024-08-27T08:10:51.500Z</published>
    <updated>2024-09-03T00:46:02.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见的Java应用启停脚本"><a href="#常见的Java应用启停脚本" class="headerlink" title="常见的Java应用启停脚本"></a>常见的Java应用启停脚本</h2><p>reboot_jar_shell.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">bootClassPath=$*</span><br><span class="line">appName=$1</span><br><span class="line">echo &quot;==========================&quot;</span><br><span class="line">echo &quot;stop $&#123;appName&#125;&quot;</span><br><span class="line">PID=`ps axu | grep java | grep &quot;$&#123;appName&#125;&quot; |grep -v grep| awk &#x27;&#123;printf $2&#125;&#x27;`</span><br><span class="line">if [ -n &quot;$&#123;PID&#125;&quot; ]; then</span><br><span class="line">  echo &quot;kill process $&#123;PID&#125;&quot;</span><br><span class="line">  kill -9 $&#123;PID&#125;</span><br><span class="line">fi</span><br><span class="line">echo &quot;$&#123;appName&#125; stopped&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;start $&#123;appName&#125;&quot;</span><br><span class="line">echo &quot;boot classpath: $&#123;bootClassPath&#125;&quot;</span><br><span class="line">nohup java server $bootClassPath &gt;nohup.log 2&gt;&amp;1 &amp;</span><br><span class="line">echo &quot;$appName started&quot;</span><br><span class="line">echo &quot;==========================&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>restart.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;--------xxx 开始启动--------------&quot;</span><br><span class="line">     sh reboot_jar_shell.sh -DappName=xxx -Xms1024m -Xmx1024m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/xxxx/logs -Djava.io.tmpdir=/data/tmp/xxxx -Xbootclasspath/a:/data/xxxx/config -Dspring.profiles.active=&lt;env&gt; -Dfile.encoding=utf-8 -jar xxx.jar</span><br><span class="line">     sleep 10</span><br><span class="line">echo &quot;--------xxx 启动成功--------------&quot;</span><br></pre></td></tr></table></figure><p>JVM heap参数设置建议：<br>1、JVM默认会根据运行机器的配置情况自动设置heap大小；<br>2、尽可能通过选择GC算法调优，而不是调整heap大小，除非应用需要的heap大小超过了默认值；<br>3、通常情况下，heap大小设置可以参考Full GC后老年代存活对象大小的3-4倍；<br>4、如果明确知道应用需要用到的heap大小，可以将Xms和Xmx设置为相同值，避免heap resize，会让GC更高效。<br><img src="https://s2.loli.net/2024/08/29/zoacyRxhINgbjPS.png" alt="image.png"><br>相关建议来源参考书籍《Java Performance, 2nd Edition》 by Scott Oaks</p><h2 id="Jvm优化"><a href="#Jvm优化" class="headerlink" title="Jvm优化"></a>Jvm优化</h2><p>这块主要不是谈如何优化，jvm优化是一个需要场景化的，没有什么太多特定参数，一般来说在server端运行都会指定如下参数</p><blockquote><p>初始内存和最大内存基本会设置成一样的，具体大小根据场景设置，-server是一个必须要用的参数，至于收集器这些使用默认的就可以了，除非有特定需求。</p></blockquote><h3 id="1-使用-server模式"><a href="#1-使用-server模式" class="headerlink" title="1.使用-server模式"></a>1.使用-server模式</h3><p>设置JVM使用server模式。64位JDK默认启动该模式</p><p><code>java -server -jar springboot-1.0.jar   </code></p><h3 id="2-指定堆参数"><a href="#2-指定堆参数" class="headerlink" title="2.指定堆参数"></a>2.指定堆参数</h3><p>这个根据服务器的内存大小，来设置堆参数。</p><ul><li>-Xms :设置Java堆栈的初始化大小</li><li>-Xmx :设置最大的java堆大小</li></ul><p><code>java -server -Xms512m -Xmx768m  -jar springboot-1.0.jar   </code></p><p>设置初始化堆内存为512MB，最大为768MB。</p><h3 id="3-远程Debug"><a href="#3-远程Debug" class="headerlink" title="3.远程Debug"></a>3.远程Debug</h3><p>在服务器上将启动参数修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djavax.net.debug=ssl -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8888 -jar springboot-1.0.jar </span><br></pre></td></tr></table></figure><p>这个时候服务端远程Debug模式开启，端口号为8888。</p><p>在IDEA中，点击Edit Configuration按钮。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNXkEukbLoTvyCXuwEDpW5zgZETUNibbORKodWhVrUMxqlCBpNwxiaaCtQw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">出现弹窗，点击+按钮，找到Remote选项。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNXvGrNvOFxJreZbGsLJqMHg7e6csPI3MrXNZSRdClkKgRfpzI4EoztTQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>在【1】中填入Remote项目名称，在【2】中填IP地址和端口号，在【3】选择远程调试的项目module，配置完成后点击OK即可</p><p>如果碰到连接超时的情况，很有可能服务器的防火墙的问题，举例CentOs7,关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service #停止firewall   systemctl disable firewalld.service #禁止firewall开机启动 </span><br></pre></td></tr></table></figure><p>点击debug按钮，IDEA控制台打印信息：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNXkPeueIjKTxDFmVCyU8rcePPFm9ufgWJ7PmTZYRbbJiafG3Cl9rJdsEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">说明远程调试成功。</p><h2 id="JVM工具远程连接"><a href="#JVM工具远程连接" class="headerlink" title="JVM工具远程连接"></a>JVM工具远程连接</h2><h3 id="jconsole与Jvisualvm远程连接"><a href="#jconsole与Jvisualvm远程连接" class="headerlink" title="jconsole与Jvisualvm远程连接"></a>jconsole与Jvisualvm远程连接</h3><p>通常我们的web服务都输部署在服务器上的，在window使用jconsole是很方便的，相对于Linux就有一些麻烦了，需要进行一些设置。</p><p>1.查看hostname,首先使用<br><code>hostname -i   </code><br>查看，服务器的hostname为127.0.0.1，这个是不对的，需要进行修改</p><p>2.修改hostname<br>修改&#x2F;etc&#x2F;hosts文件，将其第一行的“127.0.0.1 localhost.localdomain localhost”，修改为：“192.168.44.128 localhost.localdomain localhost”.<br>“192.168.44.128”为实际的服务器的IP</p><p>3.重启Linux，在服务器上输入hostname -i，查看实际设置的IP地址是否为你设置的</p><p>4.启动服务，参数为：<br><code>java -jar -Djava.rmi.server.hostname=192.168.44.128 -   Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=911 -   Dcom.sun.management.jmxremote.ssl=false -   Dcom.sun.management.jmxremote.authenticate=false jantent-1.0-SNAPSHOT.jar   </code></p><p>ip为192.168.44.128，端口为911 。</p><p>5.打开Jconsole，进行远程连接,输入IP和端口即可<br>点击连接，经过稍稍等待之后，即可完成连接，如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNX79JjeOV3wNV8humibI8mG6jicRLrLMvrSjIpjy20IxRWCrnFPuagrTRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">同理，JvisualVm的远程连接是同样的，启动参数也是一样。</p><p>然后在本机JvisualVm输入IP：PORT，即可进行远程连接：如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNXJV3drWDKkOUJaayW3B4TwxnOjJAUhK5011K7lVlcdwBRcDS6PH4LFQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">相比较Jvisualvm功能更加强大一下，界面也更美观。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见的Java应用启停脚本&quot;&gt;&lt;a href=&quot;#常见的Java应用启停脚本&quot; class=&quot;headerlink&quot; title=&quot;常见的Java应用启停脚本&quot;&gt;&lt;/a&gt;常见的Java应用启停脚本&lt;/h2&gt;&lt;p&gt;reboot_jar_shell.sh&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    
    <category term="Java" scheme="https://andy-whb-cn.github.io/tags/Java/"/>
    
    <category term="脚本" scheme="https://andy-whb-cn.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>前端版本更新检测</title>
    <link href="https://andy-whb-cn.github.io/2024/08/26/%E5%89%8D%E7%AB%AF%EF%BC%9A%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B/"/>
    <id>https://andy-whb-cn.github.io/2024/08/26/%E5%89%8D%E7%AB%AF%EF%BC%9A%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B/</id>
    <published>2024-08-26T09:41:36.083Z</published>
    <updated>2024-08-26T10:06:39.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端版本更新检测方案"><a href="#前端版本更新检测方案" class="headerlink" title="前端版本更新检测方案"></a>前端版本更新检测方案</h2><h4 id="采用Etag比较"><a href="#采用Etag比较" class="headerlink" title="采用Etag比较"></a>采用Etag比较</h4><p><a href="https://blog.csdn.net/qq_38951259/article/details/136739490">https://blog.csdn.net/qq_38951259/article/details/136739490</a></p><h4 id="采用前后端Version比较"><a href="#采用前后端Version比较" class="headerlink" title="采用前后端Version比较"></a>采用前后端Version比较</h4><p>1、后台提供轻量级version api；<br>2、前端页面初始化或定时，比较本地version和服务端version是否有变更，设置local vesion变更变量；<br>3、前端在进入router前，判断有local vesion变更变量，刷新本地缓存并删除local vesion变更变量；</p><p>引申：为避免频繁去请求后台的version，可以考虑按时间戳（每日）去检查远端version更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端版本更新检测方案&quot;&gt;&lt;a href=&quot;#前端版本更新检测方案&quot; class=&quot;headerlink&quot; title=&quot;前端版本更新检测方案&quot;&gt;&lt;/a&gt;前端版本更新检测方案&lt;/h2&gt;&lt;h4 id=&quot;采用Etag比较&quot;&gt;&lt;a href=&quot;#采用Etag比较&quot; cla</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://andy-whb-cn.github.io/tags/Vue/"/>
    
    <category term="前端" scheme="https://andy-whb-cn.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>大数据：Flink 处理复杂的Json格式</title>
    <link href="https://andy-whb-cn.github.io/2024/08/22/%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%9AFlink-Nested-Json/"/>
    <id>https://andy-whb-cn.github.io/2024/08/22/%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%9AFlink-Nested-Json/</id>
    <published>2024-08-22T08:33:34.000Z</published>
    <updated>2024-09-03T00:45:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flink-复杂Json格式处理"><a href="#Flink-复杂Json格式处理" class="headerlink" title="Flink 复杂Json格式处理"></a>Flink 复杂Json格式处理</h2><p>Flink 官方文档：<a href="https://nightlies.apache.org/flink/flink-docs-release-1.20/zh/docs/connectors/table/formats/json/">https://nightlies.apache.org/flink/flink-docs-release-1.20/zh/docs/connectors/table/formats/json/</a></p><p>Flink 对于单层Json的处理，可以支持直接转换，但对于复杂的嵌套Json则需要在类型定义上做一些处理。</p><p>以下是结合ROW、ARRAY、MAP的简单示例介绍（原文： <a href="https://blog.csdn.net/m0_67400972/article/details/123923656">https://blog.csdn.net/m0_67400972/article/details/123923656</a> ）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1238123899121</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;asdlkjasjkdla998y1122&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span><span class="string">&quot;1990-10-14&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;obj&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;time1&quot;</span><span class="punctuation">:</span><span class="string">&quot;12:12:43Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;str&quot;</span><span class="punctuation">:</span><span class="string">&quot;sfasfafs&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lg&quot;</span><span class="punctuation">:</span><span class="number">2324342345</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;arr&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;f1&quot;</span><span class="punctuation">:</span><span class="string">&quot;f1str11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;f2&quot;</span><span class="punctuation">:</span><span class="number">134</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;f1&quot;</span><span class="punctuation">:</span><span class="string">&quot;f1str22&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;f2&quot;</span><span class="punctuation">:</span><span class="number">555</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span><span class="string">&quot;12:12:43Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span><span class="string">&quot;1990-10-14T12:12:43Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;flink&quot;</span><span class="punctuation">:</span><span class="number">123</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mapinmap&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;inner_map&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="number">234</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> json_source (</span><br><span class="line">    id            <span class="type">BIGINT</span>,</span><br><span class="line">    name          STRING,</span><br><span class="line">    `<span class="type">date</span>`        <span class="type">DATE</span>,</span><br><span class="line">    obj           <span class="type">ROW</span><span class="operator">&lt;</span>time1 <span class="type">TIME</span>,str STRING,lg <span class="type">BIGINT</span><span class="operator">&gt;</span>,</span><br><span class="line">    arr           <span class="keyword">ARRAY</span><span class="operator">&lt;</span><span class="type">ROW</span><span class="operator">&lt;</span>f1 STRING,f2 <span class="type">INT</span><span class="operator">&gt;&gt;</span>,</span><br><span class="line">    `<span class="type">time</span>`        <span class="type">TIME</span>,</span><br><span class="line">    `<span class="type">timestamp</span>`   <span class="type">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">    `map`         MAP<span class="operator">&lt;</span>STRING,<span class="type">BIGINT</span><span class="operator">&gt;</span>,</span><br><span class="line">    mapinmap      MAP<span class="operator">&lt;</span>STRING,MAP<span class="operator">&lt;</span>STRING,<span class="type">INT</span><span class="operator">&gt;&gt;</span>,</span><br><span class="line">    proctime <span class="keyword">as</span> PROCTIME()</span><br><span class="line"> ) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="string">&#x27;connector.type&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;connector.topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;connector.properties.zookeeper.connect&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost:2181&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;connector.properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost:9092&#x27;</span>,   </span><br><span class="line">    <span class="string">&#x27;connector.properties.group.id&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;testGroup&#x27;</span>,    </span><br><span class="line">    <span class="string">&#x27;connector.version&#x27;</span><span class="operator">=</span><span class="string">&#x27;universal&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;format.type&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;json&#x27;</span>,     </span><br><span class="line">    <span class="string">&#x27;connector.startup-mode&#x27;</span><span class="operator">=</span><span class="string">&#x27;latest-offset&#x27;</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 构造</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> json_source <span class="keyword">select</span> <span class="number">111</span> <span class="keyword">as</span> id,<span class="string">&#x27;name&#x27;</span> <span class="keyword">as</span> name,<span class="type">Row</span>(<span class="built_in">CURRENT_TIME</span>,<span class="string">&#x27;ss&#x27;</span>,<span class="number">123</span>) <span class="keyword">as</span> obj,<span class="keyword">Array</span>[<span class="type">Row</span>(<span class="string">&#x27;f&#x27;</span>,<span class="number">1</span>),<span class="type">Row</span>(<span class="string">&#x27;s&#x27;</span>,<span class="number">2</span>)] <span class="keyword">as</span> arr,Map[<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;v1&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>,<span class="string">&#x27;v2&#x27;</span>] <span class="keyword">as</span> `map`,Map[<span class="string">&#x27;inner_map&#x27;</span>,Map[<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;v&#x27;</span>]] <span class="keyword">as</span> mapinmap;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取，注意数组index从1开始</span></span><br><span class="line"><span class="keyword">select</span> id, name,`<span class="type">date</span>`,obj.str,arr[<span class="number">1</span>].f1,`map`[<span class="string">&#x27;flink&#x27;</span>],mapinmap[<span class="string">&#x27;inner_map&#x27;</span>][<span class="string">&#x27;key&#x27;</span>] <span class="keyword">from</span> json_source;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Flink-复杂Json格式处理&quot;&gt;&lt;a href=&quot;#Flink-复杂Json格式处理&quot; class=&quot;headerlink&quot; title=&quot;Flink 复杂Json格式处理&quot;&gt;&lt;/a&gt;Flink 复杂Json格式处理&lt;/h2&gt;&lt;p&gt;Flink 官方文档：&lt;a </summary>
      
    
    
    
    
    <category term="Flink" scheme="https://andy-whb-cn.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>面向接口：防篡改&amp;防重放</title>
    <link href="https://andy-whb-cn.github.io/2024/08/22/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%98%B2%E7%AF%A1%E6%94%B9&amp;%E9%98%B2%E9%87%8D%E6%94%BE/"/>
    <id>https://andy-whb-cn.github.io/2024/08/22/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%98%B2%E7%AF%A1%E6%94%B9&amp;%E9%98%B2%E9%87%8D%E6%94%BE/</id>
    <published>2024-08-22T08:33:34.000Z</published>
    <updated>2024-09-03T00:44:41.798Z</updated>
    
    <content type="html"><![CDATA[<p>对于互联网来说，只要你系统的接口暴露在外网，就避免不了接口安全问题。如果你的接口在外网裸奔，只要让黑客知道接口的地址和参数就可以调用，那简直就是灾难。</p><p>举个例子：你的网站用户注册的时候，需要填写手机号，发送手机验证码，如果这个发送验证码的接口没有经过特殊安全处理，那这个短信接口早就被人盗刷不知道浪费多少钱了。</p><p>那如何保证接口安全呢？</p><p>一般来说，暴露在外网的api接口需要做到<strong>防篡改</strong>和<strong>防重放</strong>才能称之为安全的接口。</p><h2 id="防篡改"><a href="#防篡改" class="headerlink" title="防篡改"></a>防篡改</h2><p>我们知道http 是一种无状态的协议，服务端并不知道客户端发送的请求是否合法，也并不知道请求中的参数是否正确。</p><p>举个例子, 现在有个充值的接口，调用后可以给用户增加对应的余额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/api/user/recharge?user_id=1001&amp;amount=10</span><br></pre></td></tr></table></figure><p>如果非法用户通过抓包获取到接口参数后，修改user_id 或 amount的值就可以实现给任意账户添加余额的目的。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>采用https协议可以将传输的明文进行加密，但是黑客仍然可以截获传输的数据包，进一步伪造请求进行重放攻击。如果黑客使用特殊手段让请求方设备使用了伪造的证书进行通信，那么https加密的内容也会被解密。</p><p>一般的做法有2种：</p><ol><li><p>采用https方式把接口的数据进行加密传输，即便是被黑客破解，黑客也花费大量的时间和精力去破解。</p></li><li><p>接口后台对接口的请求参数进行验证，防止被黑客篡改；</p></li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jEXDkwjCHn8A3Iia4zpIqaKomGCEViagKJ8nibEOrCOuXp37YjGoTibibIl4qwyaxa2PZt6ib2V4Qpb14Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><p>步骤1：客户端使用约定好的秘钥对传输的参数进行加密，得到签名值sign1，并且将签名值也放入请求的参数中，发送请求给服务端</p></li><li><p>步骤2：服务端接收到客户端的请求，然后使用约定好的秘钥对请求的参数再次进行签名，得到签名值sign2。</p></li><li><p>步骤3：服务端比对sign1和sign2的值，如果不一致，就认定为被篡改，非法请求。</p></li></ul><h2 id="防重放"><a href="#防重放" class="headerlink" title="防重放"></a>防重放</h2><p>防重放也叫防复用。简单来说就是我获取到这个请求的信息之后什么也不改,，直接拿着接口的参数 <code>重复请求这个充值的接口</code>。此时我的请求是合法的, 因为所有参数都是跟合法请求一模一样的。  </p><p>重放攻击会造成两种后果：</p><ol><li><p>针对插入数据库接口：重放攻击，会出现大量重复数据，甚至垃圾数据会把数据库撑爆。</p></li><li><p>针对查询的接口：黑客一般是重点攻击慢查询接口，例如一个慢查询接口1s，只要黑客发起重放攻击，就必然造成系统被拖垮，数据库查询被阻塞死。</p></li></ol><p>对于重放攻击一般有两种做法：</p><h3 id="基于timestamp的方案"><a href="#基于timestamp的方案" class="headerlink" title="基于timestamp的方案"></a>基于timestamp的方案</h3><p>每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间比较，是否超过了60s，如果超过了则认为是非法请求。</p><p>一般情况下，黑客从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了。如果黑客修改timestamp参数为当前的时间戳，则sign1参数对应的数字签名就会失效，因为黑客不知道签名秘钥，没有办法生成新的数字签名。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jEXDkwjCHn8A3Iia4zpIqaKQL2eMsnqPMcXSZjUGIsAOFuG4J9unKT1ddkxaGmelkHshRNPplro3A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>但是这种方式的漏洞也是显而易见，如果在60s之内进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效。</p><p>老鸟们一般会采取下面这种方案，既可以解决接口重放问题，又可以解决接口一次请求有效的问题。</p><h3 id="基于nonce-timestamp-的方案"><a href="#基于nonce-timestamp-的方案" class="headerlink" title="基于nonce + timestamp 的方案"></a>基于nonce + timestamp 的方案</h3><p>nonce的意思是仅一次有效的随机字符串，要求每次请求时该参数要保证不同。实际使用用户信息+时间戳+随机数等信息做个哈希之后，作为nonce参数。</p><p>此时服务端的处理流程如下：</p><ol><li><p>去 redis 中查找是否有 key 为 <code>nonce:&#123;nonce&#125;</code> 的 string</p></li><li><p>如果没有，则创建这个 key，把这个 key 失效的时间和验证 timestamp 失效的时间一致，比如是 60s。</p></li><li><p>如果有，说明这个 key 在 60s 内已经被使用了，那么这个请求就可以判断为重放请求。</p></li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jEXDkwjCHn8A3Iia4zpIqaKDT8kbG9CiaIWktCicqibzAVdUYbsJTlvwTy0MqqGtmkMHRhRYDdzr6VBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这种方案nonce和timestamp参数都作为签名的一部分传到后端，基于timestamp方案可以让黑客只能在60s内进行重放攻击，加上nonce随机数以后可以保证接口只能被调用一次，可以很好的解决重放攻击问题。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>接下来通过实际代码来看看如何实现接口的防篡改和防重放。</p><h3 id="1、构建请求头对象"><a href="#1、构建请求头对象" class="headerlink" title="1、构建请求头对象"></a>1、构建请求头对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Data@Builderpublic class RequestHeader &#123;   private String sign ;   private Long timestamp ;   private String nonce;&#125;</span><br></pre></td></tr></table></figure><h3 id="2、工具类从HttpServletRequest获取请求参数"><a href="#2、工具类从HttpServletRequest获取请求参数" class="headerlink" title="2、工具类从HttpServletRequest获取请求参数"></a>2、工具类从HttpServletRequest获取请求参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j@UtilityClasspublic class HttpDataUtil &#123;    /**     * post请求处理：获取 Body 参数，转换为SortedMap     *     * @param request     */    public  SortedMap&lt;String, String&gt; getBodyParams(final HttpServletRequest request) throws IOException &#123;        byte[] requestBody = StreamUtils.copyToByteArray(request.getInputStream());        String body = new String(requestBody);        return JsonUtil.json2Object(body, SortedMap.class);    &#125;    /**     * get请求处理：将URL请求参数转换成SortedMap     */    public static SortedMap&lt;String, String&gt; getUrlParams(HttpServletRequest request) &#123;        String param = &quot;&quot;;        SortedMap&lt;String, String&gt; result = new TreeMap&lt;&gt;();        if (StringUtils.isEmpty(request.getQueryString())) &#123;            return result;        &#125;        try &#123;            param = URLDecoder.decode(request.getQueryString(), &quot;utf-8&quot;);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;        String[] params = param.split(&quot;&amp;&quot;);        for (String s : params) &#123;            String[] array=s.split(&quot;=&quot;);            result.put(array[0], array[1]);        &#125;        return result;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>这里的参数放入SortedMap中对其进行字典排序，前端构建签名时同样需要对参数进行字典排序。</p><h3 id="3、签名验证工具类"><a href="#3、签名验证工具类" class="headerlink" title="3、签名验证工具类"></a>3、签名验证工具类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j@UtilityClasspublic class SignUtil &#123;    /**     * 验证签名     * 验证算法：把timestamp + JsonUtil.object2Json(SortedMap)合成字符串，然后MD5     */    @SneakyThrows    public  boolean verifySign(SortedMap&lt;String, String&gt; map, RequestHeader requestHeader) &#123;        String params = requestHeader.getNonce() + requestHeader.getTimestamp() + JsonUtil.object2Json(map);        return verifySign(params, requestHeader);    &#125;    /**     * 验证签名     */    public boolean verifySign(String params, RequestHeader requestHeader) &#123;        log.debug(&quot;客户端签名: &#123;&#125;&quot;, requestHeader.getSign());        if (StringUtils.isEmpty(params)) &#123;            return false;        &#125;        log.info(&quot;客户端上传内容: &#123;&#125;&quot;, params);        String paramsSign = DigestUtils.md5DigestAsHex(params.getBytes()).toUpperCase();        log.info(&quot;客户端上传内容加密后的签名结果: &#123;&#125;&quot;, paramsSign);        return requestHeader.getSign().equals(paramsSign);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="4、HttpServletRequest包装类"><a href="#4、HttpServletRequest包装类" class="headerlink" title="4、HttpServletRequest包装类"></a>4、HttpServletRequest包装类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class SignRequestWrapper extends HttpServletRequestWrapper &#123;    //用于将流保存下来    private byte[] requestBody = null;    public SignRequestWrapper(HttpServletRequest request) throws IOException &#123;        super(request);        requestBody = StreamUtils.copyToByteArray(request.getInputStream());    &#125;    @Override    public ServletInputStream getInputStream() throws IOException &#123;        final ByteArrayInputStream bais = new ByteArrayInputStream(requestBody);        return new ServletInputStream() &#123;            @Override            public boolean isFinished() &#123;                return false;            &#125;            @Override            public boolean isReady() &#123;                return false;            &#125;            @Override            public void setReadListener(ReadListener readListener) &#123;            &#125;            @Override            public int read() throws IOException &#123;                return bais.read();            &#125;        &#125;;    &#125;    @Override    public BufferedReader getReader() throws IOException &#123;        return new BufferedReader(new InputStreamReader(getInputStream()));    &#125;&#125;</span><br></pre></td></tr></table></figure><p>防篡改和防重放我们会通过SpringBoot Filter来实现，而编写的filter过滤器需要读取request数据流，但是request数据流只能读取一次，需要自己实现HttpServletRequestWrapper对数据流包装，目的是将request流保存下来。</p><h3 id="5、创建过滤器实现安全校验"><a href="#5、创建过滤器实现安全校验" class="headerlink" title="5、创建过滤器实现安全校验"></a>5、创建过滤器实现安全校验</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Configurationpublic class SignFilterConfiguration &#123;    @Value(&quot;$&#123;sign.maxTime&#125;&quot;)    private String signMaxTime;    //filter中的初始化参数    private Map&lt;String, String&gt; initParametersMap =  new HashMap&lt;&gt;();    @Bean    public FilterRegistrationBean contextFilterRegistrationBean() &#123;        initParametersMap.put(&quot;signMaxTime&quot;,signMaxTime);        FilterRegistrationBean registration = new FilterRegistrationBean();        registration.setFilter(signFilter());        registration.setInitParameters(initParametersMap);        registration.addUrlPatterns(&quot;/sign/*&quot;);        registration.setName(&quot;SignFilter&quot;);        // 设置过滤器被调用的顺序        registration.setOrder(1);        return registration;    &#125;    @Bean    public Filter signFilter() &#123;        return new SignFilter();    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Slf4jpublic class SignFilter implements Filter &#123;    @Resource    private RedisUtil redisUtil;    //从fitler配置中获取sign过期时间    private Long signMaxTime;    private static final String NONCE_KEY = &quot;x-nonce-&quot;;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;        HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;        log.info(&quot;过滤URL:&#123;&#125;&quot;, httpRequest.getRequestURI());        HttpServletRequestWrapper requestWrapper = new SignRequestWrapper(httpRequest);        //构建请求头        RequestHeader requestHeader = RequestHeader.builder()                .nonce(httpRequest.getHeader(&quot;x-Nonce&quot;))                .timestamp(Long.parseLong(httpRequest.getHeader(&quot;X-Time&quot;)))                .sign(httpRequest.getHeader(&quot;X-Sign&quot;))                .build();        //验证请求头是否存在        if(StringUtils.isEmpty(requestHeader.getSign()) || ObjectUtils.isEmpty(requestHeader.getTimestamp()) || StringUtils.isEmpty(requestHeader.getNonce()))&#123;            responseFail(httpResponse, ReturnCode.ILLEGAL_HEADER);            return;        &#125;        /*         * 1.重放验证         * 判断timestamp时间戳与当前时间是否操过60s（过期时间根据业务情况设置）,如果超过了就提示签名过期。         */        long now = System.currentTimeMillis() / 1000;        if (now - requestHeader.getTimestamp() &gt; signMaxTime) &#123;            responseFail(httpResponse,ReturnCode.REPLAY_ERROR);            return;        &#125;        //2. 判断nonce        boolean nonceExists = redisUtil.hasKey(NONCE_KEY + requestHeader.getNonce());        if(nonceExists)&#123;            //请求重复            responseFail(httpResponse,ReturnCode.REPLAY_ERROR);            return;        &#125;else &#123;            redisUtil.set(NONCE_KEY+requestHeader.getNonce(), requestHeader.getNonce(), signMaxTime);        &#125;        boolean accept;        SortedMap&lt;String, String&gt; paramMap;        switch (httpRequest.getMethod())&#123;            case &quot;GET&quot;:                paramMap = HttpDataUtil.getUrlParams(requestWrapper);                accept = SignUtil.verifySign(paramMap, requestHeader);                break;            case &quot;POST&quot;:                paramMap = HttpDataUtil.getBodyParams(requestWrapper);                accept = SignUtil.verifySign(paramMap, requestHeader);                break;            default:                accept = true;                break;        &#125;        if (accept) &#123;            filterChain.doFilter(requestWrapper, servletResponse);        &#125; else &#123;            responseFail(httpResponse,ReturnCode.ARGUMENT_ERROR);            return;        &#125;    &#125;    private void responseFail(HttpServletResponse httpResponse, ReturnCode returnCode)  &#123;        ResultData&lt;Object&gt; resultData = ResultData.fail(returnCode.getCode(), returnCode.getMessage());        WebUtils.writeJson(httpResponse,resultData);    &#125;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        String signTime = filterConfig.getInitParameter(&quot;signMaxTime&quot;);        signMaxTime = Long.parseLong(signTime);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="6、Redis工具类"><a href="#6、Redis工具类" class="headerlink" title="6、Redis工具类"></a>6、Redis工具类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Componentpublic class RedisUtil &#123;    @Resource    private RedisTemplate&lt;String, Object&gt; redisTemplate;    /**     * 判断key是否存在     * @param key 键     * @return true 存在 false不存在     */    public boolean hasKey(String key) &#123;        try &#123;            return Boolean.TRUE.equals(redisTemplate.hasKey(key));        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 普通缓存放入并设置时间     * @param key   键     * @param value 值     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期     * @return true成功 false 失败     */    public boolean set(String key, Object value, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125; else &#123;                set(key, value);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 普通缓存放入     * @param key   键     * @param value 值     * @return true成功 false失败     */    public boolean set(String key, Object value) &#123;        try &#123;            redisTemplate.opsForValue().set(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于互联网来说，只要你系统的接口暴露在外网，就避免不了接口安全问题。如果你的接口在外网裸奔，只要让黑客知道接口的地址和参数就可以调用，那简直就是灾难。&lt;/p&gt;
&lt;p&gt;举个例子：你的网站用户注册的时候，需要填写手机号，发送手机验证码，如果这个发送验证码的接口没有经过特殊安全处</summary>
      
    
    
    
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="接口" scheme="https://andy-whb-cn.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>架构方案：微服务设计</title>
    <link href="https://andy-whb-cn.github.io/2024/08/22/%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%EF%BC%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>https://andy-whb-cn.github.io/2024/08/22/%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%EF%BC%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-08-22T08:33:34.000Z</published>
    <updated>2024-09-03T00:44:02.286Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/08/29/pKwxN5QZA1cvhTo.png" alt="image.png"></p><p>微服务API网关模式链接：<a href="https://microservices.io/patterns/apigateway.html">https://microservices.io/patterns/apigateway.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/29/pKwxN5QZA1cvhTo.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;微服务API网关模式链接：&lt;a href=&quot;https://microservices.io/patt</summary>
      
    
    
    
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="java" scheme="https://andy-whb-cn.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>前端：IFrame自适应高度</title>
    <link href="https://andy-whb-cn.github.io/2024/04/30/%E5%89%8D%E7%AB%AF%EF%BC%9AIFrame-Auto-Resize/"/>
    <id>https://andy-whb-cn.github.io/2024/04/30/%E5%89%8D%E7%AB%AF%EF%BC%9AIFrame-Auto-Resize/</id>
    <published>2024-04-30T06:43:29.847Z</published>
    <updated>2024-09-03T00:45:45.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IFrame子页面自适应高度问题"><a href="#IFrame子页面自适应高度问题" class="headerlink" title="IFrame子页面自适应高度问题"></a>IFrame子页面自适应高度问题</h2><p>项目中经常会遇到需要通过IFrame集成子页面的情况，比较常见的问题如跨域、自适应页面高度等。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><blockquote><p>廖老师这里介绍得很全面，直接引用原文</p></blockquote><p><a href="https://liaoxuefeng.com/blogs/all/2024-02-25-auto-resize-iframe/">https://liaoxuefeng.com/blogs/all/2024-02-25-auto-resize-iframe/</a></p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><blockquote><p> 使用第三方库(Vue), <a href="https://github.com/davidjbradshaw/iframe-resizer">https://github.com/davidjbradshaw/iframe-resizer</a></p></blockquote><h4 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install iframe-resizer@latest -S</span><br></pre></td></tr></table></figure><h4 id="IFrame子窗口页面"><a href="#IFrame子窗口页面" class="headerlink" title="IFrame子窗口页面"></a>IFrame子窗口页面</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// directives/iframeResize.js</span><br><span class="line">import iframeResize from &#x27;iframe-resizer/js/iframeResizer&#x27;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  beforeMount: (el, &#123; value = &#123;&#125; &#125;) =&gt; &#123;</span><br><span class="line">    el.addEventListener(&#x27;load&#x27;, () =&gt; iframeResize(value, el))</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted: (el) =&gt; &#123;</span><br><span class="line">    el.iFrameResizer.removeListeners()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// index.js</span><br><span class="line">import iframeResize from &#x27;./iframeResize&#x27;</span><br><span class="line">app.directive(&#x27;resize&#x27;, iframeResize)</span><br></pre></td></tr></table></figure><h4 id="IFrame父窗口页面"><a href="#IFrame父窗口页面" class="headerlink" title="IFrame父窗口页面"></a>IFrame父窗口页面</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;iframe-wrapper&quot;&gt;</span><br><span class="line">    &lt;iframe</span><br><span class="line">      v-resize=&quot;iFrameResizer&quot;</span><br><span class="line">      id=&quot;Iframe&quot;</span><br><span class="line">      width=&quot;100%&quot;</span><br><span class="line">      :src=&quot;url&quot;</span><br><span class="line">      frameborder=&quot;0&quot;</span><br><span class="line">    &gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapGetters &#125; from &#x27;vuex&#x27;</span><br><span class="line">import &#123; jumpOtherSSO &#125; from &#x27;@/utils/sso/sso&#x27;</span><br><span class="line">import &#123; openFunc &#125; from &#x27;@/utils/util&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;AppCenter&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      iFrameResizer: &#123;</span><br><span class="line">        log: false,</span><br><span class="line">        heightCalculationMethod: &#x27;lowestElement&#x27;,</span><br><span class="line">        warningTimeout: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      ssoUrl: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    // this.updateIframeHeightFunc()</span><br><span class="line">    if (this.isUserLogin) &#123;</span><br><span class="line">      jumpOtherSSO(&#x27;appCenter&#x27;, &#123; page: 1 &#125;).then(res =&gt; &#123;</span><br><span class="line">        this.ssoUrl = res.data</span><br><span class="line">      &#125;).catch(() =&gt; &#123;</span><br><span class="line">        this.ssoUrl = this.$route.query.url</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, (e) =&gt; &#123;</span><br><span class="line">      if (e.data.appId) &#123;</span><br><span class="line">        const routeData = this.$router.resolve(&#123;</span><br><span class="line">          name: this.$routerNameMap.appCenterDetails,</span><br><span class="line">          query: &#123;</span><br><span class="line">            url: xxx`,</span><br><span class="line">            id: e.data.appId</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        openFunc(routeData.href)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([&#x27;isUserLogin&#x27;]),</span><br><span class="line">    url () &#123;</span><br><span class="line">      return !this.isUserLogin ? this.$route.query.url : this.ssoUrl</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateIframeHeightFunc () &#123;</span><br><span class="line">      const oIframe = document.getElementById(&#x27;Iframe&#x27;)</span><br><span class="line">      const deviceHeight = document.documentElement.clientHeight + 2360</span><br><span class="line">      oIframe.style.height = `$&#123;deviceHeight&#125;px`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.iframe-wrapper &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  border: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IFrame子页面自适应高度问题&quot;&gt;&lt;a href=&quot;#IFrame子页面自适应高度问题&quot; class=&quot;headerlink&quot; title=&quot;IFrame子页面自适应高度问题&quot;&gt;&lt;/a&gt;IFrame子页面自适应高度问题&lt;/h2&gt;&lt;p&gt;项目中经常会遇到需要通过IF</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://andy-whb-cn.github.io/tags/Vue/"/>
    
    <category term="前端" scheme="https://andy-whb-cn.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
