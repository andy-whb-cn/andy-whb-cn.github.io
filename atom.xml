<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andy&#39;s Note</title>
  
  
  <link href="https://andy-whb-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://andy-whb-cn.github.io/"/>
  <updated>2024-11-21T01:47:40.909Z</updated>
  <id>https://andy-whb-cn.github.io/</id>
  
  <author>
    <name>Andy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>探究CAP、PACELC、BASE理论</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E6%8E%A2%E7%A9%B6CAP%E3%80%81PACELC%E3%80%81BASE%E7%90%86%E8%AE%BA/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E6%8E%A2%E7%A9%B6CAP%E3%80%81PACELC%E3%80%81BASE%E7%90%86%E8%AE%BA/</id>
    <published>2024-11-06T09:22:10.177Z</published>
    <updated>2024-11-21T01:47:40.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP 理论是由加州大学伯克利分校的 Eric Brewer 教授在 2000 年提出的，当时他在分布式计算原理研讨会（PODC）上提出了这一猜想。在 2002 年，经过 Seth Gilbert 和 Nancy Lynch 通过反证法从理论上证明了 CAP 猜想后，CAP 理论正式成为了分布式系统理论的基石之一。</p><p>这个理论即在一个分布式系统中，不可能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个条件。实际上在分布式环境下，必须选择P。因此，分布式系统理论不可能选择CA，只能选择CP或AP。</p><ul><li>C（一致性）：对于指定客户端而言，保证读操作能够返回最新的写操作结果。在分布式系统中，这意味着所有节点在同一时间具有相同的数据副本。</li><li>A（可用性）：非故障的节点在合理的时间内返回系统的正常响应(不是错误和超时的响应)。</li><li>P（分区容错性）：当系统中某个节点或网络分区出现后，整个系统仍然能对外提供满足一致性或可用性的服务(即，部分故障不影响整体使用)。</li></ul><p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，<strong>这是违背分布式系统设计的初衷的</strong>。单机数据库或共享存储数据库，满足ACID的事务特性，符合CA。</p><p>CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p><p>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如秒杀活动，可能前几秒你浏览商品的时候页面提示是有库存的，当选择完商品准备下单时，系统提示下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p><p>注：</p><ul><li>CAP关注的粒度是数据，并不是系统。系统可能即存在CP又存在AP。</li><li>CAP是忽略网络延迟的，网络延迟是客观存在的，分布式下完美的数据一致性实际是不存在的。</li><li>正常运行情况下，没有发生网络分区，不存在CP和AP的选择，可同时满足CA。</li><li>CAP中牺牲掉一个，并不意味着什么都不做，例如分区期间记录日志，以用于分区故障解决后，重新使得系统得到CA状态。</li></ul><h3 id="PACELC理论"><a href="#PACELC理论" class="headerlink" title="PACELC理论"></a>PACELC理论</h3><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h3&gt;&lt;p&gt;CAP 理论是由加州大学伯克利分校的 Eric Brewer 教授在 2000 年提出的，当时他在分布式计算原理研讨会（PODC）上</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84/</id>
    <published>2024-11-06T07:54:50.869Z</published>
    <updated>2024-11-06T08:26:40.957Z</updated>
    
    <content type="html"><![CDATA[<p>TOGAF&amp; Zaash<br>投顾服务体系</p><p>1、需求提不出来<br>2、厂商能力也不行</p><p>如何搞出业务架构，实现什么业务价值？资产配置的能力</p><p>应用架构（技术学习业务），各种学习，掌握。。资配体系研究清楚。</p><p>我们做的东西对业务的帮助有多大作用。</p><p>公司的投顾服务，投顾社区很挣钱，十月份一天收入20万？投顾社区做的是股票、ETF类的，场内的管理，场外基金需要资配的业务。。三大类资产配置模型，风险等级是中高低，做不同的资产配置模型，做动态的调整，资产配置的跟踪。。</p><p>1、业务理论的研究<br>2、资配的源代码的研究（各类指标怎么计算）</p><p>14%没有，20年资产增长了14倍，雪球一本书。。择时，择物，90%来自于资产配置。风险预警。</p><p>投顾平台、进入常态化建设，让开发承担</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TOGAF&amp;amp; Zaash&lt;br&gt;投顾服务体系&lt;/p&gt;
&lt;p&gt;1、需求提不出来&lt;br&gt;2、厂商能力也不行&lt;/p&gt;
&lt;p&gt;如何搞出业务架构，实现什么业务价值？资产配置的能力&lt;/p&gt;
&lt;p&gt;应用架构（技术学习业务），各种学习，掌握。。资配体系研究清楚。&lt;/p&gt;
&lt;p&gt;我们</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>探究架构理论的演进（领域驱动架构）</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%88%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%EF%BC%89/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%88%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%EF%BC%89/</id>
    <published>2024-11-06T03:23:04.498Z</published>
    <updated>2024-11-21T01:47:13.123Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>分层架构（Layered Architecture）</strong>：<ul><li>提出者：不详</li><li>提出时间：最早应用于1960年代的网络协议设计，软件架构中广泛应用则是后来随着软件工程的发展逐渐形成的。</li><li>特点：将软件系统划分为多个逻辑层，每一层具有特定的职责和功能。</li></ul></li><li><strong>MVC 架构</strong>：<ul><li>提出者：Trygve Reenskaug </li><li>提出时间：1979年</li><li>提出方式：用于解决桌面图形用户界面（GUI）的设计</li><li>特点：MVC 将应用程序分为三个主要部分，使得逻辑、数据和界面分开，便于管理和维护，在现代的web程序开发中被广泛应用。</li></ul></li><li><strong>EIC（Entity-Interface-Control）：</strong><ul><li>提出者：Ivar Jacobson</li><li>提出时间：1992年</li><li>特点：Robert C. Martin在做整洁架构演讲时，避免和其他概念混淆，将其调整为EBI（Entity-Boundary-Interacter，名词调整）。EBI模式相比MVC模式更加关注后端，两者可以融合，融合后就变成了View-Controller-Interacter-Entity。EBI 架构通过职责的封装将系统的变化控制在局部，最好是一个对象，符合单一职责原则。EBI的矩形边界为4，若修改为6，即可演进为2005年的六边形架构。</li></ul></li></ul><ul><li><strong>领域驱动设计（Domain-Driven Design, DDD）</strong>：<ul><li>提出者：埃里克·埃文斯（Eric Evans）</li><li>提出时间：2003年</li><li>著作：在《领域驱动设计》中引入分层架构，希望分离领域。这意味着该模式本身是作用在整个系统层次。</li><li>核心理念：重视将实际业务问题映射到软件设计中，以解决复杂业务场景带来的软件开发问题。</li></ul></li></ul><ul><li><strong>六边形架构（Hexagonal Architecture）</strong>：<ul><li>提出者：Alistair Cockburn </li><li>提出时间：2005年 </li><li>著作：Vaughn Vernon 在《实现领域驱动设计》一书中，将 Alistair Cockburn 提出的六边形架构（Haxagonal Architecture）引入到领域驱动设计中，并将其与限界上下文结合在一起，清晰地体现了它内部的视图。这一模式的引入，实际上代表着限界上下文在架构中的核心地位。限界上下文改变了系统架构的逻辑视图，领域层的抽取则意味着领域对设计的驱动力，二者的结合可以形成一种新的架构风格，既“<strong>领域驱动架构（Domain Driven Architecture）</strong>”</li><li>特点：基于EIC，几边形不是重点，重点是提出端口&amp;适配器的概念。</li><li>核心理念：将应用程序分为内六边形和外六边形两层，内六边形实现应用的核心业务逻辑。外六边形完成外部应用、基础资源等的交互和访问。</li></ul></li><li><strong>洋葱架构（Onion Architecture）</strong>：<ul><li>提出者：Jeffrey Palermo </li><li>提出时间：2008年 </li><li>特点：基于六边形架构，结合DDD对内层进一步划分，形成Adapters和Application Core，且明确了依赖方向。</li><li>核心理念：通过同心圆的方式将应用程序划分为多个层次，强调依赖关系向内指向领域模型。外层依赖于内层，内层不需要知道外层的情况。</li></ul></li><li><strong>CQRS（Command Query Responsibility Segregation）设计模式</strong>：<ul><li>提出者：Greg Young</li><li>提出时间：2010 年</li><li>特点：这种模式将系统中的命令（写入操作）和查询（读取操作）的职责分离开来。其核心理念来源于 Bertrand Meyer 的 CQS（Command Query Separation）设计模式，它建议将对象的方法分为两类：一类是改变对象状态但不返回任何内容的命令（Command），另一类是返回信息但不改变对象状态的查询（Query）。适用CQRS需要慎重考虑，对于只具有简单域的简单项目，其UI模型与域模型紧密联系的，使用CQRS会增加项目的复杂度和冗余度，无疑是过度设计。另外，对于数据量较少或者性能要求较低的项目实施CQRS模式不会带来显著的性能提升。</li><li>优点：<ul><li>可扩展性：CQRS 允许独立扩展读写操作，这在读写负载差异较大的系统中尤其有用</li><li>灵活性：命令和查询是分开的，因此可以独立优化数据存储和检索策略</li><li>可维护性：通过分离关注点来简化代码库，使得命令和查询不会相互干扰</li><li>安全性：可以对读写操作应用不同的安全机制，确保只有授权用户才能进行更改</li></ul></li><li>缺点：<ul><li>复杂性：需要管理命令模型和查询模型之间的数据流</li><li>学习曲线：不熟悉 CQRS 的开发人员在采用该模式时可能会面临重新学习的问题</li><li>最终一致性：可能会导致最终的一致性，即查询模型可能无法立即反映命令所做的最新更改</li></ul></li></ul></li><li><strong>ES(Event Sourcing) 设计模式</strong>:<ul><li>提出者：并没有一个明确的“提出者”，因为它是一个逐渐发展起来的概念。</li><li>提出时间：Event Sourcing 的概念与实现随着领域驱动设计（Domain-Driven Design, DDD）的流行而得到更广泛的关注。</li><li>适用场合：<ul><li>复杂业务逻辑：当应用程序的业务逻辑非常复杂，需要详细记录每个业务操作的历史时。</li><li>审计和合规性：需要能够追溯和审计业务操作的历史，以满足合规性要求。</li><li>分布式系统：在分布式系统中，事件 Sourcing 可以帮助保持不同服务之间的数据一致性</li><li>微服务架构：在微服务架构中，每个服务可以维护自己的事件日志，从而解耦服务并提高系统的可维护性。</li></ul></li><li>缺点：<ul><li>开发思维的转变：面向对象思维转变为基于事件的响应式编程思维</li><li>没有成熟完善的框架：没有一个大而一统的框架来实现 Event Sourcing 模式</li><li>事件结构的改变：业务的变化可能需要修改事件的结构，这可能会带来兼容性问题</li><li>领域模型角度设计系统：需要以领域模型为基础设计系统，而不是以数据库表为基础</li></ul></li><li>架构组件<ul><li>事件存储（Event Store）：事件被保存在一个不可变的、追加的、按时间顺序排列的存储库或数据存储中。</li><li>事件处理（Event Processor）：处理事件并更新系统状态。</li><li>事件消费者（Event Consumer）：消费事件并执行基于事件内容的逻辑</li></ul></li><li>ES的实现：<ul><li>事件存储：事件被保存在一个不可变的、追加的、按时间顺序排列的存储库或数据存储中。</li><li>事件重放：通过按时间顺序重放事件日志中的事件来重构应用程序的当前状态。</li><li>事件版本控制：随着服务的演变，事件的结构（模式）可以变化，需要实现事件版本控制策略以确保向后和向前兼容。</li></ul></li><li>关联参考：<strong>Revo</strong>，<strong>EventStoreDB</strong>，<strong>Axon Framework</strong>，<strong>Lagom</strong>， <strong>Apache Kafka</strong>，<strong>PostgreSQL</strong></li></ul></li><li><strong>整洁架构（Clean Architecture）</strong>：<ul><li>提出者：Robert C. Martin（Uncle Bob）</li><li>提出时间：2012年</li><li>著作：《整洁架构之道》</li><li>特点：整合EBI（Entity-Boundary-Interacter，Robert C. Martin基于EIC提出）、六边形架构、洋葱架构成为一个可以实际落地的架构。与洋葱架构相比，整洁架构将Application Services调整为Use Cases， Domain Services, Domain Model调整为Entities。整洁架构并没有带来突破性的概念或模式，但是它带澄清了概念、规则和模式，并构建了复杂应用并保持可维护性的标准套路。整洁架构适用于需要长期维护和频繁更新的复杂项目，如腾讯文档、VS Code 内核、低代码引擎等。对于业务逻辑简单、业务生命周期较短的项目，直接使用整洁架构可能会导致开发效率降低</li><li>核心理念：围绕独立的对象模型构建应用，内层定义接口，外层实现接口。依赖的方向指向圆心。</li></ul></li><li><strong>菱形架构（Rhombic Symmetric Architecture）</strong>：<ul><li>提出者：张逸</li><li>提出时间：2017年 </li><li>著作：《解构领域驱动设计》</li><li>网站：<a href="http://zhangyi.xyz/rhombic-symmetric-architecture/">http://zhangyi.xyz/rhombic-symmetric-architecture/</a></li><li>核心理念：结合了六边形架构、分层架构、整洁架构的知识，并结合了领域驱动设计的元模型，使其能够更好地运用到限界上下文的架构设计中。</li></ul></li></ul><ul><li><strong>清晰架构（Explicit Architecture）</strong><ul><li>提出者：Herberto Graca</li></ul><p> </p><ul><li>提出时间：2017年 </li><li>著作：《软件架构编年史》</li><li>特点：清晰架构融合了领域驱动设计（DDD）、六边形架构、洋葱架构、整洁架构和CQRS等概念。它强调明确的职责和依赖关系，将系统划分为不同的职责区域，并明确它们之间的交互方式和依赖关系。这种架构有助于减少代码的耦合度，提高系统的可维护性和可扩展性，适用于对可维护性、可测试性和可扩展性有高度要求的复杂应用程序。</li><li>优点：<ul><li>可维护性：分离核心业务逻辑与外部框架、数据库和 UI，修改测试各组件更容易。</li><li>模块化：分层使得代码库更易于维护和扩展。</li><li>独立性：业务逻辑与外部框架或库的独立性允许开发者替换或升级框架而不影响应用程序的核心功能。</li><li>测试覆盖率：鼓励编写隔离的单元测试，便于测试覆盖率和早期捕捉错误。</li><li>可扩展性：模块化设计简化了新功能的添加或现有功能的移除。</li></ul></li><li>缺点：<ul><li>过度工程：引入过多的复杂性，对于小型工程或原型项目不适用。</li><li>学习曲线：团队成员可能需要时间来理解和适应架构原则。</li><li>开发成本：清晰架构可能比传统方法需要更多的开发时间和工作量。</li><li>性能影响：通过接口和依赖注入实现松散耦合可能会引入轻微的性能影响。</li><li>灵活性：严格遵循架构原则有时可能限制灵活性和适应性。</li></ul></li></ul></li></ul><p>领域驱动架构理论发展演进路径图：<br><img src="https://s2.loli.net/2024/11/06/3giEet1f8InTHS9.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分层架构（Layered Architecture）&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;提出者：不详&lt;/li&gt;
&lt;li&gt;提出时间：最早应用于1960年代的网络协议设计，软件架构中广泛应用则是后来随着软件工程的发展逐渐形成的。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>探究KISS原则</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6KISS%E5%8E%9F%E5%88%99/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6KISS%E5%8E%9F%E5%88%99/</id>
    <published>2024-11-06T02:34:35.950Z</published>
    <updated>2024-11-21T01:46:14.971Z</updated>
    
    <content type="html"><![CDATA[<p>KISS 原则，即 “Keep It Simple and Stupid” 或 “Keep It Simple, Stupid”，翻译成中文就是：尽量保持简单，有时也被称作懒人法则，设计理念：简单就是美。</p><p>KISS原则的来源众说纷纭：</p><ul><li>追溯到14世纪英格兰的逻辑学家<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E5%A5%A5%E5%8D%A1%E5%A7%86%E7%9A%84%E5%A8%81%E5%BB%89&rsv_pq=d1021d2b00014d49&oq=KISS%20%E5%8E%9F%E5%88%99&rsv_t=a4149hqv2F95Z7Sec39BV1HZoeDDcESCgNOIJaxNofoMDE5I1roJDJMd5o4&tn=baidu&ie=utf-8">奥卡姆的威廉</a>提出的“<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80%E5%8E%9F%E7%90%86&rsv_pq=d1021d2b00014d49&oq=KISS%20%E5%8E%9F%E5%88%99&rsv_t=a4149hqv2F95Z7Sec39BV1HZoeDDcESCgNOIJaxNofoMDE5I1roJDJMd5o4&tn=baidu&ie=utf-8">奥卡姆剃刀原理</a>”，即“如无必要，勿增实体”，强调简单有效‌。</li><li>美国海军飞行器工程师凯利·约翰逊（Kelly Johnson）。</li><li>David Mamet（<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E5%A4%A7%E5%8D%AB%C2%B7%E9%A9%AC%E9%BA%A6%E7%89%B9&rsv_pq=d1021d2b00014d49&oq=KISS%20%E5%8E%9F%E5%88%99&rsv_t=a4149hqv2F95Z7Sec39BV1HZoeDDcESCgNOIJaxNofoMDE5I1roJDJMd5o4&tn=baidu&ie=utf-8">大卫·马麦特</a>）的电影理论。</li></ul><p>Unix和C语言的发明者Dennis Ritchie（丹尼斯·里奇）在1969年将Unix的设计原则定为”保持简单和直接”（Keep it simple stupid），也即KISS原则。</p><p>KISS 原则在软件开发中主张在设计和实现过程中追求简单性，避免不必要的复杂性，以提高代码的可读性、可维护性和可扩展性，如少用复杂的算法、避免冗余和重复代码、遵循标准和惯例。</p><p>KISS原则的优点在于提高可读性和可维护性，提高开发效率，降低成本，但过度的简化又可能会限制创新，在实际应用中需要做好平衡。</p><h2 id="什么是代码简单"><a href="#什么是代码简单" class="headerlink" title="什么是代码简单"></a>什么是代码简单</h2><p>并不是代码行数越少就越“简单”，还要考虑<strong>逻辑复杂度、实现难度、代码的可读性</strong>等。</p><p>&#x2F;&#x2F; 第一种实现方式: 使用正则表达式<br>public boolean isValidIpAddressV1(String ipAddress) {<br>  if (StringUtils.isBlank(ipAddress)) return false;  String regex &#x3D; “^(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)$”;  return ipAddress.matches(regex);<br>}<br>&#x2F;&#x2F; 第二种实现方式: 使用现成的工具类<br>public boolean isValidIpAddressV2(String ipAddress) {<br>  if (StringUtils.isBlank(ipAddress)) return false;  String[] ipUnits &#x3D; StringUtils.split(ipAddress, ‘.’);  if (ipUnits.length !&#x3D; 4) {    return false;  }  for (int i &#x3D; 0; i &lt; 4; ++i) {    int ipUnitIntValue;    try {      ipUnitIntValue &#x3D; Integer.parseInt(ipUnits[i]);    } catch (NumberFormatException e) {      return false;    }    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {      return false;    }    if (i &#x3D;&#x3D; 0 &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) {      return false;    }  }  return true;<br>}<br>&#x2F;&#x2F; 第一种实现方式: 使用正则表达式<br>public boolean isValidIpAddressV1(String ipAddress) {<br>  if (StringUtils.isBlank(ipAddress)) return false;  String regex &#x3D; “^(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)$”;  return ipAddress.matches(regex);<br>}<br>&#x2F;&#x2F; 第二种实现方式: 使用现成的工具类<br>public boolean isValidIpAddressV2(String ipAddress) {<br>  if (StringUtils.isBlank(ipAddress)) return false;  String[] ipUnits &#x3D; StringUtils.split(ipAddress, ‘.’);  if (ipUnits.length !&#x3D; 4) {    return false;  }  for (int i &#x3D; 0; i &lt; 4; ++i) {    int ipUnitIntValue;    try {      ipUnitIntValue &#x3D; Integer.parseInt(ipUnits[i]);    } catch (NumberFormatException e) {      return false;    }    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {      return false;    }    if (i &#x3D;&#x3D; 0 &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) {      return false;    }  }  return true;<br>}<br>&#x2F;&#x2F; 第三种实现方式: 不使用任何工具类<br>public boolean isValidIpAddressV3(String ipAddress) {<br>  char[] ipChars &#x3D; ipAddress.toCharArray();  int length &#x3D; ipChars.length;  int ipUnitIntValue &#x3D; -1;  boolean isFirstUnit &#x3D; true;  int unitsCount &#x3D; 0;  for (int i &#x3D; 0; i &lt; length; ++i) {    char c &#x3D; ipChars[i];    if (c &#x3D;&#x3D; ‘.’) {      if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;      if (isFirstUnit &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) return false;      if (isFirstUnit) isFirstUnit &#x3D; false;      ipUnitIntValue &#x3D; -1;      unitsCount++;      continue;    }    if (c &lt; ‘0’ || c &gt; ‘9’) {      return false;    }    if (ipUnitIntValue &#x3D;&#x3D; -1) ipUnitIntValue &#x3D; 0;    ipUnitIntValue &#x3D; ipUnitIntValue * 10 + (c - ‘0’);  }  if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;  if (unitsCount !&#x3D; 3) return false;  return true;<br>}</p><p>上面这段检查输入的字符串 ipAddress 是否是合法的 IP 地址的代码，第一种实现方式利用的是正则表达式，第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。</p><ul><li>第一种方式不符合KISS原则，虽然代码行数最少，看似最简单，实际上却很复杂，因为它使用了正则表达式，复杂的正则表达式会导致<strong>代码的可读性和可维护性变差</strong></li><li>第三种方式不符合KISS原则，第三种虽然和第二种代码行数了类似，但实现起来要比第二种更加有难度，更容易写出 bug，也就是逻辑复杂度较高</li></ul><p>只有第二种方式使用了现成的工具类，代码逻辑不复杂，易读也易维护，满足KISS原子。但即使这样也需要看适配场景，如果本身问题比较复杂，那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，但能解决这样复杂的问题，也满足KISS原则。例如用<a href="https://so.csdn.net/so/search?q=KMP%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">KMP算法</a>解决字符串匹配问题，<strong>本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则</strong></p><h2 id="如何写出满足KISS的代码"><a href="#如何写出满足KISS的代码" class="headerlink" title="如何写出满足KISS的代码"></a>如何写出满足KISS的代码</h2><p>KISS原则其实本来就比较主观，不过还是有一些验证方式的：</p><ol><li><strong>不要使用同事可能不懂的技术来实现代码</strong>。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。如果想用，培训一下大家。</li><li><strong>不要重复造轮子</strong>，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</li><li><strong>不要过度优化</strong>。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;KISS 原则，即 “Keep It Simple and Stupid” 或 “Keep It Simple, Stupid”，翻译成中文就是：尽量保持简单，有时也被称作懒人法则，设计理念：简单就是美。&lt;/p&gt;
&lt;p&gt;KISS原则的来源众说纷纭：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式之六大设计原则（SOLID原则）</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88SOLID%E5%8E%9F%E5%88%99%EF%BC%89/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88SOLID%E5%8E%9F%E5%88%99%EF%BC%89/</id>
    <published>2024-11-06T01:38:49.403Z</published>
    <updated>2024-11-21T01:47:23.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会有六大原则"><a href="#为什么会有六大原则" class="headerlink" title="为什么会有六大原则"></a>为什么会有六大原则</h2><p>面向过程编程到面向对象编程是软件设计的一大步，封装、继承、多态是面向对象的三大特征，本来这些都是面向对象的好处，但是一旦有人滥用了，就有了坏味道，代码的坏味道导致系统的可维护性和复用性等变低，所以面向对象需要遵循一些原则make the code better。如：一个servlet干所有事情可以改为MVC，每一层的类做自己负责的事情，遵循单一职责原则。</p><p>为了提高系统的可维护性、复用性和高内聚低耦合等， 2000 年Robert C. Martin（也被称为 Uncle Bob）在他的论文《设计原则和设计模式》中首次提出了SOLID 原则（注：SOLID 这个缩写是后来由 Michael Feathers 概括确定的）。因为设计模式是面向对象实践出来的经验，所以这六大原则既是面向对象的六大原则，也是设计模式的六大原则。</p><p>六大设计原则主要是指：</p><ul><li>单一职责原则（Single Responsibility Principle）；</li><li>开闭原则（Open Closed Principle）；</li><li>里氏替换原则（Liskov Substitution Principle）；</li><li>迪米特法则（Law of Demeter），又叫“最少知道法则”；</li><li>接口隔离原则（Interface Segregation Principle）；</li><li>依赖倒置原则（Dependence Inversion Principle）。</li></ul><p>把这 6 个原则的首字母（里氏替换原则和迪米特法则的首字母重复，只取一个）联合起来就是：SOLID（稳定的），其代表的含义也就是把这 6 个原则结合使用的好处：建立稳定、灵活、健壮的设计。</p><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>单一职责原则的定义是：应该有且仅有一个原因引起类的变更。</p><p>没错，单一职责原则就这一句话，不懂没关系，我们举个例子。</p><p>我们以打电话为例，电话通话的时候有 4 个过程发生：拨号、通话、回应、挂机。那我们写一个接口，类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/6810e906066044299403283215465453.jpeg"></p><p>代码为：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/5685c98b7d7b4d8890e11fe733d51de1.jpeg"></p><p>我们看这个接口有没有问题？相信大部分同学会觉得没问题，因为平常我们就是这么写的。没错，这个接口接近于完美，注意，是“接近”。单一职责原则要求一个接口或一个类只能有一个原因引起变化，也就是一个接口或者类只能有一个职责，它就负责一件事情，看看上面的接口只负责一件事情吗？明显不是。</p><p>IPhone这个接口包含了两个职责：协议管理和数据传送。dial 和 hangup 这两个方法实现的是协议管理，分别负责拨号接通和挂机，chat 方法实现的是数据传送。不管是协议接通的变化还是输出传送的变化，都会引起这个接口的变化。所以，IPhone这个接口并不符合单一职责原则。若要让IPhone满足单一职责原则，我们就要对其进行拆分，拆分后的类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/d7f21da12e1c41dab697d14bca62731a.jpeg"></p><p>这样设计就完美了，一个类实现了两个接口，把两个职责融合在一个类中。你会觉得这个Phone有两个原因引起变化了啊，是的，但是别忘了我们是面向接口编程，我们对外公布的是接口而不是实现类。</p><p>另外，单一职责原则不仅适用于接口和类，也适用于方法。一个方法尽可能只做一件事，比如一个修改用户密码的方法，不要把这个方法放到“修改用户信息”方法中。</p><p><strong>单一职责的好处</strong></p><ol><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性高，复杂性降低，可读性自然就提高了；</li><li>可维护性提高，可读性提高了，那自然更容易维护了；</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ol><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：</p><ol><li>代码共享，减少创建类的工作量，每个子类都拥有父类的属性和方法；</li><li>提高代码的重用性；</li><li>子类可以形似父类，但又异于父类；</li><li>提高代码的可扩展性；</li><li>提高产品或项目的开放性。</li></ol><p>有优点就必然存在缺点：</p><ol><li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li><li>降低代码的灵活性。子类会多一些父类的约束。</li><li>增强了耦合性。当父类的常量、变量、方法被修改时，需要考虑子类的修改。</li></ol><p>为了让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦，引入了里氏替换原则（LSP）。</p><p>历史替换原则最正宗的定义是：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代替o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。</p><p>通俗点讲，就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。</p><p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。</p><p><strong>1. 子类必须完全实现父类的方法。</strong></p><p>我们在做系统设计的时候，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里就已经使用了里氏替换原则。我们以打CS举例，来描述一下里面用到的枪。类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/cf96e9a0a749461bb43a6a8545bbf49d.jpeg"></p><p>枪的主要职责是射击，如何射击在各个具体的子类中实现，在士兵类Soldier中定义了一个方法 killEnemy，使用枪来kill敌人，具体用什么枪，调用的时候才知道。</p><p>AbstractGun类源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/afb508c631f540d5a7982f6d9661d4f7.jpeg"></p><p>手枪、步枪、机枪的实现类代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/bfe5b661ca7e4861898a9217679f7b51.jpeg"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/39687c32557a4a37bc339cb67bee604f.jpeg"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/393cda22234d48378343ae0fe11afd86.jpeg"></p><p>士兵类的源码为：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/5138365d7c964433a5adca31239d67d5.jpeg"></p><p>注意，士兵类的killEnemy方法中使用的gun是抽象的，具体时间什么枪需要由客户端（Client）调用Soldier的构造方法传参确定。</p><p>客户端Client源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/3de2a33f298c4df4a23e3709d6c49653.jpeg"></p><p><strong>注意：</strong>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</p><p><strong>2. 孩子类可以有自己的个性。</strong></p><p>孩子类当然可以有自己的属性和方法了，也正因如此，在子类出现的地方，父类未必就可以代替。</p><p>还是以上面的关于枪支的例子为例，步枪有 AK47、SKS狙击步枪等型号，把这两个型号的枪引入后的Rifle的子类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/34147a3e339841d0ac91b0647819f586.jpeg"></p><p>SKS狙击步枪可以配一个8倍镜进行远程瞄准，相对于父类步枪，这就是SKS的个性。源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/3dbecb28d0f741e382e09a916d8511a9.jpeg"></p><p>狙击手Spinner类的源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/4de8a11686974fe89317885ea8e99c89.jpeg"></p><p>狙击手因为只能使用狙击枪，所以，狙击手类中持有的枪只能是狙击类型的，如果换成父类步枪Rifle，则传递进来的可能就不是狙击枪，而是AK47了，而AK47是没有zoomOut方法的，所以肯定是不行的。这也验证了里氏替换原则的那一句话：有子类出现的地方，父类未必就可以代替。</p><p><strong>3. 覆盖或实现父类的方法时，输入参数可以被放大。</strong></p><p>来看一个例子，我们先定义一个Father类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/a930fc9e9ca14f78a8b5750d29059a43.jpeg"></p><p>然后定义一个子类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/ecf2fe6ce1a34cdea67f8f3ebc469826.jpeg"></p><p>子类方法与父类方法同名，但又不是覆写父类的方法。你加个@Override看看，会报错的。像这种方法名相同，方法参数不同，叫做方法的重载。你可能会有疑问：重载不是只能在当前类内部重载吗？因为Son继承了Father，Son就有了Father的所有属性和方法，自然就有了Father的doSomething这个方法，所以，这里就构成了重载。</p><p>接下来看场景类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/af7cf9aeabc44e99b902eaefc2f6ac3d.jpeg"></p><p>根据里氏替换原则，父类出现的地方子类就可以出现，我们把上面的父类替换为子类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/3f828240826f496cac9a7654fe039c4d.jpeg"></p><p>我们发现运行结果是一样的。为什么会这样呢？因为子类Son继承了Father，就拥有了doSomething(HashMap map)这个方法，不过由于Son没有重写这个方法，当调用Son的这个方法的时候，就会自动调用其父类的这个方法。所以两次的结果是一致的。</p><p>举个反例，如果父类的输入参数类型大于子类的输入参数类型，会出现什么问题呢？我们直接看代码执行结果即可轻松看出问题：</p><p>扩大父类方法入参：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/b8be47040d7343d69d3c60997f2b26d9.jpeg"></p><p>缩小子类方法入参：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/1392fe6b3fd44ae09726bd05a415dd61.jpeg"></p><p>场景类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/af7cf9aeabc44e99b902eaefc2f6ac3d.jpeg"></p><p>根据里氏替换原则，有父类的地方就可以有子类，我们把Father替换为Son看看结果：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/4aeeb87649334270b2cee7e8d3f91d52.jpeg"></p><p>两次运行结果不一致，违反了里氏替换原则，所以<strong>子类中方法的入参类型必须与父类中被覆写的方法的入参类型相同或更宽松。</strong></p><p><strong>4. 覆盖或实现父类的方法时，输出结果可以被缩小。</strong></p><p>这句话的意思就是，父类的一个方法的返回值是类型T，子类的相同方法（重载或重写）的返回值为类型S，那么里氏替换原则就要求S必须小于等于T。为什么呢？因为重写父类方法，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这时重写父类方法的要求。</p><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则在Java语言中的表现是：</p><ol><li><p>模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的；</p></li><li><p>接口或抽象类不依赖于实现类；</p></li><li><p>实现类依赖接口或抽象类。</p></li></ol><p>说白了，就是“面向接口编程”。</p><p><strong>依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</strong></p><p>我们以汽车和司机举例，画出类图：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/52a08650b180439eabe64d5afbcdecca.jpeg"></p><p>奔驰车源代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/e2d3f8c0047a49b5aef5a2e95cd423c0.jpeg"></p><p>司机源代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/ed0cef80aba64003a836de4e0fe08022.jpeg"></p><p>客户端源代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/ef07fff9b440419787e84b840fbe3f67.jpeg"></p><p>通过以上的代码，完成了司机开动奔驰车的场景。可以看到，这个场景并没有引用依赖倒置原则，司机Driver类直接依赖奔驰车Benz类，这样会有什么隐患呢？试想，后期业务变动，司机又买了一辆宝马车，源代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/6e89b3ebb4604134996ba99c8ffab86e.jpeg"></p><p>由于司机现在只有开奔驰的方法，所以他是开不了宝马的。一个拿有C驾照的司机能开奔驰，不能开宝马？太不合理了。所以，这就暴露出上面的设计问题了。我们对上面的功能重新设计，首先新建两个接口。</p><p>汽车接口ICar：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/4b52a06450b546b0ba682616c9160070.jpeg"></p><p>司机接口IDriver：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/eccfbaa6dc5b483a948c9bc2db310046.jpeg"></p><p>IDriver中，通过传入ICar接口实现了抽象之间的依赖关系。</p><p>接下来创建汽车实现类：奔驰和宝马。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/dbb2aacc12634babb47df3d8d1d32a78.jpeg"></p><p>然后创建司机实现类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/7af22396fdf74c9cba95e8c181ce8b46.jpeg"></p><p>最后是场景类调用：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/57bb22eb40674d109c3c3def61503bf8.jpeg"></p><p>Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，driver的表面类型是IDriver，benz的表面类型是ICar。</p><p><strong>依赖倒置原则的使用建议：</strong></p><p>（1）每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。</p><p>（2）变量的表面类型尽量是接口或抽象类。</p><p>（3）任何类都不应该从具体类派生。</p><p>（4）尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。</p><p>（5）结合里氏替换原则使用。</p><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>接口隔离原则就是客户端不应该依赖它不需要的接口，或者说类间的依赖关系应该建立在最小的接口上。</p><p>我们以搜索美女为例，设计了如下的类图：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/a070000089be46a7afb265965b8c04bd.jpeg"></p><p>源代码如下。美女及其实现类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/1df3a1da1a6b406e877f44297a7d9e6b.jpeg"></p><p>搜索程序及其子类源代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/aac49cb7747e43c5b076e561f705c9b5.jpeg"></p><p>最后是场景调用类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/96da4106ece2413bb773c79738850526.jpeg"></p><p>上面实现了一个搜索美女的小程序。我们想象这个程序有没有问题？IPettyGirl接口是否做到了最优化？并没有。</p><p>每个人的审美观不一样，张三认为颜值高就是美女，即使身材和气质一般；李四认为身材好就行，不在乎颜值和气质；而王五则认为颜值和身材都是外在，只要有气质，那就是美女。这时，IPettyGirl接口就满足不了了，因为IPettyGirl的要求是颜值、身材、气质兼具才是美女。所以为了满足各种人的口味，我们需要重新设计接口的结构。把IPettyGirl拆分为3个接口，分别表示颜值高、身材好、气质佳。修改后的类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/219d0b8796bd4d28b9e87e78eb711bc6.jpeg"></p><p>源代码如下。美女及其实现类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/4b84096823ab4be78c68924ac107e27a.jpeg"></p><p>搜索类及其子类如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/67e7741ccd774bc686c20868f406943e.jpeg"></p><p>通过重构以后，不管以后需要颜值美女，还是需要身材美女，抑或气质美女，都可以保持接口的稳定性。</p><p>以上把一个臃肿的接口拆分为三个独立的接口所依赖的原则就是接口隔离原则。接口隔离原则是对接口进行规范约束。</p><h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>迪米特法则（LoD）也叫最少知道法则：一个对象应该对其他对象有最少的了解。</p><p><strong>1.只和朋友交流</strong></p><p>迪米特法则还有一个英文解释是：Only talk to your immediate friends(只和直接的朋友交流)。每个对象都必然会与其他对象耦合，两个对象的耦合就成为朋友关系。下面我们通过体育课老师让班长清点女生人数为例讲解。</p><p>首先设计程序的类图：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/90f8ece6d2474a18b29ceaecd8d5c62e.jpeg"></p><p>编码实现：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/54ac9b91b6854e0299310d39ab9bf28c.jpeg"></p><p>场景类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/5abae5c4c5814a0dbd247ef67a9ad2cb.jpeg"></p><p>程序开发完了，我们首先看下Teacher类有几个朋友类，首先要知道朋友类的定义：<strong>出现在成员变量、方法的输入输出参数中的类称为成员朋友类</strong>。所以Teacher类只有一个GroupLeader朋友类。根据迪米特法则，一个类只能和朋友类交流，上面的Teacher类内部却与非朋友类Girl发生了交流，这就不符合迪米特法则，破坏了程序的健壮性。</p><p>我们对类图做下修改：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/b4a45d9bdda54c3980abd5b330516733.jpeg"></p><p>修改后的代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/13f159f373474e79849ba53f608a9700.jpeg"></p><p>再看场景类调用：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/209ada6ba7c84f4fbc60f80a39754b10.jpeg"></p><p>总之，就是类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象。</p><p><strong>2.朋友间也是有距离的</strong></p><p>我们在开发中经常有这种场景：调用一个或多个类，先执行第一个方法，然后是第二个方法，根据返回结果再看是否执行第三个方法。我们以安装某个软件为例，其类图为：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/65afe1e984eb4867973e94205e5b5860.jpeg"></p><p>代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/1fe35f98ebeb420187d7dfb80598b781.jpeg"></p><p>场景类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/0a18f2862cfd4a9f8b5ed996e10aaf66.jpeg"></p><p>程序很简单，但也存在一些问题：Wizard类把太多方法暴露给InstallSoftware类了，两者的朋友关系太亲密了，耦合关系变的异常牢固，如果要把Wizard中first方法的返回值改为Boolean类型，则要同时修改InstallSoftware类，增加了风险。因此，这种耦合是不合适的，我们需要对其优化。重构后的类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/f5cebb627fb74b3892742e168adf2d95.jpeg"></p><p>代码如下。导向类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/14b48eb83a7545748e1ea60984f869b7.jpeg"></p><p>我们把安装步骤改为私有方法，只向外暴露一个安装方法，这样，即使修改步骤的逻辑，也只是对Wizard自己有影响，只需要修改自己的安装方法逻辑即可，其他类不会受到影响。</p><p>安装类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/fa576b9fdb68431099fa505d0072234d.jpeg"></p><p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。所以，我们开发中尽量不要对外公布太多public方法和非静态的public变量，尽量内敛。</p><p><strong>3.是自己的就是自己的</strong></p><p>在实际开发中经常会出现这样一种情况：一个方法放在吧本类中也可以，放在其他类中也没有错。那这时，我们只需要坚持一个原则：<strong>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</strong>。</p><p>总之，迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提升上去。</p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>开闭原则是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。也就是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。我们以书店销售书籍为例来说明什么是开闭原则。</p><p>其类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/0a2b016371664bbcb0ef5f0420e25675.jpeg"></p><p>书籍及其实现类代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/76408358790c4c928dff62961fad5677.jpeg"></p><p>书店类代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/89cdaecdcae541978c3fd7941bbfa107.jpeg"></p><p>项目开发完了，开始正常卖书了。假如到了双十一，要搞打折活动，上面的功能是不支持的，所以需要修改程序。有三种方法可以解决这个问题：</p><p>（1）修改接口</p><p>在IBook接口里新增getOffPrice()方法，专门用于进行打折，所有的实现类都实现该方法。但这样修改的后果就是，实现类NovelBook要修改，书店类BookStore中的main方法也要修改，同时，IBook作为接口应该是稳定且可靠的，不应该经常发生变化，因此，该方案被否定。</p><p>（2）修改实现类</p><p>修改NovelBook类中的方法，直接在getPrice()方法中实现打折处理，这个方法可以是可以，但如果采购书籍的人员要看价格怎么办，由于该方法已经进行了打折处理，因此采购人员看到的也是打折后的价格，会因信息不对称出现决策失误的情况。因此，该方案也不是一个最优的方案。</p><p>（3）通过扩展实现变化</p><p>增加一个子类OffNovelBook，覆写getPrice方法，高层次的模块（也就是BookStore中static静态块中）通过OffNovelBook类产生新的对象，完成业务变化对系统的最小开发。这样修改也少，风险也小，修改后的类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/6f0cab63e1c842b097c24f1f9656ade8.jpeg"></p><p>OffNovelBook源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/88082d2b058146f8a21d213bf5f754a5.jpeg"></p><p>然后修改BookStore中的书籍类为OffNovelBook：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/987451e8f45045818a8ed15e6abe97db.jpeg"></p><p><strong>为什么要用开闭原则</strong></p><ol><li><p>开闭原则非常著名，只要是做面向对象编程的，在开发时都会提及开闭原则。</p></li><li><p>开闭原则是最基础的一个原则，前面介绍的5个原则都是开闭原则的具体形态，而开闭原则才是其精神领袖。</p></li><li><p>开闭原则提高了复用性，以及可维护性。</p></li></ol><h1 id="总结六大设计原则"><a href="#总结六大设计原则" class="headerlink" title="总结六大设计原则"></a>总结六大设计原则</h1><ol><li><p>单一职责原则：一个类或接口只承担一个职责。</p></li><li><p>里氏替换原则：在继承类时，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。</p></li><li><p>依赖倒置原则：高层模块不应该依赖于低层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。</p></li><li><p>接口隔离原则：不要对外暴露没有实际意义的接口。</p></li><li><p>迪米特法则：尽量减少对象之间的交互，从而减小类之间的耦合。</p></li><li><p>开闭原则：对软件实体的改动，最好用扩展而非修改的方式。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>六大设计原则虽好，但要熟练掌握和应用他们还是不那么容易的，需要在熟记于心的同时在编码工作中不断的实践和积累经验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么会有六大原则&quot;&gt;&lt;a href=&quot;#为什么会有六大原则&quot; class=&quot;headerlink&quot; title=&quot;为什么会有六大原则&quot;&gt;&lt;/a&gt;为什么会有六大原则&lt;/h2&gt;&lt;p&gt;面向过程编程到面向对象编程是软件设计的一大步，封装、继承、多态是面向对象的三大特征，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>探究DRY、YANGI、三次法则</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6DRY%E3%80%81YANGI%E3%80%81%E4%B8%89%E6%AC%A1%E6%B3%95%E5%88%99/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6DRY%E3%80%81YANGI%E3%80%81%E4%B8%89%E6%AC%A1%E6%B3%95%E5%88%99/</id>
    <published>2024-11-06T01:19:05.933Z</published>
    <updated>2024-11-21T01:46:47.976Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发工作中，我们常常会遇到一些使得代码变得冗余、复杂甚至难以维护的情况。为了应对这些问题，软件工程界提出了许多原则和方法来指导我们的编程实践。</p><p>其中，DRY原则、YAGNI原则和三次法则是我们编程过程中常常需要用到的三个重要原则。那么，这些原则具体是什么含义，又应该如何在实际开发中运用呢？下面就让我们一起来探讨。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-1242469/7ede31094a7f06f9f608f81947fc46a4.png?imageView2/2/w/591"></p><h4 id="DRY原则：追求高效，摒弃重复"><a href="#DRY原则：追求高效，摒弃重复" class="headerlink" title="DRY原则：追求高效，摒弃重复"></a>DRY原则：追求高效，摒弃重复</h4><p>软件工程名著《<a href="http://en.wikipedia.org/wiki/The_Pragmatic_Programmer">The Pragmatic Programmer</a> | <a href="http://www.amazon.cn/gp/product/B005UP9PJM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&tag=vastwork-23&linkCode=as2&camp=536&creative=3200&creativeASIN=B005UP9PJM" title="程序员修炼之道:从小工到专家">程序员修炼之道</a>:从小工到专家》首先提出这一原则。</p><p>DRY，全称”Don’t Repeat Yourself”，翻译为中文就是”不要重复自己”，这个原则有时也称作“一次且仅一次“原则（Once and Only Once)。这是一种追求高效、优雅的编程原则。根据DRY原则，任何形式的信息重复都应当被消除。在实际的编程中，如果同一个逻辑出现在两个或更多的地方，那么我们就需要考虑将这部分逻辑抽象出来，避免重复代码。</p><p>DRY原则的优点在于，它能提高代码的可读性和可维护性，降低代码的复杂度，从而提高整个软件的质量。比如，当我们需要修改某一逻辑时，只需要在一个地方修改即可，无需在多个地方做同样的修改，大大提高了代码的维护性。</p><h4 id="YAGNI原则：聚焦现在，摒弃过度设计"><a href="#YAGNI原则：聚焦现在，摒弃过度设计" class="headerlink" title="YAGNI原则：聚焦现在，摒弃过度设计"></a>YAGNI原则：聚焦现在，摒弃过度设计</h4><p>这是<a href="http://en.wikipedia.org/wiki/Extreme_programming">“极限编程”</a>提倡的原则,  指导思想，就是尽可能快、尽可能简单地让软件运行起来（do the simplest thing that could possibly work）。</p><p>YAGNI，全称”You Aren’t Gonna Need It”，翻译为中文就是”你不会需要它”。这个原则鼓励我们抵制过度设计的诱惑，只关注当前真正需要的功能，而不是那些”可能”在未来会用到的功能。</p><p>在软件开发过程中，我们常常会受到”可能会用到”这种假设的诱惑，这导致我们花费大量的时间和精力去实现那些实际上并不需要的功能，而这些功能反而增加了代码的复杂度，降低了软件的可维护性。因此，YAGNI原则告诉我们，除非确定需要某个功能，否则就不要去实现它。</p><p>DRY原则和YAGNI原则并非完全兼容。前者追求”抽象化”，要求找到通用的解决方法；后者追求”快和省”，意味着不要把精力放在抽象化上面，因为很可能”你不会需要它”。于是就有了第三个原则”三次法则“。</p><h4 id="三次法则：提炼抽象，追求优雅"><a href="#三次法则：提炼抽象，追求优雅" class="headerlink" title="三次法则：提炼抽象，追求优雅"></a>三次法则：提炼抽象，追求优雅</h4><p><a href="http://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">Rule of three</a> 称为”三次原则”，指的是当某个功能第三次出现时，才进行”抽象化”。这是软件开发大家<a href="http://en.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a>在《Refactoring | <a href="http://www.amazon.cn/gp/product/B003BY6PLK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&tag=vastwork-23&linkCode=as2&camp=536&creative=3200&creativeASIN=B003BY6PLK" title="重构:改善既有代码的设计">重构</a>》一书中提出的。</p><p>三次法则，是一种关于何时应该重构或抽象代码的原则。它告诉我们，如果你做了一次相同的事情，那就继续；如果你做了两次相同的事情，那就稍微有点耐心；如果你做了三次相同的事情，那么你应该重构或抽象它。</p><p>实际上，这个法则是DRY原则的一个具体实践。当我们在代码中发现重复的逻辑时，可能是时候考虑进行抽象了。这样，当我们需要修改这部分逻辑时，只需要在一个地方进行修改即可，而不需要在多个地方进行相同的修改。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>软件开发是一项复杂的工作，需要我们不断学习和实践。DRY原则、YAGNI原则和三次法则，都是我们在编程实践中需要掌握的重要原则。通过运用这些原则，我们可以写出更高质量的代码，构建出更优秀的软件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发工作中，我们常常会遇到一些使得代码变得冗余、复杂甚至难以维护的情况。为了应对这些问题，软件工程界提出了许多原则和方法来指导我们的编程实践。&lt;/p&gt;
&lt;p&gt;其中，DRY原则、YAGNI原则和三次法则是我们编程过程中常常需要用到的三个重要原则。那么，这些原则具体是什么</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>安全框架 Spring Security vs Shiro</title>
    <link href="https://andy-whb-cn.github.io/2024/09/06/%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83/Spring%20Security%20vs%20Shiro/"/>
    <id>https://andy-whb-cn.github.io/2024/09/06/%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83/Spring%20Security%20vs%20Shiro/</id>
    <published>2024-09-06T07:38:00.000Z</published>
    <updated>2024-09-06T07:44:15.136Z</updated>
    
    <content type="html"><![CDATA[<p>目前在java web应用安全框架中，比较常用的是Spring Security和Shiro框架, 二者在核心功能上几乎差不多，从使用的角度各有优缺点。从使用量上来说，Shiro要高于 Spring Security， Shiro的入门也相对比较容易。但Spring Security依托于Spring社区的支持，对于和Spring系列框架的集成有更好的融合型和兼容性。</p><p>相同点：<br>1、认证功能<br>2、授权功能<br>3、加密功能<br>4、会话管理<br>5、缓存支持<br>6、rememberMe功能</p><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><p><strong>Shiro四大核心功能:Authentication,Authorization,Cryptography,Session Management</strong><br><img src="https://s2.loli.net/2024/09/06/f5RbAjyFh4BGX1p.png" alt="image.png"></p><p>Shiro三个核心组件：Subject, SecurityManager 和 Realms.<br><img src="https://s2.loli.net/2024/09/06/Ua3dfNWJm1bKv97.png" alt="image.png"><br>Subject：主体，可以是任何可以与应用交互的 “用户”；<br>SecurityManager：相当于 SpringMVC 中的 DispatcherServlet, 是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。<br>Realm：域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色&#x2F;权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</p><p><img src="https://s2.loli.net/2024/09/06/AMDCFJB2ngQvN5l.png" alt="image.png"></p><p>除前文所讲Subject、SecurityManager 、Realm三个核心组件外，Shiro主要组件还包括： <br>Authenticator: 认证就是核实用户身份的过程。这个过程的常见例子是大家都熟悉的“用户&#x2F;密码”组合。多数用户在登录软件系统时，通常提供自己的用户名（当事人）和支持他们的密码（证书）。如果存储在系统中的密码（或密码表示）与用户提供的匹配，他们就被认为通过认证。 <br>Authorizer ：授权实质上就是访问控制 - 控制用户能够访问应用中的哪些内容，比如资源、Web页面等等。<br>SessionManager ：在安全框架领域，Apache Shiro提供了一些独特的东西：可在任何应用或架构层一致地使用Session API。即，Shiro为任何应用提供了一个会话编程范式 - 从小型后台独立应用到大型集群Web应用。这意味着，那些希望使用会话的应用开发者，不必被迫使用Servlet或EJB容器了。或者，如果正在使用这些容器，开发者现在也可以选择使用在任何层统一一致的会话API，取代Servlet或EJB机制。 <br>CacheManager: 对Shiro的其他组件提供缓存支持。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>1、引入shiro包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、Shiro配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置ShiroFilter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;securityManager&quot;)</span> DefaultWebSecurityManager securityManager)</span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean=<span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置安全管理器</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//添加Shiro拦截器</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Shiro 内置过滤器，可以实现权限相关的拦截器</span></span><br><span class="line"><span class="comment">         *     anon:无需认证（登录）可以直接访问</span></span><br><span class="line"><span class="comment">         *     authc:必须认证才能访问</span></span><br><span class="line"><span class="comment">         *     user:如果使用rememberMe的功能才可以访问</span></span><br><span class="line"><span class="comment">         *     perms:该资源得到资源权限才可以访问</span></span><br><span class="line"><span class="comment">         *     role:该资源必须得到角色权限才可以访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String,String&gt; filterMap=<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        filterMap.put(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">//添加Shiro授权拦截器</span></span><br><span class="line">        filterMap.put(<span class="string">&quot;/add&quot;</span>,<span class="string">&quot;perms[添加]&quot;</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;/foresee&quot;</span>,<span class="string">&quot;perms[预言未来]&quot;</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;/update&quot;</span>,<span class="string">&quot;perms[修改]&quot;</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;/delete&quot;</span>,<span class="string">&quot;perms[删除]&quot;</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;/*&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        <span class="comment">//跳转到登陆的页面</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        <span class="comment">//设置未授权的页面</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/unAuthorized&quot;</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建DefaultWebSecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;securityManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(<span class="meta">@Qualifier(&quot;userRealm&quot;)</span> UserRealm userRealm)</span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager=<span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//关联Realm</span></span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Realm</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userRealm&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserRealm <span class="title function_">getRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        UserRealm userRealm=<span class="keyword">new</span> <span class="title class_">UserRealm</span>();</span><br><span class="line">        <span class="keyword">return</span> userRealm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置shiroDialect,用于thymeleaf和shiro标签配合使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">getShiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        ShiroDialect shiroDialect=<span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">        <span class="keyword">return</span> shiroDialect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、自定义Realm</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IPermissionService permissionService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">// 判断用户是否存在</span></span><br><span class="line">        UsernamePasswordToken usernamePasswordToken=(UsernamePasswordToken)token;</span><br><span class="line">        User user=userService.findByname(usernamePasswordToken.getUsername());</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//用户名不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(user.getPassword().equals(usernamePasswordToken.getPassword()))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user, user.getPassword(),<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取登陆信息</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)subject.getPrincipal();</span><br><span class="line">        </span><br><span class="line">        User user1=userService.findById(user.getId());</span><br><span class="line">        <span class="keyword">if</span>(user1==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//用户已经不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始授权</span></span><br><span class="line">        SimpleAuthorizationInfo simpleAuthorizationInfo=<span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        List&lt;Permission&gt; permissions =permissionService.getPermissionByUserId(user1.getId());</span><br><span class="line">        <span class="keyword">for</span> (Permission per : permissions) &#123;</span><br><span class="line">            simpleAuthorizationInfo.addStringPermission(per.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、接口使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(User user, Model model)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        subject.login(<span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(user.getUsername(), user.getPassword()));</span><br><span class="line">        model.addAttribute(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;dashboard&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>Spring Security对Servlet的支持是基于Servlet Filters的。<br><img src="https://s2.loli.net/2024/09/06/dbmlRThyg5XAka6.png" alt="image.png"><a href="https://docs.spring.io/spring-boot/api/java/org/springframework/boot/autoconfigure/security/servlet/SecurityFilterAutoConfiguration.html">SecurityFilterAutoConfiguration</a>会自动注册一个名为springSecurityFilterChain的DelegatingFilterProxy。请求到达 DelegatingFilterProxy触发 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html">SecurityFilterChain</a>_执行一系列的filter.<br>可以看一下浏览器Http请求到达@RestController依次需要经过的Security Filter。<br><img src="https://s2.loli.net/2024/09/06/9wvl3NYJUCyzoXB.png" alt="image.png"><br>其中需要关注的几个Filter</p><ul><li><strong>SecurityContextHolderFilter</strong>(@Deprecated SecurityContextPersistenceFilter)：它在整个SecurityFilterChain中具有较高的优先级，当一个请求进入SecurityFilterChain的时候，需要从SecurityContextRepository加载SecurityContext实例①，并调用SecurityContextHolder对应的set方法进行保存②，以便后续其他地方获取这个SecurityContext实例，通常会保存在ThreadLocal中。</li></ul><ul><li><strong>BasicAuthenticationFilter</strong>: 尝试从Basic Auth HTTP Header中获取用户名和密码进行用户身份校验。</li><li><strong>UsernamePasswordAuthenticationFilter</strong>: 尝试从请求体或参数中获取用户名和密码进行用户身份校验。从request请求参数中获取用户名和密码并封装成UsernamePasswordAuthenticationToken①，然后交给ProviderManager#authenticate方法对其认证②，认证通过后返回AuthenticationProvider的Authentication对象③，此时SecurityContextHolderStrategy会创建出一个空载的SecurityContext实例④，并传入上述Authentication⑤，然后调用SecurityContextHolderStrategy保存⑤，最后通过SecurityContextRepository进行持久化⑦。</li><li><strong>DefaultLoginPageGeneratingFilter</strong>: 如果不显示的关闭这个特性，默认会生成登陆页面。这就是为什么开启了Spring Security以后会有默认的登录页。</li><li><strong>DefaultLogoutPageGeneratingFilter</strong>:  如果不显示的关闭这个特性，默认会生成登出页面。</li><li><strong>AuthorizationFilter</strong>(@Deprecated FilterSecurityInterceptor):  AuthorizationFilter主要是用来判断请求访问受保护资源时，是否符合授权条件。这时就需要获取当前用户的授权信息，先通过SecurityContext得到Authentication认证信息①，如果获取到Authentication实例为空，就表示请求并没有认证过，那么就会抛出一个AuthenticationCredentialsNotFoundException异常②，这个异常会被ExceptionTranslationFilter捕获，通常情况下，异常处理方式就是跳转到到登录页面③，让用户完成登录的操作。</li></ul><p><img src="https://s2.loli.net/2024/09/06/GMoldajcf5Z7XNC.png" alt="image.png"></p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p><strong>接口：</strong></p><ul><li><strong>Authentication</strong>：顶层接口，用于保存身份认证信息，主要包括3个部分：用户标识（principal，通常为用户名），凭证（credentials，通常为密码），权限信息（authorities，通常为该用户所拥有的角色）</li><li><strong>SecurityContext</strong>：顶层接口，直译为安全上下文，内部只定义了<code>getAuthentication</code>和<code>setAuthentication</code>两个方法，概括地说，<code>SecurityContext</code>相当于用于装载<code>Authentication</code>对象的容器，在整个<code>SecurityFilterChain</code>中，为不同的认证机制操作<code>Authentication</code>对象时提供服务。</li><li><strong>AuthenticationManager</strong>: 顶层接口，定义了“认证“方法。</li><li><strong>AuthenticationProvider</strong>: 顶层接口，同样也定义了一个签名相同的“认证”方法，不同于<code>AuthenticationManager</code>的认证方法，这个才是各种认证协议的具体实现，它通常接受一个未认证的<code>Authentication</code>对象的参数，该对象仅包含了principal和credentials的信息，在经过认证后，会把authorities填充进来，并将状态设置为已认证。在spring security中内置了很多实现类，例如<code>OAuth2LoginAuthenticationProvider</code>，用于实现OAuth2.0认证协议等。当然我们也可以根据需要自定义其实现。</li><li><strong>SecurityContextRepository</strong>：顶层接口，定义了保存和加载<code>SecuriyContext</code>对象的方法，常用的实现有<code>HttpSessionSecurityContextRepository</code>，即通过request的会话对象session，存取<code>SecurityContext</code>的实例。</li><li><strong>SecurityContextHolderStrategy</strong>：顶层接口，定义了在当前请求的线程中，获取和设置<code>SecurityContext</code>对象等方法，在5.8版本之后，新增了两个get&#x2F;set“延迟（Deferred）”接口，主要是使用了Supplier函数式接口实现的惰性计算，不过只是性能上的考量，本质上都是用于维护<code>SecurityContext</code>对象的方法</li></ul><p><strong>类：</strong></p><ul><li><strong>SecurityContextHolder</strong>：它是spring security认证模型中最为常用的一个工具类，它采用策略模式封装了<code>SecurityContextHolderStrategy</code>接口实现，默认的策略实现为<code>ThreadLocalSecurityContextHolderStrategy</code>，底层使用了<code>ThreadLocal</code>实现对<code>SecurityContext</code>对象的存取，可以保证在一次请求的同一个线程中，方便地获取<code>SecurityContext</code>对象。</li><li><strong>ProviderManager</strong>: AuthenticationManager的实现类，它内部维护了一个<code>List&lt;AuthenticationProvider&gt;</code> 成员变量，在实现<code>AuthenticationManager#authenticate</code>方法时，其实是遍历这个<code>List&lt;AuthenticationProvider&gt;</code>列表，依次判断是否支持当前<code>Authentication</code>对象（如<code>OAuth2LoginAuthenticationProvider</code>支持<code>OAuth2LoginAuthenticationToken</code>），如果支持，则调用<code>AuthenticationProvider#authenticate</code>方法，完成认证过程。</li></ul><p><img src="https://s2.loli.net/2024/09/06/YUbdm8WGq5MIs4L.png" alt="image.png"></p><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>1、引入包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置Security</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">inMemoryUserDetailsManager</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.builder()</span><br><span class="line">.username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">.password(passwordEncoder().encode(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">.roles(<span class="string">&quot;USER&quot;</span>) </span><br><span class="line">.build();</span><br><span class="line"><span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User.builder()</span><br><span class="line">.username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">.password(passwordEncoder().encode(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">.roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">.build(); </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user, admin); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Bean</span></span><br><span class="line"><span class="comment">public UserDetailsService jdbcUserDetailsService(DataSource dataSource) &#123;</span></span><br><span class="line"><span class="comment">return new JdbcUserDetailsManager(dataSource); </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 用于单向密码校验，匹配(输入明文密码，UserDetails的加密密码) </span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> http.authorizeRequests()</span><br><span class="line"> .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line"> .requestMatchers(<span class="string">&quot;/**&quot;</span>).authenticated()</span><br><span class="line"> .and()</span><br><span class="line"> .formLogin().permitAll(); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//@formatter:off </span></span><br><span class="line"> http.authorizeRequests()</span><br><span class="line"> .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()  <span class="comment">// 允许所有人login访问</span></span><br><span class="line"> .requestMatchers(<span class="string">&quot;/**&quot;</span>).hasAnyRole(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>) </span><br><span class="line"> .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line"> .and()</span><br><span class="line"> .formLogin()</span><br><span class="line"> .loginPage(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定登陆页，区别默认登陆页面</span></span><br><span class="line"> .loginProcessingUrl(<span class="string">&quot;/process-login&quot;</span>)</span><br><span class="line"> .defaultSuccessUrl(<span class="string">&quot;/home&quot;</span>)</span><br><span class="line"> .failureUrl(<span class="string">&quot;/login?error=true&quot;</span>)</span><br><span class="line"> .permitAll()</span><br><span class="line"> .and()</span><br><span class="line"> .logout()</span><br><span class="line"> .logoutSuccessUrl(<span class="string">&quot;/login?logout=true&quot;</span>)  <span class="comment">// 指定登出页面</span></span><br><span class="line"> .invalidateHttpSession(<span class="literal">true</span>)</span><br><span class="line"> .deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>)</span><br><span class="line"> .permitAll() <span class="comment">// 允许logout访问</span></span><br><span class="line"> .and()</span><br><span class="line"> .csrf().disable(); <span class="comment">// 关闭csrf校验</span></span><br><span class="line"> <span class="comment">//@formatter:on </span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> http.build(); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Bean</span> </span><br><span class="line"> <span class="keyword">public</span> WebSecurityCustomizer <span class="title function_">webSecurityCustomizer</span><span class="params">()</span> &#123; </span><br><span class="line"> <span class="comment">// 资源类请求无需权限校验</span></span><br><span class="line"> <span class="keyword">return</span> (web) -&gt; web.ignoring()</span><br><span class="line">.requestMatchers(<span class="string">&quot;/resources/**&quot;</span>, <span class="string">&quot;/static/**&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> @Bean </span></span><br><span class="line"><span class="comment"> AuthenticationSuccessHandler authenticationSuccessHandler() &#123; </span></span><br><span class="line"><span class="comment"> return new CustomAuthenticationSuccessHandler(); </span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @Bean </span></span><br><span class="line"><span class="comment"> AuthenticationFailureHandler authenticationFailureHandler() &#123; </span></span><br><span class="line"><span class="comment">return new CustomAuthenticationFailureHandler();</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://howtodoinjava.com/spring-security/spring-security-tutorial/">https://howtodoinjava.com/spring-security/spring-security-tutorial/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前在java web应用安全框架中，比较常用的是Spring Security和Shiro框架, 二者在核心功能上几乎差不多，从使用的角度各有优缺点。从使用量上来说，Shiro要高于 Spring Security， Shiro的入门也相对比较容易。但Spring Sec</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="安全" scheme="https://andy-whb-cn.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用软件清单</title>
    <link href="https://andy-whb-cn.github.io/2024/09/03/%E6%8E%A8%E8%8D%90/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/"/>
    <id>https://andy-whb-cn.github.io/2024/09/03/%E6%8E%A8%E8%8D%90/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/</id>
    <published>2024-09-03T06:11:58.004Z</published>
    <updated>2024-09-03T06:31:27.693Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>软件名称</th><th>下载地址</th><th>用途</th></tr></thead><tbody><tr><td>winscp</td><td><a href="https://winscp.net/eng/index.php">https://winscp.net/eng/index.php</a></td><td>scp远程连接上传下载文件</td></tr><tr><td>Another-Redis-Desktop-Manager</td><td><a href="https://goanother.com/cn/#download">https://goanother.com/cn/#download</a></td><td>Redis客户端工具</td></tr><tr><td>NoSQLBooster for MongoDB</td><td><a href="https://www.nosqlbooster.com/">https://www.nosqlbooster.com/</a></td><td>MongoDB客户端</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件名称&lt;/th&gt;
&lt;th&gt;下载地址&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;winscp&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://winscp.net/eng/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SOA架构vs微服务架构</title>
    <link href="https://andy-whb-cn.github.io/2024/09/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/SOA%E6%9E%B6%E6%9E%84%20vs%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>https://andy-whb-cn.github.io/2024/09/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/SOA%E6%9E%B6%E6%9E%84%20vs%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</id>
    <published>2024-09-03T01:30:00.000Z</published>
    <updated>2024-09-03T02:29:16.772Z</updated>
    
    <content type="html"><![CDATA[<p>SOA架构和微服务架构最主要的区别：面向的范围不同。<br>SOA架构主要面向企业级服务，微服务架构主要面向应用级服务<br><img src="https://s2.loli.net/2024/09/03/LHZYIe7m26gaPRN.png" alt="image.png"><br>典型的微服务架构：<br><img src="https://s2.loli.net/2024/09/03/iyrj3mZq5x8XSTv.png" alt="image.png"><br>基础原则：</p><ul><li>服务自治：每个服务都拥有独立的数据库和功能，可以独立开发和部署。</li><li>去中心化的数据管理：强调服务的数据自主性，减少数据耦合，解决在单体应用中可能出现的数据一致性问题。</li><li>技术的异质性：每个服务可以选择最适合的技术栈开发，提升效率和创新。<br>挑战：</li><li>分布式服务的复杂性：服务发现、负载均衡、网络延迟、调试和测试。</li><li>跨服务数据一致性问题：每个服务都有自己的数据库，数据的完整性和一致性变得复杂，分布式事务比较麻烦且有潜在的性能影响。</li><li>业务处理的复杂性：依赖于微服务的良好设计和实现。</li><li>监控的必要性：依赖于监控解决方案发现性能瓶颈、错误、异常。</li></ul><p>典型的SOA架构：<br><img src="https://s2.loli.net/2024/09/03/VKqOLTi1uNY3tjZ.png" alt="image.png"></p><p>SOA架构可以认为是一种强调模块化和互用性的基础方法。<br>SOA架构图描绘的是互相连接的组件组成系统的结构：</p><ul><li>Servcie: 完成特定业务功能的服务</li><li>Service Repository: 中心化的服务目录，便于服务发现和使用</li><li>FrontEnd: 用户接口层，通过契约(Contracts)和服务交互</li><li>Service Bus: 用于服务间通讯，建立消息交换。</li><li>Contract: 定义服务的交互契约，促使松耦合</li><li>Interface: 对外暴露服务功能<br>基本原则：</li></ul><ul><li>复用性：模块化的服务，并且可以被多个应用复用。</li><li>可发现性：服务注册。</li><li>可组合性：可以支持任意方法进行服务的组合。</li><li>松耦合：服务之间互相独立，通过标准接口进行通信。<br>挑战：</li><li>服务的版本和兼容性</li><li>数据的完整性和一致性</li><li>业务处理的复杂性</li></ul><h2 id="其他差异：SOA-与微服务"><a href="#其他差异：SOA-与微服务" class="headerlink" title="其他差异：SOA 与微服务"></a>其他差异：SOA 与微服务</h2><table><thead><tr><th></th><th><strong>SOA</strong></th><th><strong>微服务</strong></th></tr></thead><tbody><tr><td>实施</td><td>共享资源的不同服务。</td><td>独立且针对特定用途的小型服务。</td></tr><tr><td>交流</td><td>ESB 使用多种消息协议，例如 SOAP、AMQP 和 MSMQ。</td><td>API、Java 消息服务、发布&#x2F;订阅</td></tr><tr><td>数据存储</td><td>共享数据存储。</td><td>独立的数据存储。</td></tr><tr><td>部署</td><td>具有挑战性。细微更改也需要全面重构。</td><td>易于部署。每个微服务都可以容器化。</td></tr><tr><td>可重用性</td><td>通过共享公共资源提供可重复使用的服务。</td><td>每项服务都有自己的独立资源。您可以通过微服务的 API 重复使用微服务。</td></tr><tr><td>速度</td><td>速度会随着服务增多而减慢。</td><td>可在流量增长时保持稳定的速度。</td></tr><tr><td>治理灵活性</td><td>跨所有服务进行一致的数据治理。</td><td>针对每种存储采用不同的数据治理策略。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SOA架构和微服务架构最主要的区别：面向的范围不同。&lt;br&gt;SOA架构主要面向企业级服务，微服务架构主要面向应用级服务&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/09/03/LHZYIe7m26gaPRN.png&quot; alt=&quot;image.p</summary>
      
    
    
    
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 扩展点</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E6%89%A9%E5%B1%95%E7%82%B9/</id>
    <published>2024-09-02T11:02:01.624Z</published>
    <updated>2024-09-03T02:34:56.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是封装了Spring，遵循约定大于配置，加上自动装配的机制。很多时候我们只要引用了一个依赖，几乎是零配置就能完成一个功能的装配。</p><p>我非常喜欢这种自动装配的机制，所以在自己开发中间件和公共依赖工具的时候也会用到这个特性。让使用者以最小的代价接入。想要把自动装配玩的转，就必须要了解spring对于bean的构造生命周期以及各个扩展接口。当然了解了bean的各个生命周期也能促进我们加深对spring的理解。业务代码也能合理利用这些扩展点写出更加漂亮的代码。</p><p>在网上搜索Spring扩展点，发现很少有博文说的很全的，只有一些常用的扩展点的说明。</p><p>所以在这篇文章里，我总结了几乎Spring &amp; Springboot所有的扩展接口，以及各个扩展点的使用场景。并且整理出了一个bean在spring内部从被加载到最后初始化完成所有可扩展点的顺序调用图。从而我们也能窥探到bean是如何一步步加载到spring容器中的。</p><h2 id="可扩展的接口启动调用顺序图"><a href="#可扩展的接口启动调用顺序图" class="headerlink" title="可扩展的接口启动调用顺序图"></a>可扩展的接口启动调用顺序图</h2><p>以下是我整理的spring容器中Bean的生命周期内所有可扩展的点的调用顺序，下面会一个个分析</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4hB8nHklbQwqMicuD3lsDSHljEIJQOP11Js5oYzt3OgtNuiapvoCnUibkLbINdd3XaHN0S9UoOS3lgzw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="1-ApplicationContextInitializer"><a href="#1-ApplicationContextInitializer" class="headerlink" title="1. ApplicationContextInitializer"></a>1. ApplicationContextInitializer</h2><blockquote><p>org.springframework.context.ApplicationContextInitializer</p></blockquote><p>这是整个spring容器在刷新之前初始化<code>ConfigurableApplicationContext</code>的回调接口，简单来说，就是在容器刷新之前调用此类的<code>initialize</code>方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。</p><p>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestApplicationContextInitializer implements ApplicationContextInitializer &#123;      @Override      public void initialize(ConfigurableApplicationContext applicationContext) &#123;          System.out.println(&quot;[ApplicationContextInitializer]&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><p>因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：</p><ul><li><p>在启动类中用<code>springApplication.addInitializers(new TestApplicationContextInitializer())</code>语句加入</p></li><li><p>配置文件配置<code>context.initializer.classes=com.example.demo.TestApplicationContextInitializer</code></p></li><li><p>Spring SPI扩展，在spring.factories中加入<code>org.springframework.context.ApplicationContextInitializer=com.example.demo.TestApplicationContextInitializer</code></p></li></ul><h2 id="2-BeanDefinitionRegistryPostProcessor"><a href="#2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="2. BeanDefinitionRegistryPostProcessor"></a>2. BeanDefinitionRegistryPostProcessor</h2><blockquote><p>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</p></blockquote><p>这个接口在读取项目中的<code>beanDefinition</code>之后执行，提供一个补充的扩展点。</p><p>使用场景：你可以在这里动态注册自己的<code>beanDefinition</code>，可以加载classpath之外的bean</p><p>扩展方式为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;      @Override      public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;          System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;);      &#125;        @Override      public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;          System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-BeanFactoryPostProcessor"><a href="#3-BeanFactoryPostProcessor" class="headerlink" title="3. BeanFactoryPostProcessor"></a>3. BeanFactoryPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.BeanFactoryPostProcessor</p></blockquote><p>这个接口是<code>beanFactory</code>的扩展接口，调用时机在spring在读取<code>beanDefinition</code>信息之后，实例化bean之前。</p><p>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的<code>beanDefinition</code>的元信息。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;      @Override      public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;          System.out.println(&quot;[BeanFactoryPostProcessor]&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="4-InstantiationAwareBeanPostProcessor"><a href="#4-InstantiationAwareBeanPostProcessor" class="headerlink" title="4. InstantiationAwareBeanPostProcessor"></a>4. InstantiationAwareBeanPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</p></blockquote><p>该接口继承了<code>BeanPostProcess</code>接口，区别如下：</p><p><strong><code>BeanPostProcess</code>接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而<code>InstantiationAwareBeanPostProcessor</code>接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</strong></p><p>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：<strong>实例化阶段</strong> 和<strong>初始化阶段</strong> ，下面一起进行说明，按调用顺序为：</p><ul><li><p><code>postProcessBeforeInstantiation</code>：实例化bean之前，相当于new这个bean之前</p></li><li><p><code>postProcessAfterInstantiation</code>：实例化bean之后，相当于new这个bean之后</p></li><li><p><code>postProcessPropertyValues</code>：bean已经实例化完成，在属性注入时阶段触发，<code>@Autowired</code>,<code>@Resource</code>等注解原理基于此方法实现</p></li><li><p><code>postProcessBeforeInitialization</code>：初始化bean之前，相当于把bean注入spring上下文之前</p></li><li><p><code>postProcessAfterInitialization</code>：初始化bean之后，相当于把bean注入spring上下文之后</p></li></ul><p>使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor &#123;        @Override      public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot; + beanName);          return bean;      &#125;        @Override      public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot; + beanName);          return bean;      &#125;        @Override      public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot; + beanName);          return null;      &#125;        @Override      public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot; + beanName);          return true;      &#125;        @Override      public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot; + beanName);          return pvs;      &#125;</span><br></pre></td></tr></table></figure><h2 id="5-SmartInstantiationAwareBeanPostProcessor"><a href="#5-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="5. SmartInstantiationAwareBeanPostProcessor"></a>5. SmartInstantiationAwareBeanPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</p></blockquote><p>该扩展接口有3个触发点方法：</p><ul><li><p><code>predictBeanType</code>：<br>  该触发点发生在<code>postProcessBeforeInstantiation</code>之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用<code>BeanFactory.getType(name)</code>时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</p></li><li><p><code>determineCandidateConstructors</code>：<br>  该触发点发生在<code>postProcessBeforeInstantiation</code>之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</p></li><li><p><code>getEarlyBeanReference</code>：<br>  该触发点发生在<code>postProcessAfterInstantiation</code>之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。</p></li></ul><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestSmartInstantiationAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor &#123;        @Override      public Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot; + beanName);          return beanClass;      &#125;        @Override      public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot; + beanName);          return null;      &#125;        @Override      public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException &#123;          System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot; + beanName);          return bean;      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="6-BeanFactoryAware"><a href="#6-BeanFactoryAware" class="headerlink" title="6. BeanFactoryAware"></a>6. BeanFactoryAware</h2><blockquote><p>org.springframework.beans.factory.BeanFactoryAware</p></blockquote><p>这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为<code>setBeanFactory</code>，可以拿到<code>BeanFactory</code>这个属性。</p><p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 <code>BeanFactory</code>，在这个时候，可以对每个bean作特殊化的定制。也或者可以把<code>BeanFactory</code>拿到进行缓存，日后使用。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanFactoryAware implements BeanFactoryAware &#123;      @Override      public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;          System.out.println(&quot;[TestBeanFactoryAware] &quot; + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName());      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="7-ApplicationContextAwareProcessor"><a href="#7-ApplicationContextAwareProcessor" class="headerlink" title="7. ApplicationContextAwareProcessor"></a>7. ApplicationContextAwareProcessor</h2><blockquote><p>org.springframework.context.support.ApplicationContextAwareProcessor</p></blockquote><p>该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWaHkLLxnI5CWkzPIFHHvKmOJASx9aLomwLG0cCsBbJCuicuwfdYX0qo8fYbSLSzWKaSictUTXoGH1A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp" alt="图片"></p><p>可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。<strong>所以这里应该来说是有6个扩展点</strong> ，这里就放一起来说了</p><ul><li><p><code>EnvironmentAware</code>：<br>  用于获取<code>EnviromentAware</code>的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。</p></li><li><p><code>EmbeddedValueResolverAware</code>：<br>  用于获取<code>StringValueResolver</code>的一个扩展类， <code>StringValueResolver</code>用于获取基于<code>String</code>类型的properties的变量，一般我们都用<code>@Value</code>的方式去获取，如果实现了这个Aware接口，把<code>StringValueResolver</code>缓存起来，通过这个类去获取<code>String</code>类型的变量，效果是一样的。</p></li><li><p><code>ResourceLoaderAware</code>：<br>  用于获取<code>ResourceLoader</code>的一个扩展类，<code>ResourceLoader</code>可以用于获取classpath内所有的资源对象，可以扩展此类来拿到<code>ResourceLoader</code>对象。</p></li><li><p><code>ApplicationEventPublisherAware</code>：<br>  用于获取<code>ApplicationEventPublisher</code>的一个扩展类，<code>ApplicationEventPublisher</code>可以用来发布事件，结合<code>ApplicationListener</code>来共同使用，下文在介绍<code>ApplicationListener</code>时会详细提到。这个对象也可以通过spring注入的方式来获得。</p></li><li><p><code>MessageSourceAware</code>：<br>  用于获取<code>MessageSource</code>的一个扩展类，<code>MessageSource</code>主要用来做国际化。</p></li><li><p><code>ApplicationContextAware</code>：<br>  用来获取<code>ApplicationContext</code>的一个扩展类，<code>ApplicationContext</code>应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时<code>ApplicationContext</code>也实现了<code>BeanFactory</code>，<code>MessageSource</code>，<code>ApplicationEventPublisher</code>等接口，也可以用来做相关接口的事情。</p></li></ul><h2 id="8-BeanNameAware"><a href="#8-BeanNameAware" class="headerlink" title="8. BeanNameAware"></a>8. BeanNameAware</h2><blockquote><p>org.springframework.beans.factory.BeanNameAware</p></blockquote><p>可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是<code>postProcessBeforeInitialization</code>之前，这个类的触发点方法只有一个：<code>setBeanName</code></p><p>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class NormalBeanA implements BeanNameAware&#123;      public NormalBeanA() &#123;          System.out.println(&quot;NormalBean constructor&quot;);      &#125;        @Override      public void setBeanName(String name) &#123;          System.out.println(&quot;[BeanNameAware] &quot; + name);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="9-PostConstruct"><a href="#9-PostConstruct" class="headerlink" title="9. @PostConstruct"></a>9. @PostConstruct</h2><blockquote><p>javax.annotation.PostConstruct</p></blockquote><p>这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了<code>@PostConstruct</code>，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在<code>postProcessBeforeInitialization</code>之后，<code>InitializingBean.afterPropertiesSet</code>之前。</p><p>使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class NormalBeanA &#123;      public NormalBeanA() &#123;          System.out.println(&quot;NormalBean constructor&quot;);      &#125;        @PostConstruct      public void init()&#123;          System.out.println(&quot;[PostConstruct] NormalBeanA&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="10-InitializingBean"><a href="#10-InitializingBean" class="headerlink" title="10. InitializingBean"></a>10. InitializingBean</h2><blockquote><p>org.springframework.beans.factory.InitializingBean</p></blockquote><p>这个类，顾名思义，也是用来初始化bean的。<code>InitializingBean</code>接口为bean提供了初始化方法的方式，它只包括<code>afterPropertiesSet</code>方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在<code>postProcessAfterInitialization</code>之前。</p><p>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class NormalBeanA implements InitializingBean&#123;      @Override      public void afterPropertiesSet() throws Exception &#123;          System.out.println(&quot;[InitializingBean] NormalBeanA&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="11-FactoryBean"><a href="#11-FactoryBean" class="headerlink" title="11. FactoryBean"></a>11. FactoryBean</h2><blockquote><p>org.springframework.beans.factory.FactoryBean</p></blockquote><p>一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个<code>org.springframework.bean.factory.FactoryBean</code>的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。<code>FactoryBean</code>接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个<code>FactoryBean</code>的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，<code>FactoryBean</code>开始支持泛型，即接口声明改为<code>FactoryBean&lt;T&gt;</code>的形式</p><p>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿<code>ProxyFactoryBean</code>的功能。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestFactoryBean implements FactoryBean&lt;TestFactoryBean.TestFactoryInnerBean&gt; &#123;        @Override      public TestFactoryBean.TestFactoryInnerBean getObject() throws Exception &#123;          System.out.println(&quot;[FactoryBean] getObject&quot;);          return new TestFactoryBean.TestFactoryInnerBean();      &#125;        @Override      public Class&lt;?&gt; getObjectType() &#123;          return TestFactoryBean.TestFactoryInnerBean.class;      &#125;        @Override      public boolean isSingleton() &#123;          return true;      &#125;        public static class TestFactoryInnerBean&#123;        &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="12-SmartInitializingSingleton"><a href="#12-SmartInitializingSingleton" class="headerlink" title="12. SmartInitializingSingleton"></a>12. SmartInitializingSingleton</h2><blockquote><p>org.springframework.beans.factory.SmartInitializingSingleton</p></blockquote><p>这个接口中只有一个方法<code>afterSingletonsInstantiated</code>，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为<code>postProcessAfterInitialization</code>之后。</p><p>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestSmartInitializingSingleton implements SmartInitializingSingleton &#123;      @Override      public void afterSingletonsInstantiated() &#123;          System.out.println(&quot;[TestSmartInitializingSingleton]&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="13-CommandLineRunner"><a href="#13-CommandLineRunner" class="headerlink" title="13. CommandLineRunner"></a>13. CommandLineRunner</h2><blockquote><p>org.springframework.boot.CommandLineRunner</p></blockquote><p>这个接口也只有一个方法：<code>run(String... args)</code>，触发时机为整个项目启动完毕后，自动执行。如果有多个<code>CommandLineRunner</code>，可以利用<code>@Order</code>来进行排序。</p><p>使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestCommandLineRunner implements CommandLineRunner &#123;        @Override      public void run(String... args) throws Exception &#123;          System.out.println(&quot;[TestCommandLineRunner]&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="14-DisposableBean"><a href="#14-DisposableBean" class="headerlink" title="14. DisposableBean"></a>14. DisposableBean</h2><blockquote><p>org.springframework.beans.factory.DisposableBean</p></blockquote><p>这个扩展点也只有一个方法：<code>destroy()</code>，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行<code>applicationContext.registerShutdownHook</code>时，就会触发这个方法。</p><p>扩展方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class NormalBeanA implements DisposableBean &#123;      @Override      public void destroy() throws Exception &#123;          System.out.println(&quot;[DisposableBean] NormalBeanA&quot;);      &#125;  &#125;</span><br></pre></td></tr></table></figure><h2 id="15-ApplicationListener"><a href="#15-ApplicationListener" class="headerlink" title="15. ApplicationListener"></a>15. ApplicationListener</h2><blockquote><p>org.springframework.context.ApplicationListener</p></blockquote><p>准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，<code>ApplicationListener</code>可以监听某个事件的<code>event</code>，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。</p><p>接下来罗列下spring主要的内置事件：</p><ul><li><p>ContextRefreshedEvent<br>  ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在<code>ConfigurableApplicationContext</code>接口中使用 <code>refresh()</code>方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，<code>ApplicationContext</code>容器已就绪可用。</p></li><li><p>ContextStartedEvent<br>  当使用 <code>ConfigurableApplicationContext</code> （ApplicationContext子接口）接口中的 start() 方法启动 <code>ApplicationContext</code>时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p></li><li><p>ContextStoppedEvent<br>  当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>stop()</code>停止<code>ApplicationContext</code> 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</p></li><li><p>ContextClosedEvent<br>  当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>close()</code>方法关闭 <code>ApplicationContext</code> 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</p></li><li><p>RequestHandledEvent<br>  这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们从这些spring&amp;springboot的扩展点当中，大致可以窥视到整个bean的生命周期。在业务开发或者写中间件业务的时候，可以合理利用spring提供给我们的扩展点，在spring启动的各个阶段内做一些事情。以达到自定义初始化的目的。此篇总结，如果有错误或者疏漏的地方，恳请指正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面向接口：限流</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%99%90%E6%B5%81/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E9%99%90%E6%B5%81/</id>
    <published>2024-09-02T10:58:29.715Z</published>
    <updated>2024-09-03T02:36:01.074Z</updated>
    
    <content type="html"><![CDATA[<p>如何在SpringBoot中使用Guava和Redis实现接口限流的文章。具体包括：</p><ol><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&mid=2247496639&idx=1&sn=4971f8fd16d27eedd81ffc4e0944eed4&chksm=9ad3e9feada460e85f3404e6c86ae2315df0d77c07296a45760cef2e137d0f3cd1d952854029&scene=21#wechat_redirect">使用Guava实现单机令牌桶限流</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&mid=2247505503&idx=1&sn=4b8a0ac1ee6d3362675c46767dd14df1&chksm=9ad3cc1eada445083b4e8e386945db8e7b1113f02a523bde6d4721e5758c4b420d770274535b&scene=21#wechat_redirect">使用Redis实现分布式限流</a></li></ol><p>现在，一个问题摆在我们面前：如何将这两种限流机制整合到同一个组件中，以便用户随时切换呢？</p><p>显然，我们需要定义一个通用的限流组件，将其引入到业务中，并支持通过配置文件自由切换不同的限流机制。举例而言，当使用<code>limit.type=redis</code>时，启用Redis分布式限流组件，当使用<code>limit.type=local</code>时，启用Guava限流组件。这种自由切换机制能够为用户提供更大的灵活性和可维护性。</p><p>接下来，让我们开始动手实现吧！</p><h3 id="第一步，创建通用模块cloud-limiter-starter"><a href="#第一步，创建通用模块cloud-limiter-starter" class="headerlink" title="第一步，创建通用模块cloud-limiter-starter"></a>第一步，创建通用模块cloud-limiter-starter</h3><p>首先在父项目下创建一个模块</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jYuuibyuhu4y8aWlcmziaZicx1n6SHag3GwO5foniafcoibb3Y4wHlS4qKJlXD33S5DknV3qzO2CichY7Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后在pom文件中引入相关依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;!--SpringFramework--&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><blockquote><p>小提示：通用模块命名最好遵照规则以starter命名结束，同时通用模块引入的依赖最好设置<code>&lt;scope&gt;provided&lt;/scope&gt;</code>属性。</p></blockquote><h3 id="第二步，实现限流功能"><a href="#第二步，实现限流功能" class="headerlink" title="第二步，实现限流功能"></a>第二步，实现限流功能</h3><ol><li>创建限流接口</li></ol><p>既然有两种限流机制，按照套路肯定得先创建一个限流接口，就叫<code>LimiterManager</code>吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface LimiterManager &#123;    boolean tryAccess(Limiter limiter);&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>分别实现Redis的限流功能和Guava的限流功能，这里只给出核心代码。</li></ol><p>Guava限流的核心实现GuavaLimiter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Slf4jpublic class GuavaLimiter implements LimiterManager&#123;    private final Map&lt;String, RateLimiter&gt; limiterMap = Maps.newConcurrentMap();    @Override    public boolean tryAccess(Limiter limiter) &#123;        RateLimiter rateLimiter = getRateLimiter(limiter);        if (rateLimiter == null) &#123;            return false;        &#125;        boolean access = rateLimiter.tryAcquire(1,100, TimeUnit.MILLISECONDS);        log.info(&quot;&#123;&#125; access :&#123;&#125;&quot;,limiter.getKey() , access);        return access;    &#125;&#125;    </span><br></pre></td></tr></table></figure><p>Redis限流的核心实现RedisLimiter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Slf4jpublic class RedisLimiter implements LimiterManager&#123;    private final StringRedisTemplate stringRedisTemplate;    public RedisLimiter(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean tryAccess(Limiter limiter) &#123;        String key = limiter.getKey();        if (StringUtils.isEmpty(key)) &#123;            throw new LimiterException( &quot;redis limiter key cannot be null&quot; );        &#125;        List&lt;String&gt; keys = new ArrayList&lt;&gt;();        keys.add( key );        int seconds = limiter.getSeconds();        int limitCount = limiter.getLimitNum();        String luaScript = buildLuaScript();        RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(luaScript, Long.class);        Long count = stringRedisTemplate.execute( redisScript, keys, &quot;&quot; + limitCount, &quot;&quot; + seconds );        log.info( &quot;Access try count is &#123;&#125; for key=&#123;&#125;&quot;, count, key );        return count != null &amp;&amp; count != 0;    &#125;&#125;    </span><br></pre></td></tr></table></figure><h3 id="第三步，创建配置类"><a href="#第三步，创建配置类" class="headerlink" title="第三步，创建配置类"></a>第三步，创建配置类</h3><p>编写配置类根据配置文件注入限流实现类，当配置文件中属性 <code>limit.type=local</code> 时启用Guava限流机制，当<code>limit.type=redis</code> 时启用Redis限流机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Configurationpublic class LimiterConfigure &#123;    @Bean    @ConditionalOnProperty(name = &quot;limit.type&quot;,havingValue = &quot;local&quot;)    public LimiterManager guavaLimiter()&#123;        return new GuavaLimiter();    &#125;    @Bean    @ConditionalOnProperty(name = &quot;limit.type&quot;,havingValue = &quot;redis&quot;)    public LimiterManager redisLimiter(StringRedisTemplate stringRedisTemplate)&#123;        return new RedisLimiter(stringRedisTemplate);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="第四步，创建AOP"><a href="#第四步，创建AOP" class="headerlink" title="第四步，创建AOP"></a>第四步，创建AOP</h3><p>根据前面的两篇文章可知，避免限流功能污染业务逻辑的最好方式是借助Spring AOP，所以很显然还得需要创建一个AOP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Aspect@EnableAspectJAutoProxy(proxyTargetClass = true) //使用CGLIB代理@Conditional(LimitAspectCondition.class)public class LimitAspect &#123;    @Setter(onMethod_ = @Autowired)    private LimiterManager limiterManager;    @Pointcut(&quot;@annotation(com.jianzh5.limit.aop.Limit)&quot;)    private void check() &#123;    &#125;    @Before(&quot;check()&quot;)    public void before(JoinPoint joinPoint)&#123;        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        Method method = signature.getMethod();        Limit limit = method.getAnnotation(Limit.class);        if(limit != null)&#123;            Limiter limiter = Limiter.builder().limitNum(limit.limitNum())                    .seconds(limit.seconds())                    .key(limit.key()).build();            if(!limiterManager.tryAccess(limiter))&#123;                throw new LimiterException( &quot;There are currently many people , please try again later!&quot; );            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>注意到类上我加了一行<code>@Conditional(LimitAspectCondition.class)</code>，使用了自定义条件选择器，意思是只有当配置类中出现了<code>limit.type</code>属性时才会加载这个AOP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class LimitAspectCondition implements Condition &#123;    @Override    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;        //检查配置文件是否包含limit.type属性        return conditionContext.getEnvironment().containsProperty(ConfigConstant.LIMIT_TYPE);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="第四步，创建spring-factories文件，引导SpringBoot加载配置类"><a href="#第四步，创建spring-factories文件，引导SpringBoot加载配置类" class="headerlink" title="第四步，创建spring.factories文件，引导SpringBoot加载配置类"></a>第四步，创建spring.factories文件，引导SpringBoot加载配置类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\  com.jianzh5.limit.config.LimiterConfigure,\  com.jianzh5.limit.aop.LimitAspect</span><br></pre></td></tr></table></figure><p>完整目录结构如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jYuuibyuhu4y8aWlcmziaZicxddAyDsicibHiaibhA7IarQAPmugnuRghR9jSzAGJ1Bqqe8eA2SVaMHcWIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="第五步，在项目中引用限流组件"><a href="#第五步，在项目中引用限流组件" class="headerlink" title="第五步，在项目中引用限流组件"></a>第五步，在项目中引用限流组件</h3><ol><li><p>引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;    &lt;groupId&gt;com.jianzh5&lt;/groupId&gt;    &lt;artifactId&gt;cloud-limit-starter&lt;/artifactId&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在application.properties中设置加载的限流组件</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit.type = redis</span><br></pre></td></tr></table></figure><p>如果不配置此属性则不加载对应限流功能。</p><ol start="3"><li>在需要限流的接口上加上注解<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Limit(key = &quot;Limiter:test&quot;,limitNum = 3,seconds = 1)</span><br></pre></td></tr></table></figure></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过上述步骤，我们已经成功实现了一个通用限流组件。在实际应用中，只需要根据场景需求选择对应的限流机制，即可非常方便的进行限流操作。这种灵活性和便捷性，也是SpringBoot中定义Starter的一般套路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何在SpringBoot中使用Guava和Redis实现接口限流的文章。具体包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247496639&amp;idx=1&amp;sn</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot GraphQL</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9AGraphQL/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9AGraphQL/</id>
    <published>2024-09-02T10:36:22.017Z</published>
    <updated>2024-09-02T10:41:42.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>REST作为一种现代网络应用非常流行的软件架构风格受到广大WEB开发者的喜爱，在目前软件架构设计模式中随处可见REST的身影，但是随着REST的流行与发展，它的一个最大的缺点开始暴露出来：</p><blockquote><p>在很多时候客户端需要的数据往往在不同的地方具有相似性，但却又不尽相同。</p><p>如同样的用户信息，在有的场景下前端只需要用户的简要信息（名称、头像），在其他场景下又需要用户的详细信息。当这样的相似但又不同的地方多的时候，就需要开发更多的接口来满足前端的需要。</p><p>随着这样的场景越来越多，接口越来越多，文档越来越臃肿，前后端沟通成本呈指数增加。</p></blockquote><p>基于上面的场景，我们迫切需要有一种解决方案或框架，可以使得在使用同一个领域模型（DO、DTO）的数据接口时可以由前端指定需要的接口字段，而后端根据前端的需求自动适配并返回对应的字段。</p><p>这就是我们今天的主角GraphQL。</p><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><p>考虑下面的场景：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1u3gJl6YBstESJE1iciaLLvicGmXLtFuIyfuzN2OoRRhUlTgujVgciatvXZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>用户 与 文章 是一对多的关系，一个用户可以发表多篇文章，同时又可以根据文章找到对应的作者。</p><p>我们需要构建以下几个Graphql查询：</p><ul><li>根据用户ID获取用户详情，并获取此用户发表的所有文章</li><li>根据文章ID获取文章详情，并获取文章作者的信息</li></ul><p>当然项目是基于SpringBoot开发的。</p><h2 id="开发实战"><a href="#开发实战" class="headerlink" title="开发实战"></a>开发实战</h2><p>在正式开发之前我推荐你在IDEA上安装一下 JS GraphQL插件，这个插件方便我们编写Schema，语法纠错，代码高亮等等。。。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uBPkL45bhWrKgWkOnQNUME0VLI5CevxknxPbyAAF5WCmIia8fdCMJJeg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="创建一个SpringBoot项目"><a href="#创建一个SpringBoot项目" class="headerlink" title="创建一个SpringBoot项目"></a>创建一个SpringBoot项目</h3><p>通过IDEA创建一个SpringBoot项目，并引入对应的jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--graphql start--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java-tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--graphql end--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里主要需要引入 <code>graphql-spring-boot-starter</code>和 <code>graphql-java-tools</code>。</p><h3 id="建立Java实体类"><a href="#建立Java实体类" class="headerlink" title="建立Java实体类"></a>建立Java实体类</h3><p>User</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Datapublic class User &#123;    private int userId;    private String userName;    private String realName;    private String email;    private List&lt;Post&gt; posts;    public User() &#123;    &#125;    public User(int userId, String userName, String realName, String email) &#123;        this.userId = userId;        this.userName = userName;        this.realName = realName;        this.email = email;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>Post</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Datapublic class Post &#123;    private int postId;    private String title ;    private String text;    private String  category;    private User user;    public Post() &#123;    &#125;    public Post(int postId, String title, String text, String category) &#123;        this.postId = postId;        this.title = title;        this.text = text;        this.category = category;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>定义了两个JAVA实体：Post，User。</p><h3 id="编写Schema文件"><a href="#编写Schema文件" class="headerlink" title="编写Schema文件"></a>编写Schema文件</h3><p>在resources&#x2F;schema目录下创建GraphQL Schema文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">schema <span class="punctuation">&#123;</span> </span><br><span class="line">query<span class="punctuation">:</span> Query<span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">type Query <span class="punctuation">&#123;</span> </span><br><span class="line"># 获取具体的用户   </span><br><span class="line">getUserById(id<span class="punctuation">:</span>Int) <span class="punctuation">:</span> User    </span><br><span class="line"># 获取具体的博客    </span><br><span class="line">getPostById(id<span class="punctuation">:</span>Int) <span class="punctuation">:</span> Post</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">type User </span><br><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">userId <span class="punctuation">:</span> ID!<span class="punctuation">,</span> </span><br><span class="line">userName <span class="punctuation">:</span> String<span class="punctuation">,</span></span><br><span class="line">realName <span class="punctuation">:</span> String<span class="punctuation">,</span>   </span><br><span class="line">email <span class="punctuation">:</span> String<span class="punctuation">,</span>   </span><br><span class="line">posts <span class="punctuation">:</span> <span class="punctuation">[</span>Post<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">type Post <span class="punctuation">&#123;</span>   </span><br><span class="line">postId <span class="punctuation">:</span> ID!<span class="punctuation">,</span>  </span><br><span class="line">title <span class="punctuation">:</span> String!<span class="punctuation">,</span>   </span><br><span class="line">text <span class="punctuation">:</span> String<span class="punctuation">,</span> </span><br><span class="line">category<span class="punctuation">:</span> String    </span><br><span class="line">user<span class="punctuation">:</span> User<span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如上，我们通过 <code>type</code>关键字定义了两个对象，User与Post。在属性后面添加！表明这是一个非空属性，通过[Post]表明这是一个Post集合，类似于Java对象中List。</p><p>通过Query关键字定义了两个查询对象，getUserById，getPostById，分别返回User对象和Post对象。</p><p>关于schema的语法大家可以参考链接：<code>https://graphql.org/learn/schema</code></p><h3 id="编写业务逻辑"><a href="#编写业务逻辑" class="headerlink" title="编写业务逻辑"></a>编写业务逻辑</h3><p>PostService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostService</span> <span class="keyword">implements</span> <span class="title class_">GraphQLQueryResolver</span> &#123; </span><br><span class="line"><span class="comment">/**     * 为了测试，只查询id为1的结果     */</span>    </span><br><span class="line"><span class="keyword">public</span> Post <span class="title function_">getPostById</span><span class="params">(<span class="type">int</span> id)</span>&#123;     </span><br><span class="line"><span class="keyword">if</span>(id == <span class="number">1</span>)&#123;        </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;JAVA日知录&quot;</span>,<span class="string">&quot;zhangsan@qq.com&quot;</span>);           </span><br><span class="line"><span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="number">1</span>,<span class="string">&quot;Hello,Graphql&quot;</span>,<span class="string">&quot;Graphql初体验&quot;</span>,<span class="string">&quot;日记&quot;</span>);           </span><br><span class="line">post.setUser(user);         </span><br><span class="line"><span class="keyword">return</span> post;       </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;       </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> <span class="keyword">implements</span> <span class="title class_">GraphQLQueryResolver</span> &#123; </span><br><span class="line">List&lt;User&gt; userList = Lists.newArrayList(); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>&#123;        </span><br><span class="line"><span class="keyword">return</span> userList.stream()</span><br><span class="line">.filter(item &gt; item.getUserId() == id)</span><br><span class="line">.findAny()</span><br><span class="line">.orElse(<span class="literal">null</span>);  </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">initUsers</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="type">Post</span> <span class="variable">post1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="number">1</span>,<span class="string">&quot;Hello,Graphql1&quot;</span>,<span class="string">&quot;Graphql初体验1&quot;</span>,<span class="string">&quot;日记&quot;</span>);      </span><br><span class="line"><span class="type">Post</span> <span class="variable">post2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="number">2</span>,<span class="string">&quot;Hello,Graphql2&quot;</span>,<span class="string">&quot;Graphql初体验2&quot;</span>,<span class="string">&quot;日记&quot;</span>);      </span><br><span class="line"><span class="type">Post</span> <span class="variable">post3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="number">3</span>,<span class="string">&quot;Hello,Graphql3&quot;</span>,<span class="string">&quot;Graphql初体验3&quot;</span>,<span class="string">&quot;日记&quot;</span>);      </span><br><span class="line">List&lt;Post&gt; posts = Lists.newArrayList(post1,post2,post3);    </span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;zhangsan@qq.com&quot;</span>);        </span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;lisi@qq.com&quot;</span>);        </span><br><span class="line">user1.setPosts(posts);        </span><br><span class="line">user2.setPosts(posts);        </span><br><span class="line">userList.add(user1);      </span><br><span class="line">userList.add(user2);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于Graphql的查询需要实现 <code>GraphQLQueryResolver</code>接口，由于为了便于演示我们并没有引入数据层，请大家知悉。</p><h3 id="配置Graphql-端点"><a href="#配置Graphql-端点" class="headerlink" title="配置Graphql 端点"></a>配置Graphql 端点</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port </span>=<span class="string"> 8080</span></span><br><span class="line"><span class="attr">graphql.servlet.corsEnabled</span>=<span class="string">true# 配置端点</span></span><br><span class="line"><span class="attr">graphql.servlet.mapping</span>=<span class="string">/graphql</span></span><br><span class="line"><span class="attr">graphql.servlet.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>配置完端口和端点后我们就可以对我们编写的Graphql接口进行测试了。</p><p>接口地址为：<code>localhost:8080/graphql</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这里我使用的是Chrome浏览器的 <code>Altair Graphal Client</code>插件，当然你还可以使用其他的客户端工具，如：graphql-playground。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>浏览器输入chrome:&#x2F;&#x2F;extensions&#x2F;，在扩展中心搜索Altair后即可添加至浏览器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uxnfmDuJRqzO2vicjlZzLvdiaLAB3X4rr0bMezgfbicEicvhXjuYE5QctdA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>启动SpringBoot项目，然后在打开的Altair插件界面，输入Graphql端点 <a href="http://localhost:8080/graphql%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB">http://localhost:8080/graphql，然后点击</a> <code>Docs</code>，将鼠标移至需要的查询上，点击 <code>ADD QUERY</code> 即可添加对应的查询。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uIkduYW1CQ0r4f8py1oOQQ76TZqsTfiacGicLEYxqg3dmfNkgvHost3rA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>点击Send Request 即可看到查询结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uMNlCkgiauNp7aiav2vSiclkBywh5H9vMGFyF9t5FOdrTaybVt87JCq1mA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后我们在Query中可以根据我们的需要新增或删除接口字段并重新请求接口，会看到响应结果中也会根据我们的请求自动返回结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1u7QatEVdg9FutWzOo5vicRTVnqfRMHt2GGLNgDyx19WHNWVW3PgJURiaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Graphql支持的数据操作有：</p><ul><li>查询（Query）：获取数据的基本查询。</li><li>变更（Mutation）：支持对数据的增删改等操作。</li><li>订阅（Subscription）：用于监听数据变动、并靠websocket等协议推送变动的消息给对方。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hKWblHWIXxabEXToROoS1uUGM03Go1mnHjOxvOY0jDHMIk5ouprdcWG3WlVHibJXSeF2snsfAa3vQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>本节内容我们基于SpringBoot完成了Query的数据操作，实现过程还是相对比较简单。希望此文能让大家对Graphql有一个整体的了解，如果大家对Graphql感兴趣后面还会更新此系列文章，完成对其他数据操作的整合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;REST作为一种现代网络应用非常流行的软件架构风格受到广大WEB开发者的喜爱，在目前软件架构设计模式中随处可见REST的身影，但是随着RES</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot启动参数</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/</id>
    <published>2024-09-02T09:02:25.399Z</published>
    <updated>2024-09-03T02:35:28.457Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span>  </span><br><span class="line">  <span class="attr">tomcat:</span>  </span><br><span class="line">    <span class="string">min-spare-threads:</span> <span class="number">20</span>  </span><br><span class="line">    <span class="string">max-threads:</span> <span class="number">100</span>  </span><br><span class="line">  <span class="string">connection-timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>目前的容器优化，目前来说没有太多地方，需要考虑如下几个点</p><ul><li>线程数</li><li>超时时间</li></ul><p>这块对tomcat进行了一个优化配置，最大线程数是100，初始化线程是20, 超时时间是5000ms</p><p>默认tomcat最大线程数200，初始化线程10, 连接超时时间20s</p><p>⚠️upload failed, check dev console</p><p>⚠️upload failed, check dev console</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Restful API 版本控制</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9ARestful%20API%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9ARestful%20API%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</id>
    <published>2024-09-02T08:47:53.483Z</published>
    <updated>2024-09-02T08:57:11.861Z</updated>
    
    <content type="html"><![CDATA[<p>在实际项目开发中我们经常需要对接口进行版本管理。那今天我们就来聊聊为什么需要版本控制，以及如何对REST API进行版本控制。我们将讨论4种版本控制的方法，并比较不同的方法。</p><p>通过此文您将学到</p><ul><li>为什么我们需要对RESTful API 进行版本控制?</li><li>可用的版本控制有哪些?</li><li>如何实现基于 Restful 的版本控制?</li></ul><h2 id="为什么我们需要对RESTful-API进行版本化"><a href="#为什么我们需要对RESTful-API进行版本化" class="headerlink" title="为什么我们需要对RESTful API进行版本化"></a>为什么我们需要对RESTful API进行版本化</h2><p>最好的版本控制方法是不进行版本控制。</p><blockquote><p>构建向后兼容的服务，以便尽可能避免版本控制！</p></blockquote><p>然而，在许多情况下我们都需要进行版本控制，然我们看看下面具体的例子：<br>最初，你有个这个版本的Student服务，返回数据如下：<br><code>&#123;     &quot;name&quot;: &quot;Bob Charlie&quot;   &#125;   </code></p><p>后来，您希望将学生的名字拆分，因此创建了这个版本的服务。<br><code>&#123;     &quot;name&quot;: &#123;       &quot;firstName&quot;: &quot;Bob&quot;,       &quot;lastName&quot;: &quot;Charlie&quot;     &#125;   &#125;   </code></p><p>您可以从同一个服务支持这两个请求，但是随着每个版本的需求多样化，它会变得越来越复杂。</p><p>在这种情况下，版本控制就成必不可少，强制性的了。</p><p>接下来让我们创建一个简单的SpringBoot的maven项目，并理解对 RESTful 服务进行版本控制的4种不同方法。</p><p><strong>几个用于实现版本控制的Bean</strong></p><p>第一个版本的 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="meta">@AllArgsConstructor</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentV1</span> &#123;      </span><br><span class="line"><span class="keyword">private</span> String name;   </span><br><span class="line">&#125;   `</span><br></pre></td></tr></table></figure><p>第二个版本的 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentV2</span> &#123;       </span><br><span class="line"><span class="keyword">private</span> Name name;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>StudentV2使用的Name实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="meta">@AllArgsConstructor</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Name</span> &#123;       </span><br><span class="line"><span class="keyword">private</span> String firstName;       </span><br><span class="line"><span class="keyword">private</span> String lastName;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="Restful-版本控制的方法"><a href="#Restful-版本控制的方法" class="headerlink" title="Restful 版本控制的方法"></a>Restful 版本控制的方法</h2><p>我们希望创建两个版本的服务，一个返回 StudentV1，另一个返回 StudentV2。</p><p>让我们来看看创建相同服务版本的4种不同方法。</p><h3 id="通过-URI-进行版本控制"><a href="#通过-URI-进行版本控制" class="headerlink" title="通过 URI 进行版本控制"></a>通过 URI 进行版本控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentUriController</span> &#123;       </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;v1/student&quot;)</span>     </span><br><span class="line"><span class="keyword">public</span> StudentV1 <span class="title function_">studentV1</span><span class="params">()</span> &#123;      </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV1</span>(<span class="string">&quot;javadaily&quot;</span>);      </span><br><span class="line">&#125;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;v2/student&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> StudentV2 <span class="title function_">studentV2</span><span class="params">()</span> &#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV2</span>(<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;javadaily&quot;</span>, <span class="string">&quot;JAVA日知录&quot;</span>));     </span><br><span class="line">&#125;      </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>请求：<code>http://localhost:8080/v1/student</code><br>响应：{“name”:”javadaily”}</p><p>请求：<code>http://localhost:8080/v2/student</code><br>响应：{“name”:{“firstName”:”javadaily”,”lastName”:”JAVA日知录”}}</p><h3 id="通过请求参数进行版本控制"><a href="#通过请求参数进行版本控制" class="headerlink" title="通过请求参数进行版本控制"></a>通过请求参数进行版本控制</h3><p>版本控制的第二种方法是使用请求参数来区分版本。请求示例如下所示：</p><ul><li><code>http://localhost:8080/student/param?version=1</code></li><li><code>http://localhost:8080/student/param?version=2</code></li></ul><p>实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentParmController</span> &#123;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/param&quot;, params = &quot;version=1&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> StudentV1 <span class="title function_">studentV1</span><span class="params">()</span> &#123;       </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV1</span>(<span class="string">&quot;javadaily&quot;</span>);       </span><br><span class="line">&#125;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/param&quot;, params = &quot;version=2&quot;)</span>       </span><br><span class="line"><span class="keyword">public</span> StudentV2 <span class="title function_">studentV2</span><span class="params">()</span> &#123;          </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV2</span>(<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;javadaily&quot;</span>, <span class="string">&quot;JAVA日知录&quot;</span>));    </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>请求：<code>http://localhost:8080/student/param?version=1</code><br>响应：{“name”:”javadaily”}</p><p>请求：<code>http://localhost:8080/student/param?version=2</code><br>响应：{“name”:{“firstName”:”javadaily”,”lastName”:”JAVA日知录”}}</p><h3 id="通过自定义Header进行版本控制"><a href="#通过自定义Header进行版本控制" class="headerlink" title="通过自定义Header进行版本控制"></a>通过自定义Header进行版本控制</h3><p>版本控制的第三种方法是使用请求头来区分版本，请求示例如下：</p><ul><li><code>http://localhost:8080/student/header</code><ul><li>headers&#x3D;[X-API-VERSION&#x3D;1]</li></ul></li><li><code>http://localhost:8080/student/header</code><ul><li>headers&#x3D;[X-API-VERSION&#x3D;2]</li></ul></li></ul><p>实现方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHeaderController</span> &#123;          </span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/header&quot;,headers = &quot;X-API-VERSION=1&quot;)</span>       </span><br><span class="line"><span class="keyword">public</span> StudentV1 <span class="title function_">studentV1</span><span class="params">()</span> &#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV1</span>(<span class="string">&quot;javadaily&quot;</span>);      </span><br><span class="line">&#125; </span><br><span class="line">        </span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/header&quot;,headers = &quot;X-API-VERSION=2&quot;)</span>       </span><br><span class="line"><span class="keyword">public</span> StudentV2 <span class="title function_">studentV2</span><span class="params">()</span> &#123;         </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV2</span>(<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;javadaily&quot;</span>, <span class="string">&quot;JAVA日知录&quot;</span>));  </span><br><span class="line">&#125; </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>下图展示了我们如何使用Postman执行带有请求头的Get请求方法。</p><p>请求：<code>http://localhost:8080/student/header</code><br>header：<code>X-API-VERSION = 1</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jqm35NaykhC1aTJn9JvXSrVp9EAUPqZFvz4vymuNoicVQxmlNlcUnTGUiaIQYomw129icfeWz9JTJhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>请求：<code>http://localhost:8080/student/header</code><br>header：<code>X-API-VERSION = 2</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jqm35NaykhC1aTJn9JvXSrSGm9CYoZ0Om5aZhSzk9xwQ4ArSNmiaZNcz4nddcBFsY9sux9RLfonFw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="通过媒体类型进行版本控制"><a href="#通过媒体类型进行版本控制" class="headerlink" title="通过媒体类型进行版本控制"></a>通过媒体类型进行版本控制</h3><p>最后一种版本控制方法是在请求中使用Accept Header，请求示例如下：</p><ul><li><code>http://localhost:8080/student/produce</code><ul><li><code>headers=[Accept=application/api-v1+json]</code></li></ul></li><li><code>http://localhost:8080/student/produce</code><ul><li><code>headers=[Accept=application/api-v2+json]</code></li></ul></li></ul><p>实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentProduceController</span> &#123;          </span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/produce&quot;,produces = &quot;application/api-v1+json&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> StudentV1 <span class="title function_">studentV1</span><span class="params">()</span> &#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV1</span>(<span class="string">&quot;javadaily&quot;</span>);       </span><br><span class="line">&#125;          </span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/student/produce&quot;,produces = &quot;application/api-v2+json&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> StudentV2 <span class="title function_">studentV2</span><span class="params">()</span> &#123;          </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentV2</span>(<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;javadaily&quot;</span>, <span class="string">&quot;JAVA日知录&quot;</span>));     </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>下图展示了我们如何使用Postman执行带有请求Accept的Get方法。</p><p>请求：<code>http://localhost:8080/student/produce</code><br>header：<code>Accept = application/api-v1+json</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jqm35NaykhC1aTJn9JvXSrib4ATp9xWVKnmcEb1C2bgSnnW4C0YZNu0cm12RJbwOf09j46u2Aia8Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>请求：<code>http://localhost:8080/student/produce</code><br>header：<code>Accept = application/api-v2+json</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jqm35NaykhC1aTJn9JvXSrgsjbiag7JvmpDEAqDibzq5Xt06LxYlN5r8E0eY8Gv2rFbvg4X66oLicog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="影响版本选择的因素"><a href="#影响版本选择的因素" class="headerlink" title="影响版本选择的因素"></a>影响版本选择的因素</h2><p>以下因素影响版本控制的选择</p><ul><li>URI 污染 - URL版本和请求参数版本控制会污染URI空间。</li><li>滥用请求头 - Accept 请求头并不是为版本控制而设计的。</li><li>缓存 - 如果你使用基于头的版本控制，我们不能仅仅基于URL缓存，你需要考虑特定的请求头。</li><li>是否能在浏览器直接执行 ? - 如果您有非技术消费者，那么基于URL的版本将更容易使用，因为它们可以直接在浏览器上执行。</li><li>API文档 - 如何让文档生成理解两个不同的url是同一服务的版本？</li></ul><blockquote><p>事实上，并没有完美的版本控制解决方案，你需要根据项目实际情况进行选择。</p></blockquote><p>下面列表展示了主要API提供商使用的不同版本控制方法：</p><ul><li>媒体类型的版本控制<ul><li>Github</li></ul></li><li>自定义Header<ul><li>Microsoft</li></ul></li><li>URI路径<ul><li>Twitter，百度，知乎</li></ul></li><li>请求参数控制<ul><li>Amazon</li></ul></li></ul><p>好了，今天的文章就到这里了，希望能对你有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在实际项目开发中我们经常需要对接口进行版本管理。那今天我们就来聊聊为什么需要版本控制，以及如何对REST API进行版本控制。我们将讨论4种版本控制的方法，并比较不同的方法。&lt;/p&gt;
&lt;p&gt;通过此文您将学到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么我们需要对RESTful API </summary>
      
    
    
    
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot参数校验</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</id>
    <published>2024-09-02T07:13:41.928Z</published>
    <updated>2024-09-03T02:35:16.366Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&mid=2247512866&idx=1&sn=f9d1549dc312c48a9fde14fb1fdb5d07&chksm=9ad3a963ada420756be6f848faef228d08b2ea49d87d2c083eabd6a2cf184cefa2ed8fa05964&cur_album_id=1517924978380308484&scene=189#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247512866&amp;idx=1&amp;sn=f9d1549dc312c48a9fde14fb1fdb5d07&amp;chksm=9ad3a963ada420756be6f848faef228d08b2ea49d87d2c083eabd6a2cf184cefa2ed8fa05964&amp;cur_album_id=1517924978380308484&amp;scene=189#wechat_redirect</a></p><p>首先我们来看看什么是Validator参数校验器，为什么需要参数校验？</p><h2 id="为什么需要参数校验"><a href="#为什么需要参数校验" class="headerlink" title="为什么需要参数校验"></a>为什么需要参数校验</h2><p>在日常的接口开发中，为了防止非法参数对业务造成影响，经常需要对接口的参数做校验，例如登录的时候需要校验用户名密码是否为空，创建用户的时候需要校验邮件、手机号码格式是否准确。靠代码对接口参数一个个校验的话就太繁琐了，代码可读性极差。</p><p>Validator框架就是为了解决开发人员在开发的时候少写代码，提升开发效率；<br>Validator专门用来进行接口参数校验，例如常见的必填校验，email格式校验，用户名必须位于6到12之间 等等…</p><blockquote><p>Validator校验框架遵循了JSR-303验证规范（参数校验规范）, JSR是<code>Java Specification Requests</code>的缩写。<br>接下来我们看看在SpringbBoot中如何集成参数校验框架。</p></blockquote><h2 id="SpringBoot中集成参数校验"><a href="#SpringBoot中集成参数校验" class="headerlink" title="SpringBoot中集成参数校验"></a>SpringBoot中集成参数校验</h2><h3 id="第一步，引入依赖"><a href="#第一步，引入依赖" class="headerlink" title="第一步，引入依赖"></a>第一步，引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：从<code>springboot-2.3</code>开始，校验包被独立成了一个<code>starter</code>组件，所以需要引入validation和web，而<code>springboot-2.3</code>之前的版本只需要引入 web 依赖就可以了。</p></blockquote><h3 id="第二步，定义要参数校验的实体类"><a href="#第二步，定义要参数校验的实体类" class="headerlink" title="第二步，定义要参数校验的实体类"></a>第二步，定义要参数校验的实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidVO</span> &#123;       </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String id;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@Length(min = 6,max = 12,message = &quot;appId长度必须位于6到12之间&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> String appId;         </span><br><span class="line"></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;名字为必填项&quot;)</span>      </span><br><span class="line"><span class="keyword">private</span> String name;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@Email(message = &quot;请填写正确的邮箱地址&quot;)</span>  </span><br><span class="line"><span class="keyword">private</span> String email;          </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String sex;        </span><br><span class="line"></span><br><span class="line"><span class="meta">@NotEmpty(message = &quot;级别不能为空&quot;)</span>     </span><br><span class="line"><span class="keyword">private</span> String level;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在实际开发中对于需要校验的字段都需要设置对应的业务提示，即message属性。<br>常见的约束注解如下：</p><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>可以为null,如果不为null的话必须为false</td></tr><tr><td>@AssertTrue</td><td>可以为null,如果不为null的话必须为true</td></tr><tr><td>@DecimalMax</td><td>设置不能超过最大值</td></tr><tr><td>@DecimalMin</td><td>设置不能超过最小值</td></tr><tr><td>@Digits</td><td>设置必须是数字且数字整数的位数和小数的位数必须在指定范围内</td></tr><tr><td>@Future</td><td>日期必须在当前日期的未来</td></tr><tr><td>@Past</td><td>日期必须在当前日期的过去</td></tr><tr><td>@Max</td><td>最大不得超过此最大值</td></tr><tr><td>@Min</td><td>最大不得小于此最小值</td></tr><tr><td>@NotNull</td><td>不能为null，可以是空</td></tr><tr><td>@Null</td><td>必须为null</td></tr><tr><td>@Pattern</td><td>必须满足指定的正则表达式</td></tr><tr><td>@Size</td><td>集合、数组、map等的size()值必须在指定范围内</td></tr><tr><td>@Email</td><td>必须是email格式</td></tr><tr><td>@Length</td><td>长度必须在指定范围内</td></tr><tr><td>@NotBlank</td><td>字符串不能为null,字符串trim()后也不能等于“”</td></tr><tr><td>@NotEmpty</td><td>不能为null，集合、数组、map等size()不能为0；字符串trim()后可以等于“”</td></tr><tr><td>@Range</td><td>值必须在指定范围内</td></tr><tr><td>@URL</td><td>必须是一个URL</td></tr></tbody></table><p>注：此表格只是简单的对注解功能的说明，并没有对每一个注解的属性进行说明；可详见源码。</p><p>在Controller层对需要参数校验的方法加上@Validated注解</p><ol><li><p>参数校验一般分为两类：在Controller使用模型接收数据时， @Validated注解直接放在该模型参数前即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;test1&quot;)</span>   <span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> ValidEntity validEntity)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test1 valid success&quot;</span>;  </span><br><span class="line">&#125;      </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;test3&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test3</span><span class="params">(<span class="meta">@Validated</span> ValidEntity validEntity)</span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test3 valid success&quot;</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当我们是直接在Controller层中的参数前，使用约束注解时，@Validated要直接放在类上  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;test2&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(<span class="meta">@Email</span> String email)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test2 valid success&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此时需要在主类上增加@Validated注解  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span>   </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo/valid&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidController</span> &#123;  </span><br><span class="line">...   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在参数校验时我们既可以使用@Validated也可以使用@Valid注解，两者功能大部分类似；<br>主要区别在于：<br>@Valid属于javax下的，而@Validated属于spring下；<br>@Valid支持嵌套校验、而@Validated不支持，@Validated支持分组，而@Valid不支持。<br>@Validated： 用在类、方法和方法参数上，但不能用于成员属性。<br>@Valid：可以用在方法、构造函数、方法参数和成员属性上<br>@Validated和@Valid支持混合使用</p></blockquote><h3 id="第三步，定义校验类进行测试"><a href="#第三步，定义校验类进行测试" class="headerlink" title="第三步，定义校验类进行测试"></a>第三步，定义校验类进行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>   </span><br><span class="line"><span class="meta">@Validated</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidController</span> &#123;         </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(&quot;RequestBody校验&quot;)</span>     </span><br><span class="line"><span class="meta">@PostMapping(&quot;/valid/test1&quot;)</span>          </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> ValidVO validVO)</span>&#123;           </span><br><span class="line">log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);           </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test1 valid success&quot;</span>;       </span><br><span class="line">&#125;    </span><br><span class="line">     </span><br><span class="line"><span class="meta">@ApiOperation(&quot;Form校验&quot;)</span>       </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/test2&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(<span class="meta">@Validated</span> ValidVO validVO)</span>&#123;  </span><br><span class="line">log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);          </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test2 valid success&quot;</span>;       </span><br><span class="line">&#125;         </span><br><span class="line">  </span><br><span class="line"><span class="meta">@ApiOperation(&quot;单参数校验&quot;)</span>       </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/test3&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test3</span><span class="params">(<span class="meta">@Email</span> String email)</span>&#123;   </span><br><span class="line">log.info(<span class="string">&quot;email is &#123;&#125;&quot;</span>, email);          </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;email valid success&quot;</span>;       </span><br><span class="line">&#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里我们先定义三个方法test1，test2，test3，test1使用了<code>@RequestBody</code>注解，用于接受前端发送的json数据，test2模拟表单提交，test3模拟单参数提交。注意，当使用单参数校验时需要在Controller上加上@Validated注解，否则不生效。</p><h3 id="第四步，体验效果"><a href="#第四步，体验效果" class="headerlink" title="第四步，体验效果"></a>第四步，体验效果</h3><ol><li>调用test1方法，提示的是<code>org.springframework.web.bind.MethodArgumentNotValidException</code>异常<br><code>POST http://localhost:8080/valid/test1   Content-Type: application/json      &#123;     &quot;id&quot;: 1,     &quot;level&quot;: &quot;12&quot;,     &quot;email&quot;: &quot;47693899&quot;,     &quot;appId&quot;: &quot;ab1c&quot;   &#125;  </code></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Validation failed for argument [0] in public java.lang.String com.jianzh5.blog.valid.ValidController.test1(com.jianzh5.blog.valid.ValidVO) with 3 errors: [Field error in object &#x27;validVO&#x27; on field &#x27;email&#x27;: rejected value [47693899]; codes [Email.validVO.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [validVO.email,email]; arguments []; default message [email],[Ljavax.validation.constraints.Pattern$Flag;@26139123,.*]; default message [不是一个合法的电子邮件地址]]...&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628239624332</span>  </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><ol start="2"><li>调用test2方法，提示的是<code>org.springframework.validation.BindException</code>异常<br><code>POST http://localhost:8080/valid/test2   Content-Type: application/x-www-form-urlencoded      id=1&amp;level=12&amp;email=476938977&amp;appId=ab1c   </code></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.validation.BeanPropertyBindingResult: 3 errors\nField error in object &#x27;validVO&#x27; on field &#x27;name&#x27;: rejected value [null]; codes [NotBlank.validVO.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [validVO.name,name]; arguments []; default message [name]]; default message [名字为必填项]...&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"> <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"> <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628239301951</span>   </span><br><span class="line"> <span class="punctuation">&#125;</span>  ```</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 调用test3方法，提示的是`javax.validation.ConstraintViolationException`异常</span><br><span class="line">`POST http<span class="punctuation">:</span><span class="comment">//localhost:8080/valid/test3   Content-Type: application/x-www-form-urlencoded      email=476938977   `</span></span><br><span class="line"></span><br><span class="line">```json </span><br><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>   </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test3.email: 不是一个合法的电子邮件地址&quot;</span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628239281022</span>  </span><br><span class="line"> <span class="punctuation">&#125;</span>  </span><br></pre></td></tr></table></figure><p>通过加入<code>Validator</code>校验框架可以帮助我们自动实现参数的校验。</p><h2 id="参数异常加入全局异常处理器"><a href="#参数异常加入全局异常处理器" class="headerlink" title="参数异常加入全局异常处理器"></a>参数异常加入全局异常处理器</h2><p>虽然我们之前定义了全局异常拦截器，也看到了拦截器确实生效了，但是<code>Validator</code>校验框架返回的错误提示太臃肿了，不便于阅读，为了方便前端提示，我们需要将其简化一下。</p><p>直接修改之前定义的<code>RestExceptionHandler</code>，单独拦截参数校验的三个异常：<code>javax.validation.ConstraintViolationException</code>，<code>org.springframework.validation.BindException</code>，<code>org.springframework.web.bind.MethodArgumentNotValidException</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(value = &#123;BindException.class, </span></span><br><span class="line"><span class="meta">ValidationException.class, </span></span><br><span class="line"><span class="meta">MethodArgumentNotValidException.class&#125;)</span>   </span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;ResultData&lt;String&gt;&gt; <span class="title function_">handleValidatedException</span><span class="params">(Exception e)</span> </span><br><span class="line">&#123;  </span><br><span class="line">ResultData&lt;String&gt; resp = <span class="literal">null</span>;       </span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;       </span><br><span class="line"><span class="comment">// BeanValidation exception   </span></span><br><span class="line"><span class="type">MethodArgumentNotValidException</span> <span class="variable">ex</span> <span class="operator">=</span> (MethodArgumentNotValidException) e;</span><br><span class="line"></span><br><span class="line">resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),                              ex.getBindingResult().getAllErrors().stream()                              .map(ObjectError::getDefaultMessage)                              .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))                             );   </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConstraintViolationException) &#123;   </span><br><span class="line">  <span class="comment">// BeanValidation GET simple param       </span></span><br><span class="line">  <span class="type">ConstraintViolationException</span> <span class="variable">ex</span> <span class="operator">=</span> (ConstraintViolationException) e;       </span><br><span class="line">  resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),                              ex.getConstraintViolations().stream()                              .map(ConstraintViolation::getMessage)                              .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))                             );     </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) &#123;       </span><br><span class="line">  <span class="comment">// BeanValidation GET object param   </span></span><br><span class="line">  <span class="type">BindException</span> <span class="variable">ex</span> <span class="operator">=</span> (BindException) e;   </span><br><span class="line">  resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),                              ex.getAllErrors().stream()                              .map(ObjectError::getDefaultMessage)                              .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))                             );    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(resp,HttpStatus.BAD_REQUEST);   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>默认情况下在对参数进行校验时Spring Validation会校验完所有字段然后才抛出异常，可以通过配置开启 <code>Fali Fast</code>模式，一旦校验失败就立即返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidatedConfig</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Validator <span class="title function_">validator</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">ValidatorFactory</span> <span class="variable">validatorFactory</span> <span class="operator">=</span> Validation.byProvider(HibernateValidator.class)  </span><br><span class="line">                .configure()  </span><br><span class="line">                <span class="comment">// 快速失败模式  </span></span><br><span class="line">                .failFast(<span class="literal">true</span>)  </span><br><span class="line">                .buildValidatorFactory();  </span><br><span class="line">        <span class="keyword">return</span> validatorFactory.getValidator();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="体验效果"><a href="#体验效果" class="headerlink" title="体验效果"></a>体验效果</h3><p><code>POST http://localhost:8080/valid/test1   Content-Type: application/json      &#123;     &quot;id&quot;: 1,     &quot;level&quot;: &quot;12&quot;,     &quot;email&quot;: &quot;47693899&quot;,     &quot;appId&quot;: &quot;ab1c&quot;   &#125;   </code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;名字为必填项; 不是一个合法的电子邮件地址; appId长度必须位于6到12之间&quot;</span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628435116680</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>是不是感觉清爽多了？</p><h2 id="自定义参数校验"><a href="#自定义参数校验" class="headerlink" title="自定义参数校验"></a>自定义参数校验</h2><p>虽然Spring Validation 提供的注解基本上够用，但是面对复杂的定义，我们还是需要自己定义相关注解来实现自动校验。</p><p>比如上面实体类中的sex性别属性，只允许前端传递传 M，F 这2个枚举值，如何实现呢？</p><h3 id="第一步，创建自定义注解"><a href="#第一步，创建自定义注解" class="headerlink" title="第一步，创建自定义注解"></a>第一步，创建自定义注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span>   <span class="meta">@Retention(RUNTIME)</span> </span><br><span class="line"><span class="meta">@Repeatable(EnumString.List.class)</span>   </span><br><span class="line"><span class="meta">@Documented</span>  </span><br><span class="line"><span class="meta">@Constraint(validatedBy = EnumStringValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnumString &#123;   </span><br><span class="line"></span><br><span class="line">String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;value not in enum values.&quot;</span>;         </span><br><span class="line">Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;        </span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] value();         </span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span>       </span><br><span class="line"><span class="meta">@Documented</span>       </span><br><span class="line"><span class="meta">@interface</span> List &#123;              </span><br><span class="line">EnumString[] value();       </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="第二步，自定义校验逻辑"><a href="#第二步，自定义校验逻辑" class="headerlink" title="第二步，自定义校验逻辑"></a>第二步，自定义校验逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumStringValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;EnumString, String&gt; &#123;       </span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; enumStringList;       </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Override</span>      </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(EnumString constraintAnnotation)</span> &#123;   </span><br><span class="line">enumStringList = Arrays.asList(constraintAnnotation.value());       </span><br><span class="line">&#125;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;   </span><br><span class="line"><span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;          </span><br><span class="line">&#125;          </span><br><span class="line"><span class="keyword">return</span> enumStringList.contains(value);   </span><br><span class="line">&#125;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="第三步，在字段上增加注解"><a href="#第三步，在字段上增加注解" class="headerlink" title="第三步，在字段上增加注解"></a>第三步，在字段上增加注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;性别&quot;)</span>  </span><br><span class="line"><span class="meta">@EnumString(value = &#123;&quot;F&quot;,&quot;M&quot;&#125;, message=&quot;性别只允许为F或M&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> String sex;   </span><br></pre></td></tr></table></figure><h3 id="第四步，体验效果-1"><a href="#第四步，体验效果-1" class="headerlink" title="第四步，体验效果"></a>第四步，体验效果</h3><p><code>POST http://localhost:8080/valid/test2   Content-Type: application/x-www-form-urlencoded      id=1&amp;name=javadaily&amp;level=12&amp;email=476938977@qq.com&amp;appId=ab1cdddd&amp;sex=N   </code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;性别只允许为F或M&quot;</span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628435243723</span>   </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p>一个VO对象在新增的时候某些字段为必填，在更新的时候又非必填。如上面的<code>ValidVO</code>中 id 和 appId 属性在新增操作时都是非必填，而在编辑操作时都为必填，name在新增操作时为必填，面对这种场景你会怎么处理呢？</p><p>在实际开发中我见到很多同学都是建立两个VO对象，<code>ValidCreateVO</code>，<code>ValidEditVO</code>来处理这种场景，这样确实也能实现效果，但是会造成类膨胀，而且极其容易被开发老鸟们嘲笑。</p><p>其实<code>Validator</code>校验框架已经考虑到了这种场景并且提供了解决方案，就是分组校验，只不过很多同学不知道而已。要使用分组校验，只需要三个步骤：</p><h3 id="第一步：定义分组接口"><a href="#第一步：定义分组接口" class="headerlink" title="第一步：定义分组接口"></a>第一步：定义分组接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidGroup</span> <span class="keyword">extends</span> <span class="title class_">Default</span> &#123;       </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Crud</span> <span class="keyword">extends</span> <span class="title class_">ValidGroup</span>&#123;         </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Create</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;&#125;           </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Update</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;&#125;             </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Query</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;&#125;             </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Delete</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;&#125;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这里我们定义一个分组接口ValidGroup让其继承<code>javax.validation.groups.Default</code>，再在分组接口中定义出多个不同的操作类型，Create，Update，Query，Delete。至于为什么需要继承Default我们稍后再说。</p><h3 id="第二步，在模型中给参数分配分组"><a href="#第二步，在模型中给参数分配分组" class="headerlink" title="第二步，在模型中给参数分配分组"></a>第二步，在模型中给参数分配分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="meta">@ApiModel(value = &quot;参数校验类&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidVO</span> &#123;       </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModelProperty(&quot;ID&quot;)</span>       </span><br><span class="line"><span class="meta">@Null(groups = ValidGroup.Crud.Create.class)</span>  </span><br><span class="line"><span class="meta">@NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> String id;         </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Null(groups = ValidGroup.Crud.Create.class)</span>     </span><br><span class="line"><span class="meta">@NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;)</span>    </span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;应用ID&quot;,example = &quot;cloud&quot;)</span>      </span><br><span class="line"><span class="keyword">private</span> String appId;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;名字&quot;)</span>      </span><br><span class="line"><span class="meta">@NotBlank(groups = ValidGroup.Crud.Create.class,message = &quot;名字为必填项&quot;)</span>      </span><br><span class="line"><span class="keyword">private</span> String name;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;邮箱&quot;)</span>    </span><br><span class="line"><span class="meta">@Email(message = &quot;请填写正取的邮箱地址&quot;)</span>       </span><br><span class="line"><span class="keyword">private</span> String email;        </span><br><span class="line">...      </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>给参数指定分组，对于未指定分组的则使用的是默认分组。</p><h3 id="第三步，给需要参数校验的方法指定分组"><a href="#第三步，给需要参数校验的方法指定分组" class="headerlink" title="第三步，给需要参数校验的方法指定分组"></a>第三步，给需要参数校验的方法指定分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   </span><br><span class="line"><span class="meta">@Api(&quot;参数校验&quot;)</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>   </span><br><span class="line"><span class="meta">@Validated</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidController</span> &#123;         </span><br><span class="line"><span class="meta">@ApiOperation(&quot;新增&quot;)</span>       </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/add&quot;)</span>       </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Create.class)</span> ValidVO validVO)</span></span><br><span class="line">&#123;          </span><br><span class="line">log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);           </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test3 valid success&quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(&quot;更新&quot;)</span> </span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/update&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Update.class)</span> ValidVO validVO)</span></span><br><span class="line">&#123;           </span><br><span class="line">log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO); </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test4 valid success&quot;</span>;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这里我们通过<code>value</code>属性给<code>add()</code>和<code>update()</code>方法分别指定Create和Update分组。</p><h3 id="第四步，体验效果-2"><a href="#第四步，体验效果-2" class="headerlink" title="第四步，体验效果"></a>第四步，体验效果</h3><p><code>POST http://localhost:8080/valid/add   Content-Type: application/x-www-form-urlencoded      name=javadaily&amp;level=12&amp;email=476938977@qq.com&amp;sex=F   </code></p><p>在Create时我们没有传递id和appId参数，校验通过。</p><p>当我们使用同样的参数调用update方法时则提示参数校验错误。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ID不能为空; 应用ID不能为空&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628492514313</span>  </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>由于email属于默认分组，而我们的分组接口<code>ValidGroup</code>已经继承了<code>Default</code>分组，所以也是可以对email字段作参数校验的。如：</p><p><code>POST http://localhost:8080/valid/add   Content-Type: application/x-www-form-urlencoded      name=javadaily&amp;level=12&amp;email=476938977&amp;sex=F   </code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请填写正取的邮箱地址&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628492637305</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>当然如果你的ValidGroup没有继承Default分组，那在代码属性上就需要加上<code>@Validated(value = &#123;ValidGroup.Crud.Create.class, Default.class&#125;</code>才能让<code>email</code>字段的校验生效。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>参数校验在实际开发中使用频率非常高，但是很多同学还只是停留在简单的使用上，像分组校验，自定义参数校验这2个高阶技巧基本没怎么用过，经常出现譬如建立多个VO用于接受Create，Update场景的情况，很容易被老鸟被所鄙视嘲笑，希望大家好好掌握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247512866&amp;idx=1&amp;sn=f9d1549dc312c48a9fde14fb1fdb5d07&amp;chksm=9ad3a963ada4207</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot统一返回格式</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/SpringBoot/SpringBoot%EF%BC%9A%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-09-02T06:39:47.310Z</published>
    <updated>2024-09-03T02:35:20.472Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&mid=2247492641&idx=1&sn=23f42094f442f382581d4bcdd191e12a&chksm=9ad3fe60ada47776313cc10f4b5ed50cfebd9d21bd4bee54698c8e8d3ddf89d1c81e98665743&scene=21#wechat_redirect">http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247492641&amp;idx=1&amp;sn=23f42094f442f382581d4bcdd191e12a&amp;chksm=9ad3fe60ada47776313cc10f4b5ed50cfebd9d21bd4bee54698c8e8d3ddf89d1c81e98665743&amp;scene=21#wechat_redirect</a></p><p>基于SpringBoot前后端分离开发模式下，如何友好的返回统一的标准格式以及如何优雅的处理全局异常。<br>首先我们来看看为什么要返回统一的标准格式？</p><h2 id="为什么要对SpringBoot返回统一的标准格式"><a href="#为什么要对SpringBoot返回统一的标准格式" class="headerlink" title="为什么要对SpringBoot返回统一的标准格式"></a>为什么要对SpringBoot返回统一的标准格式</h2><p>在默认情况下，SpringBoot的返回格式常见的有三种：</p><p>第一种：返回 String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span>&#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello,javadaily&quot;</span>;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>此时调用接口获取到的返回值是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,javadaily   </span><br></pre></td></tr></table></figure><p>第二种：返回自定义对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/aniaml&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> Aniaml <span class="title function_">getAniaml</span><span class="params">()</span>&#123;     </span><br><span class="line"><span class="type">Aniaml</span> <span class="variable">aniaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Aniaml</span>(<span class="number">1</span>,<span class="string">&quot;pig&quot;</span>);     </span><br><span class="line"><span class="keyword">return</span> aniaml;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>此时调用接口获取到的返回值是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pig&quot;</span> <span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>第三种：接口异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/error&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">error</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>/<span class="number">0</span>;       </span><br><span class="line"><span class="keyword">return</span> i;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此时调用接口获取到的返回值是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-07-08T08:05:15.423+00:00&quot;</span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/wrong&quot;</span>   </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>基于以上种种情况，如果你和前端开发人员联调接口她们就会很懵逼，由于我们没有给他一个统一的格式，前端人员不知道如何处理返回值。</p><p>还有甚者，有的同学比如小张喜欢对结果进行封装，他使用了Result对象，小王也喜欢对结果进行包装，但是他却使用的是Response对象，当出现这种情况时我相信前端人员一定会抓狂的。</p><p>所以我们项目中是需要定义一个统一的标准返回格式的。</p><h2 id="定义返回标准格式"><a href="#定义返回标准格式" class="headerlink" title="定义返回标准格式"></a>定义返回标准格式</h2><p>一个标准的返回格式至少包含3部分：</p><ol><li>status 状态值：由后端统一定义各种返回结果的状态码</li><li>message 描述：本次接口调用的结果描述</li><li>data 数据：本次返回的数据。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;100&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;操作成功&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="string">&quot;hello,javadaily&quot;</span>   </span><br><span class="line"><span class="punctuation">&#125;</span>  </span><br></pre></td></tr></table></figure>当然也可以按需加入其他扩展值，比如接口调用时间</li><li>timestamp: 接口调用时间</li></ol><h3 id="定义返回对象"><a href="#定义返回对象" class="headerlink" title="定义返回对象"></a>定义返回对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultData</span>&lt;T&gt; &#123;     </span><br><span class="line"><span class="comment">/** 结果状态 ,具体状态码参见ResultData.java*/</span>     </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> status;     </span><br><span class="line"><span class="keyword">private</span> String message;     </span><br><span class="line"><span class="keyword">private</span> T data;     </span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> timestamp ;           </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ResultData</span> <span class="params">()</span>&#123;       </span><br><span class="line"><span class="built_in">this</span>.timestamp = System.currentTimeMillis();     </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultData&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">ResultData&lt;T&gt; resultData = <span class="keyword">new</span> <span class="title class_">ResultData</span>&lt;&gt;();</span><br><span class="line">resultData.setStatus(ReturnCode.RC100.getCode());</span><br><span class="line">resultData.setMessage(ReturnCode.RC100.getMessage());</span><br><span class="line">resultData.setData(data);</span><br><span class="line"><span class="keyword">return</span> resultData;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultData&lt;T&gt; <span class="title function_">fail</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">ResultData&lt;T&gt; resultData = <span class="keyword">new</span> <span class="title class_">ResultData</span>&lt;&gt;();</span><br><span class="line">resultData.setStatus(code);</span><br><span class="line">resultData.setMessage(message);</span><br><span class="line"><span class="keyword">return</span> resultData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="定义状态码"><a href="#定义状态码" class="headerlink" title="定义状态码"></a>定义状态码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ReturnCode</span> &#123;         </span><br><span class="line">RC100(<span class="number">100</span>,<span class="string">&quot;操作成功&quot;</span>),         </span><br><span class="line">RC999(<span class="number">999</span>,<span class="string">&quot;操作失败&quot;</span>),        </span><br><span class="line">RC200(<span class="number">200</span>,<span class="string">&quot;服务开启限流保护,请稍后再试!&quot;</span>),       </span><br><span class="line">RC201(<span class="number">201</span>,<span class="string">&quot;服务开启降级保护,请稍后再试!&quot;</span>),          </span><br><span class="line">RC202(<span class="number">202</span>,<span class="string">&quot;热点参数限流,请稍后再试!&quot;</span>),         </span><br><span class="line">RC203(<span class="number">203</span>,<span class="string">&quot;系统规则不满足要求,请稍后再试!&quot;</span>),     </span><br><span class="line">RC204(<span class="number">204</span>,<span class="string">&quot;授权规则不通过,请稍后再试!&quot;</span>),    </span><br><span class="line">RC403(<span class="number">403</span>,<span class="string">&quot;无访问权限,请联系管理员授予权限&quot;</span>),      </span><br><span class="line">RC401(<span class="number">401</span>,<span class="string">&quot;匿名用户访问无权限资源时的异常&quot;</span>),   </span><br><span class="line">RC500(<span class="number">500</span>,<span class="string">&quot;系统异常，请稍后重试&quot;</span>),          </span><br><span class="line">INVALID_TOKEN(<span class="number">2001</span>,<span class="string">&quot;访问令牌不合法&quot;</span>),       </span><br><span class="line">ACCESS_DENIED(<span class="number">2003</span>,<span class="string">&quot;没有权限访问该资源&quot;</span>),   </span><br><span class="line">CLIENT_AUTHENTICATION_FAILED(<span class="number">1001</span>,<span class="string">&quot;客户端认证失败&quot;</span>),</span><br><span class="line">USERNAME_OR_PASSWORD_ERROR(<span class="number">1002</span>,<span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line">UNSUPPORTED_GRANT_TYPE(<span class="number">1003</span>, <span class="string">&quot;不支持的认证模式&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String message;          </span><br><span class="line"></span><br><span class="line">ReturnCode(<span class="type">int</span> code, String message)&#123;           </span><br><span class="line"><span class="built_in">this</span>.code = code;           </span><br><span class="line"><span class="built_in">this</span>.message = message;       </span><br><span class="line">&#125;             </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;           </span><br><span class="line"><span class="keyword">return</span> code;       </span><br><span class="line">&#125;         </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;   </span><br><span class="line"><span class="keyword">return</span> message;     </span><br><span class="line">&#125;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="统一返回格式"><a href="#统一返回格式" class="headerlink" title="统一返回格式"></a>统一返回格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> ResultData&lt;String&gt; <span class="title function_">getStr</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ResultData.success(<span class="string">&quot;hello,javadaily&quot;</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此时调用接口获取到的返回值是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello,javadaily&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625736481648</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;httpStatus&quot;</span><span class="punctuation">:</span> <span class="number">0</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>这样确实已经实现了我们想要的结果，我在很多项目中看到的都是这种写法，在Controller层通过<code>ResultData.success()</code>对返回结果进行包装后返回给前端。</p><p>看到这里我们不妨停下来想想，这样做有什么弊端呢？</p><p>最大的弊端就是我们后面每写一个接口都需要调用<code>ResultData.success()</code>这行代码对结果进行包装，重复劳动，浪费体力；  </p><p>而且还很容易被其他老鸟给嘲笑。</p><p>所以呢我们需要对代码进行优化，目标就是不要每个接口都手工制定<code>ResultData</code>返回值。</p><h3 id="高级实现方式"><a href="#高级实现方式" class="headerlink" title="高级实现方式"></a>高级实现方式</h3><p>要优化这段代码很简单，我们只需要借助SpringBoot提供的<code>ResponseBodyAdvice</code>即可。</p><blockquote><p>ResponseBodyAdvice的作用：拦截Controller方法的返回值，统一处理返回值&#x2F;响应体，一般用来统一返回格式，加解密，签名等等。</p></blockquote><p>先来看下<code>ResponseBodyAdvice</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResponseBodyAdvice</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="comment">/**     * 是否支持advice功能     * true 支持，false 不支持     */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter var1, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; var2)</span>;</span><br><span class="line"><span class="comment">/**     * 对返回的数据进行处理     */</span></span><br><span class="line"><span class="meta">@Nullable</span> T <span class="title function_">beforeBodyWrite</span><span class="params">(<span class="meta">@Nullable</span> T var1, MethodParameter var2, MediaType var3, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; var4, ServerHttpRequest var5, ServerHttpResponse var6)</span>;   </span><br><span class="line">&#125;   `</span><br></pre></td></tr></table></figure><p>我们只需要编写一个具体实现类即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span>   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;       <span class="meta">@Autowired</span>       </span><br><span class="line"><span class="keyword">private</span> ObjectMapper objectMapper;          </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> &#123;          </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="meta">@SneakyThrows</span>       </span><br><span class="line"><span class="meta">@Override</span>       <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> </span><br><span class="line">&#123;           </span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)&#123;               <span class="keyword">return</span> objectMapper.writeValueAsString(ResultData.success(o));           &#125;                   </span><br><span class="line"><span class="keyword">return</span> ResultData.success(o);       </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>需要注意两个地方：</p><ul><li><code>@RestControllerAdvice</code>是<code>@RestController</code>注解的增强，可以实现三个方面的功能：<ol><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ol></li><li>String类型判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line"><span class="keyword">return</span> objectMapper.writeValueAsString(ResultData.success(o));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这段代码一定要加，如果Controller直接返回String的话，SpringBoot是直接返回，故我们需要手动转换成json。<br>经过上面的处理我们就再也不需要通过<code>ResultData.success()</code>来进行转换了，直接返回原始数据格式，SpringBoot自动帮我们实现包装类的封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello,javadaily&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们调用接口返回的数据结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello,javadaily&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625736481648</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;httpStatus&quot;</span><span class="punctuation">:</span> <span class="number">0</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> ```</span><br><span class="line">是不是感觉很完美，别急，还有个问题在等着你呢。</span><br><span class="line"></span><br><span class="line">### 接口异常问题</span><br><span class="line"></span><br><span class="line">此时有个问题，由于我们没对Controller的异常进行处理，当我们调用的方法一旦出现异常，就会出现问题，比如下面这个接口</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@GetMapping(<span class="string">&quot;/wrong&quot;</span>)  </span><br><span class="line">public int error()<span class="punctuation">&#123;</span>       </span><br><span class="line">int i = <span class="number">9</span>/<span class="number">0</span>;       </span><br><span class="line">return i;   </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回的结果为：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gOa4vJmA3Iz2aqv8C4e699F4vXppP4LAnKTsuvSGEfsU3NulReBHdmsX4Vic8n1EeopTPL8OLwwJw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这显然不是我们想要的结果，接口都报错了还返回操作成功的响应码，前端看了会打人的。<br>别急，接下来我们进入第二个议题，如何优雅的处理全局异常。</p><h2 id="SpringBoot为什么需要全局异常处理器"><a href="#SpringBoot为什么需要全局异常处理器" class="headerlink" title="SpringBoot为什么需要全局异常处理器"></a>SpringBoot为什么需要全局异常处理器</h2><ol><li>不用手写try…catch，由全局异常处理器统一捕获</li></ol><p>使用全局异常处理器最大的便利就是程序员在写代码时不再需要手写<code>try...catch</code>了，前面我们讲过，默认情况下SpringBoot出现异常时返回的结果是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-07-08T08:05:15.423+00:00&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/wrong&quot;</span>   </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>这种数据格式返回给前端，前端是看不懂的，所以这时候我们一般通过<code>try...catch</code>来处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/wrong&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">error</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="type">int</span> i;       </span><br><span class="line"><span class="keyword">try</span>&#123;          </span><br><span class="line">i = <span class="number">9</span>/<span class="number">0</span>;       </span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;         </span><br><span class="line">log.error(<span class="string">&quot;error:&#123;&#125;&quot;</span>, e);        </span><br><span class="line">i = <span class="number">0</span>;      </span><br><span class="line">&#125;       </span><br><span class="line"><span class="keyword">return</span> i;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们追求的目标肯定是不需要再手动写<code>try...catch</code>了，而是希望由全局异常处理器处理。</p><ol start="2"><li><p>对于自定义异常，只能通过全局异常处理器来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;error1&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empty</span><span class="params">()</span>&#123;    </span><br><span class="line"><span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;自定义异常&quot;</span>);   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p>当我们引入Validator参数校验器的时候，参数校验不通过会抛出异常，此时是无法用<code>try...catch</code>捕获的，只能使用全局异常处理器。</p></li></ol><h3 id="如何实现全局异常处理器"><a href="#如何实现全局异常处理器" class="headerlink" title="如何实现全局异常处理器"></a>如何实现全局异常处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>   </span><br><span class="line"><span class="meta">@RestControllerAdvice</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestExceptionHandler</span> &#123;       </span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span>       </span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span>       </span><br><span class="line"><span class="keyword">public</span> ResultData&lt;String&gt; <span class="title function_">exception</span><span class="params">(Exception e)</span> &#123;           </span><br><span class="line">log.error(<span class="string">&quot;全局异常信息 ex=&#123;&#125;&quot;</span>, e.getMessage(), e);          </span><br><span class="line"><span class="keyword">return</span> ResultData.fail(ReturnCode.RC500.getCode(), e.getMessage());    </span><br><span class="line">&#125;      </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>有三个细节需要说明一下：</p><ol><li><code>@RestControllerAdvice</code>，RestController的增强类，可用于实现全局异常处理器</li><li><code>@ExceptionHandler</code>,统一处理某一类异常，从而减少代码重复率和复杂度，比如要获取自定义异常可以<code>@ExceptionHandler(BusinessException.class)</code></li><li><code>@ResponseStatus</code>指定客户端收到的http状态码</li></ol><h3 id="体验效果"><a href="#体验效果" class="headerlink" title="体验效果"></a>体验效果</h3><p>这时候我们调用如下接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;error1&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empty</span><span class="params">()</span>&#123;       </span><br><span class="line"><span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;自定义异常&quot;</span>);   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>返回的结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义异常&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625795902556</span>  </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>基本满足我们的需求了。</p><p>但是当我们同时启用统一标准格式封装功能<code>ResponseAdvice</code>和<code>RestExceptionHandler</code>全局异常处理器时又出现了新的问题：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;操作成功&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>       </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>       </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义异常&quot;</span><span class="punctuation">,</span>       </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>       </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625796167986</span>     </span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625796168008</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>此时返回的结果是这样，统一格式增强功能会给返回的异常结果再次封装，所以接下来我们需要解决这个问题。</p><h3 id="全局异常接入返回的标准格式"><a href="#全局异常接入返回的标准格式" class="headerlink" title="全局异常接入返回的标准格式"></a>全局异常接入返回的标准格式</h3><p>要让全局异常接入标准格式很简单，因为全局异常处理器已经帮我们封装好了标准格式，我们只需要直接返回给客户端即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span>   </span><br><span class="line"><span class="meta">@Override</span>   </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> </span><br><span class="line">&#123;     </span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)&#123;       </span><br><span class="line"><span class="keyword">return</span> objectMapper.writeValueAsString(ResultData.success(o));     </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> ResultData)&#123;       </span><br><span class="line"><span class="keyword">return</span> o; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> ResultData.success(o); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> ResultData)&#123;     </span><br><span class="line"><span class="keyword">return</span> o;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>如果返回的结果是ResultData对象，直接返回即可。</p><p>这时候我们再调用上面的错误方法，返回的结果就符合我们的要求了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义异常&quot;</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span>    </span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1625796580778</span>  </span><br><span class="line"><span class="punctuation">&#125;</span>   </span><br></pre></td></tr></table></figure><p>希望通过这篇文章你能掌握如何在你项目中友好实现统一标准格式到返回并且可以优雅的处理全局异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;mid=2247492641&amp;idx=1&amp;sn=23f42094f442f382581d4bcdd191e12a&amp;chksm=9ad3fe60ada47776</summary>
      
    
    
    
    
    <category term="Java" scheme="https://andy-whb-cn.github.io/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向接口：幂等性</title>
    <link href="https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://andy-whb-cn.github.io/2024/09/02/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2024-09-02T02:59:25.925Z</published>
    <updated>2024-09-02T10:49:12.127Z</updated>
    
    <content type="html"><![CDATA[<p>原文（<a href="https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg%EF%BC%89">https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg）</a></p><h1 id="一、什么是幂等性"><a href="#一、什么是幂等性" class="headerlink" title="一、什么是幂等性"></a>一、什么是幂等性</h1><p>幂等是一个数学与计算机学概念，在数学中某一元运算为幂等时，其作用在任一元素两次后会和其作用一次的结果相同。</p><p>在计算机中编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数或幂等方法是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p><h1 id="二、什么是接口幂等性"><a href="#二、什么是接口幂等性" class="headerlink" title="二、什么是接口幂等性"></a>二、什么是接口幂等性</h1><p>在HTTP&#x2F;1.1中，对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。</p><p>这里的副作用是不会对结果产生破坏或者产生不可预料的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><h1 id="三、为什么需要实现幂等性"><a href="#三、为什么需要实现幂等性" class="headerlink" title="三、为什么需要实现幂等性"></a>三、为什么需要实现幂等性</h1><p>在接口调用时一般情况下都能正常返回信息不会重复提交，不过在遇见以下情况时可以就会出现问题，如：</p><ul><li><strong>前端重复提交表单：</strong> 在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。</li><li><strong>用户恶意进行刷单：</strong> 例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。</li><li><strong>接口超时重复提交：</strong> 很多时候 HTTP 客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。</li><li><strong>消息进行重复消费：</strong> 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。<br>使用幂等性最大的优势在于使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。</li></ul><h1 id="四、引入幂等性后对系统的影响"><a href="#四、引入幂等性后对系统的影响" class="headerlink" title="四、引入幂等性后对系统的影响"></a>四、引入幂等性后对系统的影响</h1><p>幂等性是为了简化客户端逻辑处理，能放置重复提交等操作，但却增加了服务端的逻辑复杂性和成本，其主要是：</p><ul><li>把并行执行的功能改为串行执行，降低了执行效率。</li><li>增加了额外控制幂等的业务逻辑，复杂化了业务功能；<br>所以在使用时候需要考虑是否引入幂等性的必要性，根据实际业务场景具体分析，除了业务上的特殊要求外，一般情况下不需要引入的接口幂等性。</li></ul><h1 id="五、Restful-API-接口的幂等性"><a href="#五、Restful-API-接口的幂等性" class="headerlink" title="五、Restful API 接口的幂等性"></a>五、Restful API 接口的幂等性</h1><p>现在流行的 Restful 推荐的几种 HTTP 接口方法中，分别存在幂等行与不能保证幂等的方法，如下：</p><ul><li>√ 满足幂等</li><li>x 不满足幂等</li><li><ul><li>可能满足也可能不满足幂等，根据实际业务逻辑有关</li></ul></li></ul><table><thead><tr><th>方法类型</th><th>是否幂等</th><th>描述</th></tr></thead><tbody><tr><td>Get</td><td>√</td><td>Get 方法用于获取资源。其一般不会也不应当对系统资源进行改变，所以是幂等的。</td></tr><tr><td>Post</td><td>×</td><td>Post 方法一般用于创建新的资源。其每次执行都会新增数据，所以不是幂等的。</td></tr><tr><td>Put</td><td>-</td><td>Put 方法一般用于修改资源。该操作则分情况来判断是不是满足幂等，更新操作中直接根据某个值进行更新，也能保持幂等。不过执行累加操作的更新是非幂等。</td></tr><tr><td>Delete</td><td>-</td><td>Delete 方法一般用于删除资源。该操作则分情况来判断是不是满足幂等，当根据唯一值进行删除时，删除同一个数据多次执行效果一样。不过需要注意，带查询条件的删除则就不一定满足幂等了。例如在根据条件删除一批数据后，这时候新增加了一条数据也满足条件，然后又执行了一次删除，那么将会导致新增加的这条满足条件数据也被删除。</td></tr></tbody></table><h1 id="六、如何实现幂等性"><a href="#六、如何实现幂等性" class="headerlink" title="六、如何实现幂等性"></a>六、如何实现幂等性</h1><h2 id="方案一：数据库唯一主键"><a href="#方案一：数据库唯一主键" class="headerlink" title="方案一：数据库唯一主键"></a>方案一：数据库唯一主键</h2><p><strong>方案描述</strong><br>数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。<br>使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键（可以参考 Java 中分布式 ID 的设计方案 这篇文章），这样才能能保证在分布式环境下 ID 的全局唯一性。</p><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要生成全局唯一主键 ID；</li></ul><p><strong>主要流程：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwefdI5qGGUJDGHXQS51PWCZCn6gQH0oYx9GVPZ6FIiagFkiakWs9c3cdqCsiaHZhylOJX1yQbXvwibF6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>主要流程：  </p><ul><li>① 客户端执行创建请求，调用服务端接口。</li><li>② 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执数据插入操作，运行对应的 SQL 语句。</li><li>③ 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。</li></ul><h2 id="方案二：数据库乐观锁"><a href="#方案二：数据库乐观锁" class="headerlink" title="方案二：数据库乐观锁"></a>方案二：数据库乐观锁</h2><p><strong>方案描述：</strong><br>数据库乐观锁方案一般只能适用于执行“更新操作”的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。</p><p><strong>适用操作：</strong></p><ul><li>更新操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要数据库对应业务表中添加额外字段；</li></ul><p><strong>描述示例：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwefdI5qGGUJDGHXQS51PWCZlCC8hia9K6zsgUg6Kv4rYCZ3DArAzBN0CujVBK3F0HynqT7H4dfZfBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>例如，存在如下的数据表中：  </p><table><thead><tr><th>id</th><th>name</th><th>price</th></tr></thead><tbody><tr><td>1</td><td>小米手机</td><td>1000</td></tr><tr><td>2</td><td>苹果手机</td><td>2500</td></tr><tr><td>3</td><td>华为手机</td><td>1600</td></tr></tbody></table><p>为了每次执行更新时防止重复更新，确定更新的一定是要更新的内容，我们通常都会添加一个 version 字段记录当前的记录版本，这样在更新时候将该值带上，那么只要执行更新操作就能确定一定更新的是某个对应版本下的信息。</p><table><thead><tr><th>id</th><th>name</th><th>price</th><th>version</th></tr></thead><tbody><tr><td>1</td><td>小米手机</td><td>1000</td><td>10</td></tr><tr><td>2</td><td>苹果手机</td><td>2500</td><td>21</td></tr><tr><td>3</td><td>华为手机</td><td>1600</td><td>5</td></tr></tbody></table><p>这样每次执行更新时候，都要指定要更新的版本号，如下操作就能准确更新 version&#x3D;5 的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> my_table <span class="keyword">SET</span> price<span class="operator">=</span>price<span class="operator">+</span><span class="number">50</span>,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> version<span class="operator">=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面 WHERE 后面跟着条件 id&#x3D;1 AND version&#x3D;5 被执行后，id&#x3D;1 的 version 被更新为 6，所以如果重复执行该条 SQL 语句将不生效，因为 id&#x3D;1 AND version&#x3D;5 的数据已经不存在，这样就能保住更新的幂等，多次更新对结果不会产生影响。</p><h2 id="方案三：防重-Token-令牌"><a href="#方案三：防重-Token-令牌" class="headerlink" title="方案三：防重 Token 令牌"></a>方案三：防重 Token 令牌</h2><p><strong>方案描述：</strong><br>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 Token 的机制实现防止重复提交。简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，如果 Key 存在且 Value 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作。</p><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>更新操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>需要生成全局唯一 Token 串；</li><li>需要使用第三方组件 Redis 进行数据效验；</li></ul><p><strong>主要流程：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwefdI5qGGUJDGHXQS51PWCZw8tv1YLx13CePmVDlFjxaZsJL1SQd2fyX1xQzIibGFibWI1TYKEgFv5A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>① 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。</li><li>② 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。</li><li>③ 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。</li><li>④ 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。</li><li>⑤ 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。</li><li>⑥ 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。</li><li>⑦ 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。</li></ul><blockquote><p>注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。</p></blockquote><h2 id="方案四、下游传递唯一序列号"><a href="#方案四、下游传递唯一序列号" class="headerlink" title="方案四、下游传递唯一序列号"></a>方案四、下游传递唯一序列号</h2><p><strong>方案描述：</strong><br>所谓请求序列号，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个有序 ID，也可以是一个订单号，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 ID。<br>当上游服务器收到请求信息后拿取该 序列号 和下游 认证ID 进行组合，形成用于操作 Redis 的 Key，然后到 Redis 中查询是否存在对应的 Key 的键值对，根据其结果：</p><ul><li>如果存在，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。</li><li>如果不存在，就以该 Key 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。</li></ul><p><strong>适用操作：</strong></p><ul><li>插入操作</li><li>更新操作</li><li>删除操作</li></ul><p><strong>使用限制：</strong></p><ul><li>要求第三方传递唯一序列号；</li><li>需要使用第三方组件 Redis 进行数据效验；</li></ul><p><strong>主要流程：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwefdI5qGGUJDGHXQS51PWCZoffRxtyeQX337tXwsNjfRbbrX4wicKJnzEhCZib9ibogAHr9eIukanPIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>主要步骤：  </p><ul><li>① 下游服务生成分布式 ID 作为序列号，然后执行请求调用上游接口，并附带“唯一序列号”与请求的“认证凭据ID”。</li><li>② 上游服务进行安全效验，检测下游传递的参数中是否存在“序列号”和“凭据ID”。</li><li>③ 上游服务到 Redis 中检测是否存在对应的“序列号”与“认证ID”组成的 Key，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息。如果不存在就以该“序列号”和“认证ID”组合作为 Key，以下游关键信息作为 Value，进而存储到 Redis 中，然后正常执行接来来的业务逻辑。</li></ul><blockquote><p>上面步骤中插入数据到 Redis 一定要设置过期时间。这样能保证在这个时间范围内，如果重复调用接口，则能够进行判断识别。如果不设置过期时间，很可能导致数据无限量的存入 Redis，致使 Redis 不能正常工作。</p></blockquote><h1 id="七、实现接口幂等示例"><a href="#七、实现接口幂等示例" class="headerlink" title="七、实现接口幂等示例"></a>七、实现接口幂等示例</h1><p>这里使用防重 Token 令牌方案，该方案能保证在不同请求动作下的幂等性，实现逻辑可以看上面写的”防重 Token 令牌”方案，接下来写下实现这个逻辑的代码。</p><h2 id="1、Maven-引入相关依赖"><a href="#1、Maven-引入相关依赖" class="headerlink" title="1、Maven 引入相关依赖"></a>1、Maven 引入相关依赖</h2><p>这里使用 Maven 工具管理依赖，这里在 pom.xml 中引入 SpringBoot、Redis、lombok 相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mydlq.club<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-idempotent-token<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-idempotent-token<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Idempotent Demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springboot web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springboot data redis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、配置连接-Redis-的参数"><a href="#2、配置连接-Redis-的参数" class="headerlink" title="2、配置连接 Redis 的参数"></a>2、配置连接 Redis 的参数</h2><p>在 application 配置文件中配置连接 Redis 的参数如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="string">ssl:</span> <span class="literal">false</span></span><br><span class="line">    <span class="string">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="string">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="string">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="string">timeout:</span> <span class="number">1000</span> </span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="string">max-active:</span> <span class="number">100</span></span><br><span class="line">        <span class="string">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="string">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="string">max-idle:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="3、创建与验证-Token-工具类"><a href="#3、创建与验证-Token-工具类" class="headerlink" title="3、创建与验证 Token 工具类"></a>3、创建与验证 Token 工具类</h2><p>创建用于操作 Token 相关的 Service 类，里面存在 Token 创建与验证方法，其中：</p><ul><li><strong>Token 创建方法：</strong> 使用 UUID 工具创建 Token 串，设置以 “idempotent_token:“+“Token串” 作为 Key，以用户信息当成 Value，将信息存入 Redis 中。</li><li><strong>Token 验证方法：</strong> 接收 Token 串参数，加上 Key 前缀形成 Key，再传入 value 值，执行 Lua 表达式（Lua 表达式能保证命令执行的原子性）进行查找对应 Key 与删除操作。执行完成后验证命令的返回结果，如果结果不为空且非0，则验证成功，否则失败。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;<span class="keyword">import</span> java.util.UUID;<span class="keyword">import</span> java.util.concurrent.TimeUnit;<span class="keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;<span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;<span class="keyword">import</span> org.springframework.data.redis.core.script.RedisScript;<span class="keyword">import</span> org.springframework.stereotype.Service;<span class="meta">@Slf4j</span><span class="meta">@Servicepublic</span> <span class="keyword">class</span> <span class="title class_">TokenUtilService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> StringRedisTemplate redisTemplate;    <span class="comment">/**     * 存入 Redis 的 Token 键的前缀     */</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDEMPOTENT_TOKEN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;idempotent_token:&quot;</span>;    <span class="comment">/**     * 创建 Token 存入 Redis，并返回该 Token     *     * <span class="doctag">@param</span> value 用于辅助验证的 value 值     * <span class="doctag">@return</span> 生成的 Token 串     */</span>    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(String value)</span> &#123;        <span class="comment">// 实例化生成 ID 工具对象        String token = UUID.randomUUID().toString();        // 设置存入 Redis 的 Key        String key = IDEMPOTENT_TOKEN_PREFIX + token;        // 存储 Token 到 Redis，且设置过期时间为5分钟        redisTemplate.opsForValue().set(key, value, 5, TimeUnit.MINUTES);        // 返回 Token        return token;    &#125;    /**     * 验证 Token 正确性     *     * @param token token 字符串     * @param value value 存储在Redis中的辅助验证信息     * @return 验证结果     */    public boolean validToken(String token, String value) &#123;        // 设置 Lua 脚本，其中 KEYS[1] 是 key，KEYS[2] 是 value        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == KEYS[2] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;        RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(script, Long.class);        // 根据 Key 前缀拼接 Key        String key = IDEMPOTENT_TOKEN_PREFIX + token;        // 执行 Lua 脚本        Long result = redisTemplate.execute(redisScript, Arrays.asList(key, value));        // 根据返回结果判断是否成功成功匹配并删除 Redis 键值对，若果结果不为空和0，则验证通过        if (result != null &amp;&amp; result != 0L) &#123;            log.info(&quot;验证 token=&#123;&#125;,key=&#123;&#125;,value=&#123;&#125; 成功&quot;, token, key, value);            return true;        &#125;        log.info(&quot;验证 token=&#123;&#125;,key=&#123;&#125;,value=&#123;&#125; 失败&quot;, token, key, value);        return false;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4、创建测试的-Controller-类"><a href="#4、创建测试的-Controller-类" class="headerlink" title="4、创建测试的 Controller 类"></a>4、创建测试的 Controller 类</h2><p>创建用于测试的 Controller 类，里面有获取 Token 与测试接口幂等性的接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="keyword">import</span> mydlq.club.example.service.TokenUtilService;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="meta">@Slf4j</span><span class="meta">@RestControllerpublic</span> <span class="keyword">class</span> <span class="title class_">TokenController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> TokenUtilService tokenService;    <span class="comment">/**     * 获取 Token 接口     *     * <span class="doctag">@return</span> Token 串     */</span>    <span class="meta">@GetMapping(&quot;/token&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">()</span> &#123;        <span class="comment">// 获取用户信息（这里使用模拟数据）        // 注：这里存储该内容只是举例，其作用为辅助验证，使其验证逻辑更安全，如这里存储用户信息，其目的为:        // - 1)、使用&quot;token&quot;验证 Redis 中是否存在对应的 Key        // - 2)、使用&quot;用户信息&quot;验证 Redis 的 Value 是否匹配。        String userInfo = &quot;mydlq&quot;;        // 获取 Token 字符串，并返回        return tokenService.generateToken(userInfo);    &#125;    /**     * 接口幂等性测试接口     *     * @param token 幂等 Token 串     * @return 执行结果     */    @PostMapping(&quot;/test&quot;)    public String test(@RequestHeader(value = &quot;token&quot;) String token) &#123;        // 获取用户信息（这里使用模拟数据）        String userInfo = &quot;mydlq&quot;;        // 根据 Token 和与用户相关的信息到 Redis 验证是否存在对应的信息        boolean result = tokenService.validToken(token, userInfo);        // 根据验证结果响应不同信息        return result ? &quot;正常调用&quot; : &quot;重复调用&quot;;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5、创建-SpringBoot-启动类"><a href="#5、创建-SpringBoot-启动类" class="headerlink" title="5、创建 SpringBoot 启动类"></a>5、创建 SpringBoot 启动类</h2><p>创建启动类，用于启动 SpringBoot 应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;       </span><br><span class="line">SpringApplication.run(Application.class, args);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、写测试类进行测试"><a href="#6、写测试类进行测试" class="headerlink" title="6、写测试类进行测试"></a>6、写测试类进行测试</h2><p>写个测试类进行测试，多次访问同一个接口，测试是否只有第一次能否执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdempotenceTest</span> &#123;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line"><span class="keyword">private</span> WebApplicationContext webApplicationContext;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interfaceIdempotenceTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        </span><br><span class="line"><span class="comment">// 初始化 MockMvc       </span></span><br><span class="line"><span class="type">MockMvc</span> <span class="variable">mockMvc</span> <span class="operator">=</span> MockMvcBuilders.webAppContextSetup(webApplicationContext)</span><br><span class="line">.build();        </span><br><span class="line"><span class="comment">// 调用获取 Token 接口        </span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/token&quot;</span>)   .accept(MediaType.TEXT_HTML))                </span><br><span class="line">.andReturn()                </span><br><span class="line">.getResponse()</span><br><span class="line">.getContentAsString();        </span><br><span class="line">log.info(<span class="string">&quot;获取的 Token 串：&#123;&#125;&quot;</span>, token);        </span><br><span class="line"><span class="comment">// 循环调用 5 次进行测试        </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            </span><br><span class="line">log.info(<span class="string">&quot;第&#123;&#125;次调用测试接口&quot;</span>, i);            <span class="comment">// 调用验证接口并打印结果           </span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/test&quot;</span>)             </span><br><span class="line">.header(<span class="string">&quot;token&quot;</span>, token)                    </span><br><span class="line">.accept(MediaType.TEXT_HTML))                    </span><br><span class="line">.andReturn()</span><br><span class="line">.getResponse()</span><br><span class="line">.getContentAsString();       </span><br><span class="line">log.info(result);            </span><br><span class="line"><span class="comment">// 结果断言            </span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;               </span><br><span class="line">Assert.assertEquals(result, <span class="string">&quot;正常调用&quot;</span>);            </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;               </span><br><span class="line">Assert.assertEquals(result, <span class="string">&quot;重复调用&quot;</span>);           </span><br><span class="line">&#125;        </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main] IdempotenceTest:  获取的 Token 串：980ea707-ce2e-456e-a059-0a03332110b4[main] IdempotenceTest:  第1次调用测试接口[main] IdempotenceTest:  正常调用[main] IdempotenceTest:  第2次调用测试接口[main] IdempotenceTest:  重复调用[main] IdempotenceTest:  第3次调用测试接口[main] IdempotenceTest:  重复调用[main] IdempotenceTest:  第4次调用测试接口[main] IdempotenceTest:  重复调用[main] IdempotenceTest:  第5次调用测试接口[main] IdempotenceTest:  重复调用</span><br></pre></td></tr></table></figure><h1 id="八、最后总结"><a href="#八、最后总结" class="headerlink" title="八、最后总结"></a>八、最后总结</h1><p>幂等性是开发当中很常见也很重要的一个需求，尤其是支付、订单等与金钱挂钩的服务，保证接口幂等性尤其重要。在实际开发中，我们需要针对不同的业务场景我们需要灵活的选择幂等性的实现方式：  </p><ul><li>对于下单等存在唯一主键的，可以使用“唯一主键方案”的方式实现。</li><li>对于更新订单状态等相关的更新场景操作，使用“乐观锁方案”实现更为简单。</li><li>对于上下游这种，下游请求上游，上游服务可以使用“下游传递唯一序列号方案”更为合理。</li><li>类似于前端重复提交、重复下单、没有唯一ID号的场景，可以通过 Token 与 Redis 配合的“防重 Token 方案”实现更为快捷。</li></ul><p>上面只是给与一些建议，再次强调一下，实现幂等性需要先理解自身业务需求，根据业务逻辑来实现这样才合理，处理好其中的每一个结点细节，完善整体的业务流程设计，才能更好的保证系统的正常运行。最后做一个简单总结</p><table><thead><tr><th>方案名称</th><th>适用方法</th><th>实现复杂度</th><th>方案缺点</th></tr></thead><tbody><tr><td>数据库唯一主键</td><td>插入操作 删除操作</td><td>简单</td><td>- 只能用于插入操作；- 只能用于存在唯一主键场景；</td></tr><tr><td>数据库乐观锁</td><td>更新操作</td><td>简单</td><td>- 只能用于更新操作；- 表中需要额外添加字段；</td></tr><tr><td>请求序列号</td><td>插入操作 更新操作 删除操作</td><td>简单</td><td>- 需要保证下游生成唯一序列号；- 需要 Redis 第三方存储已经请求的序列号；</td></tr><tr><td>防重 Token 令牌</td><td>插入操作 更新操作 删除操作</td><td>适中</td><td>- 需要 Redis 第三方存储生成的 Token 串；</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文（&lt;a href=&quot;https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg%EF%BC%89&quot;&gt;https://mp.weixin.qq.com/s/58j92LF2AP5mKXjQl-YaRg）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    
    <category term="Java" scheme="https://andy-whb-cn.github.io/tags/Java/"/>
    
    <category term="架构" scheme="https://andy-whb-cn.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://andy-whb-cn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java：应用启动脚本</title>
    <link href="https://andy-whb-cn.github.io/2024/08/27/JVM/Java%EF%BC%9A%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
    <id>https://andy-whb-cn.github.io/2024/08/27/JVM/Java%EF%BC%9A%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</id>
    <published>2024-08-27T08:10:51.500Z</published>
    <updated>2024-11-15T09:31:46.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见的Java应用启停脚本"><a href="#常见的Java应用启停脚本" class="headerlink" title="常见的Java应用启停脚本"></a>常见的Java应用启停脚本</h2><p>reboot_jar_shell.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">bootClassPath=$*</span><br><span class="line">appName=$1</span><br><span class="line">echo &quot;==========================&quot;</span><br><span class="line">echo &quot;stop $&#123;appName&#125;&quot;</span><br><span class="line">PID=`ps axu | grep java | grep &quot;$&#123;appName&#125;&quot; |grep -v grep| awk &#x27;&#123;printf $2&#125;&#x27;`</span><br><span class="line">if [ -n &quot;$&#123;PID&#125;&quot; ]; then</span><br><span class="line">  echo &quot;kill process $&#123;PID&#125;&quot;</span><br><span class="line">  kill -9 $&#123;PID&#125;</span><br><span class="line">fi</span><br><span class="line">echo &quot;$&#123;appName&#125; stopped&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;start $&#123;appName&#125;&quot;</span><br><span class="line">echo &quot;boot classpath: $&#123;bootClassPath&#125;&quot;</span><br><span class="line">nohup java server $bootClassPath &gt;nohup.log 2&gt;&amp;1 &amp;</span><br><span class="line">echo &quot;$appName started&quot;</span><br><span class="line">echo &quot;==========================&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>restart.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;--------xxx 开始启动--------------&quot;</span><br><span class="line">     sh reboot_jar_shell.sh -DappName=xxx -Xms1024m -Xmx1024m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/xxxx/logs -Djava.io.tmpdir=/data/tmp/xxxx -Xbootclasspath/a:/data/xxxx/config -Dspring.profiles.active=&lt;env&gt; -Dfile.encoding=utf-8 -jar xxx.jar</span><br><span class="line">     sleep 10</span><br><span class="line">echo &quot;--------xxx 启动成功--------------&quot;</span><br></pre></td></tr></table></figure><p>JVM heap参数设置建议：<br>1、JVM默认会根据运行机器的配置情况自动设置heap大小；<br>2、尽可能通过选择GC算法调优，而不是调整heap大小，除非应用需要的heap大小超过了默认值；<br>3、通常情况下，heap大小设置可以参考Full GC后老年代存活对象大小的3-4倍；<br>4、如果明确知道应用需要用到的heap大小，可以将Xms和Xmx设置为相同值，避免heap resize，会让GC更高效。<br><img src="https://s2.loli.net/2024/08/29/zoacyRxhINgbjPS.png" alt="image.png"><br>相关建议来源参考书籍《Java Performance, 2nd Edition》 by Scott Oaks</p><p>GC日志打印：<br>-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -Xloggc:gc.log</p><h2 id="Jvm优化"><a href="#Jvm优化" class="headerlink" title="Jvm优化"></a>Jvm优化</h2><p>这块主要不是谈如何优化，jvm优化是一个需要场景化的，没有什么太多特定参数，一般来说在server端运行都会指定如下参数</p><blockquote><p>初始内存和最大内存基本会设置成一样的，具体大小根据场景设置，-server是一个必须要用的参数，至于收集器这些使用默认的就可以了，除非有特定需求。</p></blockquote><h3 id="1-使用-server模式"><a href="#1-使用-server模式" class="headerlink" title="1.使用-server模式"></a>1.使用-server模式</h3><p>设置JVM使用server模式。64位JDK默认启动该模式</p><p><code>java -server -jar springboot-1.0.jar   </code></p><h3 id="2-指定堆参数"><a href="#2-指定堆参数" class="headerlink" title="2.指定堆参数"></a>2.指定堆参数</h3><p>这个根据服务器的内存大小，来设置堆参数。</p><ul><li>-Xms :设置Java堆栈的初始化大小</li><li>-Xmx :设置最大的java堆大小</li></ul><p><code>java -server -Xms512m -Xmx768m  -jar springboot-1.0.jar   </code></p><p>设置初始化堆内存为512MB，最大为768MB。</p><h3 id="3-远程Debug"><a href="#3-远程Debug" class="headerlink" title="3.远程Debug"></a>3.远程Debug</h3><p>在服务器上将启动参数修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djavax.net.debug=ssl -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8888 -jar springboot-1.0.jar </span><br></pre></td></tr></table></figure><p>这个时候服务端远程Debug模式开启，端口号为8888。</p><p>在IDEA中，点击Edit Configuration按钮。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNXkEukbLoTvyCXuwEDpW5zgZETUNibbORKodWhVrUMxqlCBpNwxiaaCtQw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">出现弹窗，点击+按钮，找到Remote选项。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNXvGrNvOFxJreZbGsLJqMHg7e6csPI3MrXNZSRdClkKgRfpzI4EoztTQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>在【1】中填入Remote项目名称，在【2】中填IP地址和端口号，在【3】选择远程调试的项目module，配置完成后点击OK即可</p><p>如果碰到连接超时的情况，很有可能服务器的防火墙的问题，举例CentOs7,关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service #停止firewall   systemctl disable firewalld.service #禁止firewall开机启动 </span><br></pre></td></tr></table></figure><p>点击debug按钮，IDEA控制台打印信息：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNXkPeueIjKTxDFmVCyU8rcePPFm9ufgWJ7PmTZYRbbJiafG3Cl9rJdsEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">说明远程调试成功。</p><h2 id="JVM工具远程连接"><a href="#JVM工具远程连接" class="headerlink" title="JVM工具远程连接"></a>JVM工具远程连接</h2><h3 id="jconsole与Jvisualvm远程连接"><a href="#jconsole与Jvisualvm远程连接" class="headerlink" title="jconsole与Jvisualvm远程连接"></a>jconsole与Jvisualvm远程连接</h3><p>通常我们的web服务都输部署在服务器上的，在window使用jconsole是很方便的，相对于Linux就有一些麻烦了，需要进行一些设置。</p><p>1.查看hostname,首先使用<br><code>hostname -i   </code><br>查看，服务器的hostname为127.0.0.1，这个是不对的，需要进行修改</p><p>2.修改hostname<br>修改&#x2F;etc&#x2F;hosts文件，将其第一行的“127.0.0.1 localhost.localdomain localhost”，修改为：“192.168.44.128 localhost.localdomain localhost”.<br>“192.168.44.128”为实际的服务器的IP</p><p>3.重启Linux，在服务器上输入hostname -i，查看实际设置的IP地址是否为你设置的</p><p>4.启动服务，参数为：<br><code>java -jar -Djava.rmi.server.hostname=192.168.44.128 -   Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=911 -   Dcom.sun.management.jmxremote.ssl=false -   Dcom.sun.management.jmxremote.authenticate=false jantent-1.0-SNAPSHOT.jar   </code></p><p>ip为192.168.44.128，端口为911 。</p><p>5.打开Jconsole，进行远程连接,输入IP和端口即可<br>点击连接，经过稍稍等待之后，即可完成连接，如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNX79JjeOV3wNV8humibI8mG6jicRLrLMvrSjIpjy20IxRWCrnFPuagrTRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">同理，JvisualVm的远程连接是同样的，启动参数也是一样。</p><p>然后在本机JvisualVm输入IP：PORT，即可进行远程连接：如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4j1okibuIJrnBlTGeiaZAVWNXJV3drWDKkOUJaayW3B4TwxnOjJAUhK5011K7lVlcdwBRcDS6PH4LFQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">相比较Jvisualvm功能更加强大一下，界面也更美观。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见的Java应用启停脚本&quot;&gt;&lt;a href=&quot;#常见的Java应用启停脚本&quot; class=&quot;headerlink&quot; title=&quot;常见的Java应用启停脚本&quot;&gt;&lt;/a&gt;常见的Java应用启停脚本&lt;/h2&gt;&lt;p&gt;reboot_jar_shell.sh&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    
    <category term="Java" scheme="https://andy-whb-cn.github.io/tags/Java/"/>
    
    <category term="脚本" scheme="https://andy-whb-cn.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>前端版本更新检测</title>
    <link href="https://andy-whb-cn.github.io/2024/08/22/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%EF%BC%9A%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B/"/>
    <id>https://andy-whb-cn.github.io/2024/08/22/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%EF%BC%9A%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B/</id>
    <published>2024-08-22T08:33:34.000Z</published>
    <updated>2024-09-03T00:47:17.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端版本更新检测方案"><a href="#前端版本更新检测方案" class="headerlink" title="前端版本更新检测方案"></a>前端版本更新检测方案</h2><h4 id="采用Etag比较"><a href="#采用Etag比较" class="headerlink" title="采用Etag比较"></a>采用Etag比较</h4><p><a href="https://blog.csdn.net/qq_38951259/article/details/136739490">https://blog.csdn.net/qq_38951259/article/details/136739490</a></p><h4 id="采用前后端Version比较"><a href="#采用前后端Version比较" class="headerlink" title="采用前后端Version比较"></a>采用前后端Version比较</h4><p>1、后台提供轻量级version api；<br>2、前端页面初始化或定时，比较本地version和服务端version是否有变更，设置local vesion变更变量；<br>3、前端在进入router前，判断有local vesion变更变量，刷新本地缓存并删除local vesion变更变量；</p><p>引申：为避免频繁去请求后台的version，可以考虑按时间戳（每日）去检查远端version更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端版本更新检测方案&quot;&gt;&lt;a href=&quot;#前端版本更新检测方案&quot; class=&quot;headerlink&quot; title=&quot;前端版本更新检测方案&quot;&gt;&lt;/a&gt;前端版本更新检测方案&lt;/h2&gt;&lt;h4 id=&quot;采用Etag比较&quot;&gt;&lt;a href=&quot;#采用Etag比较&quot; cla</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://andy-whb-cn.github.io/tags/Vue/"/>
    
    <category term="前端" scheme="https://andy-whb-cn.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot对象复制</title>
    <link href="https://andy-whb-cn.github.io/2024/08/22/SpringBoot/SpringBoot%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/"/>
    <id>https://andy-whb-cn.github.io/2024/08/22/SpringBoot/SpringBoot%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/</id>
    <published>2024-08-22T08:33:34.000Z</published>
    <updated>2024-09-04T00:50:59.425Z</updated>
    
    <content type="html"><![CDATA[<p>今天带来SpringBoot老鸟系列的第四篇，来聊聊在日常开发中如何优雅的实现对象复制。</p><p>首先我们看看为什么需要对象复制？</p><h2 id="为什么需要对象复制"><a href="#为什么需要对象复制" class="headerlink" title="为什么需要对象复制"></a>为什么需要对象复制</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gBVFX960VSFkYxMfAPwTAEHQtPUThRTsfjgibRSOCd5pRdVNvh4AIbak04GwxJEX7libic3libBgqFuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>如上，是我们平时开发中最常见的三层MVC架构模型，编辑操作时Controller层接收到前端传来的DTO对象，在Service层需要将<code>DTO</code>转换成<code>DO</code>，然后在数据库中保存。查询操作时Service层查询到DO对象后需要将<code>DO</code>对象转换成<code>VO</code>对象，然后通过Controller层返回给前端进行渲染。</p><p>这中间会涉及到大量的对象转换，很明显我们不能直接使用<code>getter/setter</code>复制对象属性，这看上去太low了。想象一下你业务逻辑中充斥着大量的<code>getter&amp;setter</code>，代码评审时老鸟们会如何笑话你？</p><p>所以我们必须要找一个第三方工具来帮我们实现对象转换。</p><blockquote><p>看到这里有同学可能会问，为什么不能前后端都统一使用DO对象呢？这样就不存在对象转换呀？</p><p>设想一下如果我们不想定义 DTO 和 VO，直接将 DO 用到数据访问层、服务层、控制层和外部访问接口上。此时该表删除或则修改一个字段，DO 必须同步修改，这种修改将会影响到各层，这并不符合高内聚低耦合的原则。通过定义不同的 DTO 可以控制对不同系统暴露不同的属性，通过属性映射还可以实现具体的字段名称的隐藏。不同业务使用不同的模型，当一个业务发生变更需要修改字段时，不需要考虑对其它业务的影响，如果使用同一个对象则可能因为 “不敢乱改” 而产生很多不优雅的兼容性行为。</p></blockquote><h2 id="对象复制工具类推荐"><a href="#对象复制工具类推荐" class="headerlink" title="对象复制工具类推荐"></a>对象复制工具类推荐</h2><p>对象复制的类库工具有很多，除了常见的Apache的<code>BeanUtils</code>，Spring的<code>BeanUtils</code>，<code>Cglib BeanCopier</code>，还有重量级组件<code>MapStruct</code>，<code>Orika</code>，<code>Dozer</code>，<code>ModelMapper</code>等。</p><p>如果没有特殊要求，这些工具类都可以直接使用，除了Apache的<code>BeanUtils</code>。原因在于<code>Apache BeanUtils</code>底层源码为了追求完美，加了过多的包装，使用了很多反射，做了很多校验，所以导致性能较差，并在阿里巴巴开发手册上强制规定避免使用 Apache BeanUtils。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4gBVFX960VSFkYxMfAPwTAEbicT7ibC4EZgcMQQD42eE9AfeibXT9P4rutYIEF9ERw74WWE9A6GbN9HQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>强制规定避免使用 Apache BeanUtils</strong></p><p>至于剩下的重量级组件，综合考虑其性能还有使用的易用性，我这里更推荐使用<code>Orika</code>。Orika底层采用了javassist类库生成Bean映射的字节码，之后直接加载执行生成的字节码文件，在速度上比使用反射进行赋值会快很多。</p><blockquote><p>国外大神 baeldung 已经对常见的组件性能进行过详细测试，大家可以通过 <a href="https://www.baeldung.com/java-performance-mapping-frameworks">https://www.baeldung.com/java-performance-mapping-frameworks</a> 查看。</p></blockquote><h2 id="Orika基本使用"><a href="#Orika基本使用" class="headerlink" title="Orika基本使用"></a>Orika基本使用</h2><p>要使用Orika很简单，只需要简单四步：</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ma.glasnost.orika<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>orika-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>构造一个MapperFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MapperFactory</span> <span class="variable">mapperFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMapperFactory</span>.Builder().build();  </span><br></pre></td></tr></table></figure></li><li><p>注册字段映射</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapperFactory.classMap(SourceClass.class, TargetClass.class)    </span><br><span class="line">.field(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;givenName&quot;</span>)   </span><br><span class="line">.field(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;sirName&quot;</span>)   </span><br><span class="line">.byDefault()   </span><br><span class="line">.register();</span><br></pre></td></tr></table></figure><p>当字段名在两个实体不一致时可以通过<code>.field()</code>方法进行映射，如果字段名都一样则可省略，<code>byDefault()</code>方法用于注册名称相同的属性，如果不希望某个字段参与映射，可以使用<code>exclude</code>方法。</p><ol start="4"><li>进行映射<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MapperFacade</span> <span class="variable">mapper</span> <span class="operator">=</span> mapperFactory.getMapperFacade();</span><br><span class="line"><span class="type">SourceClass</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SourceClass</span>();  </span><br><span class="line"><span class="comment">// set some field values...</span></span><br><span class="line"><span class="comment">// map the fields of &#x27;source&#x27; onto a new instance of </span></span><br><span class="line"><span class="type">PersonDestTargetClass</span> <span class="variable">target</span> <span class="operator">=</span> mapper.map(source, TargetClass.class);  </span><br></pre></td></tr></table></figure></li></ol><p>经过上面四步我们就完成了SourceClass到TargetClass的转换。至于Orika的其他使用方法大家可以参考 <code>http://orika-mapper.github.io/orika-docs/index.html</code></p><p>看到这里，肯定有粉丝会说：你这推荐的啥玩意呀，这个Orika使用也不简单呀，每次都要这先创建<code>MapperFactory</code>，建立字段映射关系，才能进行映射转换。</p><p>别急，我这里给你准备了一个工具类<code>OrikaUtils</code>，你可以通过<code>文末github仓库</code>获取。</p><p>它提供了五个公共方法：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gBVFX960VSFkYxMfAPwTAEGWNjiabibrzE07fsCD0pLZgAE1iaTgmlS3fqo2wXjRWsxOXMnAokFEcVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>分别对应：</p><ol><li>字段一致实体转换</li><li>字段不一致实体转换（需要字段映射）</li><li>字段一致集合转换</li><li>字段不一致集合转换（需要字段映射）</li><li>字段属性转换注册</li></ol><p>接下来我们通过单元测试案例重点介绍此工具类的使用。</p><h2 id="Orika工具类使用文档"><a href="#Orika工具类使用文档" class="headerlink" title="Orika工具类使用文档"></a>Orika工具类使用文档</h2><p>先准备两个基础实体类，Student，Teacher。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;   </span><br><span class="line"><span class="keyword">private</span> String id;    </span><br><span class="line"><span class="keyword">private</span> String name;    </span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;    </span><br><span class="line"><span class="keyword">private</span> String id;    </span><br><span class="line"><span class="keyword">private</span> String name;    </span><br><span class="line"><span class="keyword">private</span> String emailAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TC1，基础实体映射"><a href="#TC1，基础实体映射" class="headerlink" title="TC1，基础实体映射"></a>TC1，基础实体映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 只拷贝相同的属性 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertObject</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>); </span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> OrikaUtils.convert(student, Teacher.class);  </span><br><span class="line">System.out.println(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher(id=1, name=javadaily, emailAddress=null)</span><br></pre></td></tr></table></figure><p>此时由于属性名不一致，无法映射字段email。</p><h3 id="TC2，实体映射-字段转换"><a href="#TC2，实体映射-字段转换" class="headerlink" title="TC2，实体映射 - 字段转换"></a>TC2，实体映射 - 字段转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 拷贝不同属性 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertRefObject</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>);  </span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span>);  <span class="comment">//map key 放置 源属性，value 放置 目标属性  </span></span><br><span class="line">refMap.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);  </span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> OrikaUtils.convert(student, Teacher.class, refMap);  </span><br><span class="line">System.out.println(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com)</span><br></pre></td></tr></table></figure><p>此时由于对字段做了映射，可以将email映射到emailAddress。注意这里的refMap中key放置的是源实体的属性，而value放置的是目标实体的属性，不要弄反了。</p><h3 id="TC3，基础集合映射"><a href="#TC3，基础集合映射" class="headerlink" title="TC3，基础集合映射"></a>TC3，基础集合映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  * 只拷贝相同的属性集合  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertList</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>); </span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;JAVA日知录&quot;</span>,<span class="string">&quot;jianzh5@xxx.com&quot;</span>);  </span><br><span class="line">List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2); </span><br><span class="line">List&lt;Teacher&gt; teacherList = OrikaUtils.convertList(studentList, Teacher.class);</span><br><span class="line">System.out.println(teacherList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Teacher(id=1, name=javadaily, emailAddress=null), Teacher(id=2, name=JAVA日知录, emailAddress=null)]</span><br></pre></td></tr></table></figure><p>此时由于属性名不一致，集合中无法映射字段email。</p><h3 id="TC4，集合映射-字段映射"><a href="#TC4，集合映射-字段映射" class="headerlink" title="TC4，集合映射 - 字段映射"></a>TC4，集合映射 - 字段映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 映射不同属性的集合 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertRefList</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>); </span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;JAVA日知录&quot;</span>,<span class="string">&quot;jianzh5@xxx.com&quot;</span>);  </span><br><span class="line">List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2);</span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);  <span class="comment">//map key 放置 源属性，value 放置 目标属性  </span></span><br><span class="line">refMap.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);</span><br><span class="line">List&lt;Teacher&gt; teacherList = OrikaUtils.convertList(studentList, Teacher.class,refMap);  </span><br><span class="line">System.out.println(teacherList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com), Teacher(id=2, name=JAVA日知录, emailAddress=jianzh5@xxx.com)]</span><br></pre></td></tr></table></figure><p>也可以通过这样映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">refMap.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);</span><br><span class="line">List&lt;Teacher&gt; teacherList = OrikaUtils.classMap(Student.class,Teacher.class,refMap).mapAsList(studentList,Teacher.class);</span><br></pre></td></tr></table></figure><h3 id="TC5，集合与实体映射"><a href="#TC5，集合与实体映射" class="headerlink" title="TC5，集合与实体映射"></a>TC5，集合与实体映射</h3><p>有时候我们需要将集合数据映射到实体中，如Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="keyword">private</span> List&lt;String&gt; nameParts;&#125;</span><br></pre></td></tr></table></figure><p>现在需要将Person类nameParts的值映射到Student中，可以这样做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 数组和List的映射 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertListObject</span><span class="params">()</span>&#123;   </span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">person.setNameParts(Lists.newArrayList(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>));   </span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);    <span class="comment">//map key 放置 源属性，value 放置 目标属性   </span></span><br><span class="line">refMap.put(<span class="string">&quot;nameParts[0]&quot;</span>,<span class="string">&quot;id&quot;</span>);   </span><br><span class="line">refMap.put(<span class="string">&quot;nameParts[1]&quot;</span>,<span class="string">&quot;name&quot;</span>);   </span><br><span class="line">refMap.put(<span class="string">&quot;nameParts[2]&quot;</span>,<span class="string">&quot;email&quot;</span>);   </span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> OrikaUtils.convert(person, Student.class,refMap);    </span><br><span class="line">System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(id=1, name=javadaily, email=jianzh5@163.com)</span><br></pre></td></tr></table></figure><h3 id="TC6，类类型映射"><a href="#TC6，类类型映射" class="headerlink" title="TC6，类类型映射"></a>TC6，类类型映射</h3><p>有时候我们需要类类型对象映射，如BasicPerson类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicPerson</span> &#123;    <span class="keyword">private</span> Student student;&#125;</span><br></pre></td></tr></table></figure><p>现在需要将BasicPerson映射到Teacher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 类类型映射 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertClassObject</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">BasicPerson</span> <span class="variable">basicPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicPerson</span>();  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>); </span><br><span class="line">basicPerson.setStudent(student);    </span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);    <span class="comment">//map key 放置 源属性，value 放置 目标属性    </span></span><br><span class="line">refMap.put(<span class="string">&quot;student.id&quot;</span>,<span class="string">&quot;id&quot;</span>);  </span><br><span class="line">refMap.put(<span class="string">&quot;student.name&quot;</span>,<span class="string">&quot;name&quot;</span>);   </span><br><span class="line">refMap.put(<span class="string">&quot;student.email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);   </span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> OrikaUtils.convert(basicPerson, Teacher.class,refMap);</span><br><span class="line">System.out.println(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com)</span><br></pre></td></tr></table></figure><h3 id="TC7，多重映射"><a href="#TC7，多重映射" class="headerlink" title="TC7，多重映射"></a>TC7，多重映射</h3><p>有时候我们会遇到多重映射，如将<code>StudentGrade</code>映射到<code>TeacherGrade</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentGrade</span> &#123;    <span class="keyword">private</span> String studentGradeName;    <span class="keyword">private</span> List&lt;Student&gt; studentList;&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherGrade</span> &#123;    <span class="keyword">private</span> String teacherGradeName;    <span class="keyword">private</span> List&lt;Teacher&gt; teacherList;&#125;</span><br></pre></td></tr></table></figure><p>这种场景稍微复杂，Student与Teacher的属性有email字段不相同，需要做转换映射；StudentGrade与TeacherGrade中的属性也需要映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 一对多映射 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertComplexObject</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;javadaily&quot;</span>,<span class="string">&quot;jianzh5@163.com&quot;</span>);  </span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;JAVA日知录&quot;</span>,<span class="string">&quot;jianzh5@xxx.com&quot;</span>);  </span><br><span class="line">List&lt;Student&gt; studentList = Lists.newArrayList(student1,student2); </span><br><span class="line"></span><br><span class="line"><span class="type">StudentGrade</span> <span class="variable">studentGrade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentGrade</span>(); </span><br><span class="line">studentGrade.setStudentGradeName(<span class="string">&quot;硕士&quot;</span>); </span><br><span class="line">studentGrade.setStudentList(studentList);  </span><br><span class="line">Map&lt;String,String&gt; refMap1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span>);  <span class="comment">//map key 放置 源属性，value 放置 目标属性  </span></span><br><span class="line">refMap1.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;emailAddress&quot;</span>);  </span><br><span class="line">OrikaUtils.register(Student.class,Teacher.class,refMap1);  </span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; refMap2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);  <span class="comment">//map key 放置 源属性，value 放置 目标属性  </span></span><br><span class="line">refMap2.put(<span class="string">&quot;studentGradeName&quot;</span>, <span class="string">&quot;teacherGradeName&quot;</span>);  </span><br><span class="line">refMap2.put(<span class="string">&quot;studentList&quot;</span>, <span class="string">&quot;teacherList&quot;</span>);  </span><br><span class="line"><span class="type">TeacherGrade</span> <span class="variable">teacherGrade</span> <span class="operator">=</span> OrikaUtils.convert(studentGrade,TeacherGrade.class,refMap2);  </span><br><span class="line">System.out.println(teacherGrade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多重映射的场景需要根据情况调用<code>OrikaUtils.register()</code>注册字段映射。</p><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TeacherGrade(teacherGradeName=硕士, teacherList=[Teacher(id=1, name=javadaily, emailAddress=jianzh5@163.com), Teacher(id=2, name=JAVA日知录, emailAddress=jianzh5@xxx.com)])</span><br></pre></td></tr></table></figure><h3 id="TC8，MyBaits-plus分页映射"><a href="#TC8，MyBaits-plus分页映射" class="headerlink" title="TC8，MyBaits plus分页映射"></a>TC8，MyBaits plus分页映射</h3><p>如果你使用的是mybatis的分页组件，可以这样转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IPage&lt;UserDTO&gt; <span class="title function_">selectPage</span><span class="params">(UserDTO userDTO, Integer pageNo, Integer pageSize)</span> &#123;</span><br><span class="line"><span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNo, pageSize);</span><br><span class="line">LambdaQueryWrapper&lt;User&gt; query = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>(); </span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotBlank(userDTO.getName())) &#123;  </span><br><span class="line">query.like(User::getKindName,userDTO.getName());  </span><br><span class="line">&#125;  </span><br><span class="line">IPage&lt;User&gt; pageList = page(page,query);  <span class="comment">// 实体转换 SysKind转化为SysKindDto  </span></span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; refMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);  </span><br><span class="line">refMap.put(<span class="string">&quot;kindName&quot;</span>,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">refMap.put(<span class="string">&quot;createBy&quot;</span>,<span class="string">&quot;createUserName&quot;</span>);  </span><br><span class="line">refMap.put(<span class="string">&quot;createTime&quot;</span>,<span class="string">&quot;createDate&quot;</span>);  </span><br><span class="line"><span class="keyword">return</span> pageList.convert(item &gt; OrikaUtils.convert(item, UserDTO.class, refMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在MVC架构中肯定少不了需要用到对象复制，属性转换的功能，借用Orika组件，可以很简单实现这些功能。本文在Orika的基础上封装了工具类，进一步简化了Orika的操作，希望对各位有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天带来SpringBoot老鸟系列的第四篇，来聊聊在日常开发中如何优雅的实现对象复制。&lt;/p&gt;
&lt;p&gt;首先我们看看为什么需要对象复制？&lt;/p&gt;
&lt;h2 id=&quot;为什么需要对象复制&quot;&gt;&lt;a href=&quot;#为什么需要对象复制&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
