<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andy&#39;s Note</title>
  
  
  <link href="https://andy-whb-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://andy-whb-cn.github.io/"/>
  <updated>2025-11-05T05:40:55.606Z</updated>
  <id>https://andy-whb-cn.github.io/</id>
  
  <author>
    <name>Andy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot: 审计日志</title>
    <link href="https://andy-whb-cn.github.io/2025/11/05/SpringBoot/SpringBoot%EF%BC%9A%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97/"/>
    <id>https://andy-whb-cn.github.io/2025/11/05/SpringBoot/SpringBoot%EF%BC%9A%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97/</id>
    <published>2025-11-04T16:00:00.000Z</published>
    <updated>2025-11-05T05:40:55.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在企业级业务系统中，审计日志记录非常重要。特别是涉及到用户操作一些关键业务数据的新增、修改、删除时，系统应追踪操作人、操作对象和操作时间等关键数据。这不仅对运维、合规有帮助，同时也能提高系统的可审计性和安全性。</p><h2 id="审计日志实现方式"><a href="#审计日志实现方式" class="headerlink" title="审计日志实现方式"></a>审计日志实现方式</h2><p>目前审计日志的主流实现方式多数是通过AOP或是增加Springboot拦截器，对http接口请求进行拦截打印日志或者记录到数据库表中。（注：JPA&#x2F;Mybatis这类框架支持拦截数据库的操作记录）</p><h3 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h3><p>1.添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuditLog &#123; </span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 操作描述 </span></span><br><span class="line">String <span class="title function_">operator</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;#userContext.username&quot;</span>; <span class="comment">// 操作人 </span></span><br><span class="line">String <span class="title function_">operatorId</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;#userContext.userId&quot;</span>; <span class="comment">// 操作人ID</span></span><br><span class="line">String <span class="title function_">params</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 参数SpEL表达式 </span></span><br><span class="line">String <span class="title function_">result</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 结果SpEL表达式 </span></span><br><span class="line">LogLevel <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> LogLevel.INFO; <span class="comment">// 日志级别 </span></span><br><span class="line">GdprMaskType <span class="title function_">maskType</span><span class="params">()</span> <span class="keyword">default</span> GdprMaskType.DEFAULT; <span class="comment">// GDPR脱敏类型 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GdprMaskType</span> &#123; NONE, DEFAULT, SENSITIVE, EXTREME_SENSITIVE &#125;</span><br></pre></td></tr></table></figure><p>3.AOP实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuditLogAspect</span> &#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(AuditLogAspect.class); </span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> AuditLogRepository auditLogRepository; </span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> GdprMaskService maskService;</span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> UserContext userContext; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;@annotation(auditLog)&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">logAround</span><span class="params">(ProceedingJoinPoint joinPoint, AuditLog auditLog)</span> <span class="keyword">throws</span> Throwable &#123; </span><br><span class="line"><span class="comment">// 1. 构建日志对象 </span></span><br><span class="line"><span class="type">AuditLogEntity</span> <span class="variable">logEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuditLogEntity</span>(); </span><br><span class="line">logEntity.setOperationTime(<span class="keyword">new</span> <span class="title class_">Date</span>()); </span><br><span class="line">logEntity.setTargetClass(joinPoint.getTarget().getClass().getName()); </span><br><span class="line">logEntity.setTargetMethod(joinPoint.getSignature().getName()); </span><br><span class="line">logEntity.setRequestIp(IpUtils.getClientIp()); </span><br><span class="line"><span class="comment">// 2. 解析SpEL表达式</span></span><br><span class="line"><span class="type">EvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> createEvaluationContext(joinPoint); </span><br><span class="line">parseSpEL(auditLog, logEntity, context); </span><br><span class="line"><span class="comment">// 3. 执行目标方法 </span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">result = joinPoint.proceed(); </span><br><span class="line">logEntity.setIsSuccess(<span class="literal">true</span>); </span><br><span class="line">logEntity.setResult(maskService.maskData( evaluateSpEL(auditLog.result(), context), auditLog.maskType() )); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123; </span><br><span class="line">logEntity.setIsSuccess(<span class="literal">false</span>); </span><br><span class="line">logEntity.setException(e.getMessage());</span><br><span class="line"><span class="keyword">throw</span> e; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 保存日志 </span></span><br><span class="line">auditLogRepository.save(logEntity); </span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> EvaluationContext <span class="title function_">createEvaluationContext</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123; </span><br><span class="line"><span class="type">DefaultEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEvaluationContext</span>(userContext); </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; joinPoint.getArgs().length; i++) &#123; </span><br><span class="line">context.setVariable(<span class="string">&quot;arg&quot;</span> + i, joinPoint.getArgs()[i]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> context; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseSpEL</span><span class="params">(AuditLog auditLog, AuditLogEntity logEntity, EvaluationContext context)</span> &#123; </span><br><span class="line"><span class="comment">// 解析操作描述 </span></span><br><span class="line"><span class="keyword">if</span> (!auditLog.value().isEmpty()) &#123; </span><br><span class="line">logEntity.setDescription(evaluateSpEL(auditLog.value(), context)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 解析操作人 </span></span><br><span class="line"><span class="keyword">if</span> (!auditLog.operator().isEmpty()) &#123; </span><br><span class="line">logEntity.setOperator(evaluateSpEL(auditLog.operator(), context)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 解析操作人ID </span></span><br><span class="line"><span class="keyword">if</span> (!auditLog.operatorId().isEmpty()) &#123; </span><br><span class="line">logEntity.setOperatorId(evaluateSpEL(auditLog.operatorId(), context)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 解析参数 </span></span><br><span class="line"><span class="keyword">if</span> (!auditLog.params().isEmpty()) &#123; </span><br><span class="line">logEntity.setParams(evaluateSpEL(auditLog.params(), context)); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">evaluateSpEL</span><span class="params">(String expression, EvaluationContext context)</span> &#123; </span><br><span class="line"><span class="keyword">return</span> parser.parseExpression(expression).getValue(context, String.class); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AuditLog(value = &quot;用户注册&quot;, operator = &quot;#userContext.username&quot;, params = &quot;#args[0].toString()&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(User user)</span> &#123; <span class="keyword">return</span> userService.save(user); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AuditLog(value = &quot;用户登录&quot;, operator = &quot;#userContext.username&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line"> <span class="comment">// 登录逻辑 return &quot;登录成功&quot;; </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器实现"><a href="#拦截器实现" class="headerlink" title="拦截器实现"></a>拦截器实现</h3><p>1.实体定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.biz.model.common.access;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**访问用户*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**uri*/</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**访问时长*/</span></span><br><span class="line">    <span class="keyword">private</span> Long duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**请求方式*/</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**客户端IP*/</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**状态码*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**时间*/</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.拦截器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.biz.config.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxx.biz.model.common.access.AccessLog;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**访问开始时间*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_REQUEST_START_TIME</span> <span class="operator">=</span> <span class="string">&quot;KEY_REQUEST_START_TIME&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**访问请求日志对象*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_ACCESS_LOG</span> <span class="operator">=</span> <span class="string">&quot;KEY_ACCESS_LOG&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AccessLog</span> <span class="variable">accessLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessLog</span>();</span><br><span class="line">        accessLog.setIp(SpringUtils.getIpAddr())</span><br><span class="line">                .setMethod(request.getMethod())</span><br><span class="line">                .setUri(request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将信息绑定在request中</span></span><br><span class="line">        request.setAttribute(KEY_REQUEST_START_TIME, System.currentTimeMillis());</span><br><span class="line">        request.setAttribute(KEY_ACCESS_LOG, accessLog);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                            <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AccessLog</span> <span class="variable">accessLog</span> <span class="operator">=</span> (AccessLog) request.getAttribute(KEY_ACCESS_LOG);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> (Long) request.getAttribute(KEY_REQUEST_START_TIME);</span><br><span class="line">        <span class="keyword">if</span> (accessLog != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">createTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="type">AuthContext</span> <span class="variable">context</span> <span class="operator">=</span> AuthContextHolder.getContext();</span><br><span class="line">            accessLog.setCreateTime(createTime)</span><br><span class="line">                    .setDuration(createTime.getTime() - startTime)</span><br><span class="line">                    .setStatus(response.getStatus())</span><br><span class="line">                    .setUsername(context == <span class="literal">null</span> ? <span class="literal">null</span> : context.getUsername());</span><br><span class="line">            log.debug(accessLog.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.拦截器注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.xxx.biz.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxx.biz.config.log.AccessLogInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加拦截器，配置拦截地址</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">AccessLogInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.log4j配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--访问日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;accessAppender&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;/log_access.log&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;/access/log-access-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">append</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置日志格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;ACCESS_LOG_PATTERN&#125;&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 基于时间的触发策略。该策略主要是完成周期性的log文件封存工作。有两个参数：</span></span><br><span class="line"><span class="comment">               interval，integer型，指定两次封存动作之间的时间间隔。单位:以日志的命名精度来确定单位，</span></span><br><span class="line"><span class="comment">                   比如yyyy-MM-dd-HH 单位为小时，yyyy-MM-dd-HH-mm 单位为分钟</span></span><br><span class="line"><span class="comment">               modulate，boolean型，说明是否对封存时间进行调制。若modulate=true，</span></span><br><span class="line"><span class="comment">                   则封存时间将以0点为边界进行偏移计算。比如，modulate=true，interval=4hours，</span></span><br><span class="line"><span class="comment">                   那么假设上次封存日志的时间为00:00，则下次封存日志的时间为04:00，</span></span><br><span class="line"><span class="comment">                   之后的封存时间依次为08:00，12:00，16:00--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy 属性如不设置，则默认为最多同一文件夹下当天 7 个文件后开始覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 删除处理策略，在配置的路径中搜索，maxDepth 表示往下搜索的最大深度 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Delete</span> <span class="attr">basePath</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;/&quot;</span> <span class="attr">maxDepth</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 文件名搜索匹配，支持正则 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">IfFileName</span> <span class="attr">glob</span>=<span class="string">&quot;*.log.gz&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--!<span class="doctag">Note:</span> 这里的 age 必须和 filePattern 协调, 后者是精确到 dd, 这里就要写成 xd, xD 就不起作用</span></span><br><span class="line"><span class="comment">                    另外, 数字最好 &gt;2, 否则可能造成删除的时候, 最近的文件还处于被占用状态,导致删除不成功!--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--7天--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">IfLastModified</span> <span class="attr">age</span>=<span class="string">&quot;7d&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">Delete</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">DefaultRolloverStrategy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--变量配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化输出：%date 表示日期，%thread 表示线程名，%-5level：级别从左显示 5 个字符宽度 %msg：日志消息，%n 是换行符--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长 36 个字符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level [%logger&#123;50&#125;:%L] - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_CONSOLE_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%style&#123;%d&#123;ISO8601&#125;&#125;&#123;bright,green&#125; %highlight&#123;%-5level&#125; [%style&#123;%t&#125;&#123;bright,blue&#125;] %style&#123;%C&#123;&#125;&#125;&#123;bright,yellow&#125;: %msg%n%style&#123;%throwable&#125;&#123;red&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ACCESS_LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志存储的路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;newframe&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">&quot;com.xxx.biz.config.log.AccessLogInterceptor&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;accessAppender&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;consoleAppender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在企业级业务系统中，审计日志记录非常重要。特别是涉及到用户操作一些关键业务数据的新增、修改、删除时，系统应追踪操作人、操作对象和操作时间等关</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://andy-whb-cn.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2025/10/21/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/"/>
    <id>https://andy-whb-cn.github.io/2025/10/21/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/</id>
    <published>2025-10-21T07:55:18.846Z</published>
    <updated>2025-10-21T08:31:43.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="层层限流策略"><a href="#层层限流策略" class="headerlink" title="层层限流策略"></a>层层限流策略</h1><p><img src="/image-20251021161012138.jpg"></p><h2 id="合法性限流"><a href="#合法性限流" class="headerlink" title="合法性限流"></a>合法性限流</h2><p><img src="/image-20251021161442639.jpg"><br>首先需要知道哪些请求是非法的，并针对场景进行限制。<br>比如需要限制机器人或刷单行为，解决方法有：<br> 1、验证码，有效规避机器人且拉长用户访问时间；<br> 2、IP限制，使用网络监测技术监控相同IP的访问频率，或者反复购买同一件商品，加入到黑明单；<br> 3、隐藏秒杀入口，秒杀之前不开放。</p><h2 id="负载限流"><a href="#负载限流" class="headerlink" title="负载限流"></a>负载限流</h2><p><img src="/image-20251021161529684.jpg"><br>负载限流是指对网络请求，进行网络流量的负载均衡，通常配置如nginx进行请求的负载均衡。<br><img src="/image-20251021161553967.jpg"><br>根据网络7层模型，对网络请求可以在多层设备上进行负载均衡，也就是级联负载。<br> <img src="/image-20251021160245296.jpg"></p><p>级联负载并不是越多越好，原因是每增加一个负载，就增加了一次转发路径，可能会带来网络延迟问题。</p><p>常见的软负载主要是用Nginx或LVS（四层）+Nginx，可以满足绝大多数应用。</p><p>还可以利用一些硬件负载工具进行硬负载。</p><p><img src="/image-20251021162429808.jpg"></p><h2 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h2><h3 id="服务器限流"><a href="#服务器限流" class="headerlink" title="服务器限流"></a>服务器限流</h3><p>1、容器设置最大连接数<br>2、服务进行算法限流：令牌桶、漏斗， guava<br><img src="/image-20251021160441163.jpg"></p><h3 id="队列限流"><a href="#队列限流" class="headerlink" title="队列限流"></a>队列限流</h3><p><img src="/image-20251021162743906.jpg"><br>用户请求加入临时队列，每个子系统按照最大承载性能进行拉取消费处理。</p><h3 id="缓存限流"><a href="#缓存限流" class="headerlink" title="缓存限流"></a>缓存限流</h3><p>静态资源，浏览器缓存网站静态页面资源，较大的图片可以缓存在nginx或oss，更大的视频资源可以缓存到CDN服务器（底层可以是OSS）。<br><img src="/image-20251021160714552.jpg"></p><p>动态二级缓存<br><img src="/image-20251021160759750.jpg"></p><p>缓存也不是越多越好，因为缓存多就会导致一致性问题</p><h3 id="监控限流"><a href="#监控限流" class="headerlink" title="监控限流"></a>监控限流</h3><p>线程监控CPU&#x2F;内存利用率，采用服务降级或拒绝策略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;层层限流策略&quot;&gt;&lt;a href=&quot;#层层限流策略&quot; class=&quot;headerlink&quot; title=&quot;层层限流策略&quot;&gt;&lt;/a&gt;层层限流策略&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image-20251021161012138.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;合</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2025/04/25/%E5%B0%8F%E5%B7%A5%E5%85%B7/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://andy-whb-cn.github.io/2025/04/25/%E5%B0%8F%E5%B7%A5%E5%85%B7/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2025-04-25T02:29:12.878Z</published>
    <updated>2025-04-25T02:30:09.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-PDF压缩"><a href="#一、-PDF压缩" class="headerlink" title="一、 PDF压缩"></a>一、 PDF压缩</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compress_pdf</span>(<span class="params">input_pdf_path, output_pdf_path</span>):  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        pdf = fitz.<span class="built_in">open</span>(input_pdf_path)  </span><br><span class="line">        writer = fitz.<span class="built_in">open</span>()  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> page_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pdf)):  </span><br><span class="line">            page = pdf[page_num]  </span><br><span class="line">            pix = page.get_pixmap()  </span><br><span class="line">            <span class="comment"># 压缩图片  </span></span><br><span class="line">            img = fitz.<span class="built_in">open</span>(<span class="string">&quot;png&quot;</span>, pix.tobytes())  </span><br><span class="line">            <span class="comment"># 压缩图片质量  </span></span><br><span class="line">            img_pix = img[<span class="number">0</span>].get_pixmap()  </span><br><span class="line">            new_image_bytes = img_pix.tobytes(output=<span class="string">&quot;jpeg&quot;</span>, jpg_quality=<span class="number">30</span>)  </span><br><span class="line">            width = pix.width  </span><br><span class="line">            height = pix.height  </span><br><span class="line">            new_page = writer.new_page(width=width, height=height)  </span><br><span class="line">            <span class="comment"># new_page = writer.new_page(width=rect.width, height=rect.height)  </span></span><br><span class="line">            new_page.insert_image((<span class="number">0</span>, <span class="number">0</span>, width, height), stream=new_image_bytes)  </span><br><span class="line">  </span><br><span class="line">        writer.save(output_pdf_path, deflate=<span class="literal">True</span>, garbage=<span class="number">4</span>)  </span><br><span class="line">        writer.close()  </span><br><span class="line">        pdf.close()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;PDF 压缩完成，保存至 <span class="subst">&#123;output_pdf_path&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;压缩过程中出现错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    input_pdf = <span class="string">&quot;/Users/xx/Downloads/xx.pdf&quot;</span>  </span><br><span class="line">    output_pdf = <span class="string">&quot;/Users/xx/Downloads/xx-1.pdf&quot;</span>  </span><br><span class="line">    compress_pdf(input_pdf, output_pdf)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-PDF压缩&quot;&gt;&lt;a href=&quot;#一、-PDF压缩&quot; class=&quot;headerlink&quot; title=&quot;一、 PDF压缩&quot;&gt;&lt;/a&gt;一、 PDF压缩&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2025/02/17/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E6%8E%A2%E7%A9%B6%20PIKE-RAG/"/>
    <id>https://andy-whb-cn.github.io/2025/02/17/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E6%8E%A2%E7%A9%B6%20PIKE-RAG/</id>
    <published>2025-02-17T05:18:52.109Z</published>
    <updated>2025-02-24T06:02:57.292Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/qq_41739364/article/details/145655874">https://blog.csdn.net/qq_41739364/article/details/145655874</a></p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>PIKE-RAG是<strong>微软亚洲研究院推出的检索增强型生成框架</strong>。</p><h4 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h4><p>传统RAG方案很难从冗长、多格式乃至图表混杂的数据中，<strong>高效且准确</strong>地抽取并理解“专业领域知识”以及“多步推理逻辑”，具体需要解决的问题：</p><ol><li><strong>知识来源多样，检索难以兼容</strong>：数据格式复杂（PDF、图表、数据库等），致使简单文本分块失效；</li><li><strong>缺乏领域专业化</strong>：现有LLMs对专业名词、物理&#x2F;法律原理的理解不充分；</li><li><strong>一刀切式处理，不支持多层次任务</strong>：简单问题与多跳复杂问题混为一谈，缺少对任务复杂度的量化或分级机制。</li></ol><p>PIKE-RAG因此提出，针对不同“难度等级”（从简单事实检索到多跳推理、预测、创意规划），分阶段优化系统，使之在“知识抽取”、“推理逻辑”、“问题分解”方面更适配实际工业应用。</p><p>它不仅检索文本，而且会将原文中蕴含的关键领域知识进行更深入的结构化提炼（如“原子化知识”或“多层异构图”），并采用“分步式”或“多回合式”推理策略去解决复杂问题。</p><h4 id="核心研究论点"><a href="#核心研究论点" class="headerlink" title="核心研究论点"></a>核心研究论点</h4><p>1、提出“专业知识与推理增益”的 RAG 新范式：<br>    主张在传统检索增强式生成（RAG）中，不仅要“检索”文本片段，也要有效地抽取和运用专业化知识，并借助合乎逻辑的推理轨迹来支撑回答的准确性。<br>2、分级问题分类与分层系统划分：<br>    将工业领域常见问题从易到难分为四类（事实类、链式推理类、预测类、创造类）；并据此将 RAG 系统的能力分为四级（L1–L4），指导系统由浅入深迭代开发。<br>3、提出“PIKE-RAG”框架：<br>    通过知识原子化（Knowledge Atomizing）和知识感知式的任务分解（Knowledge-Aware Task Decomposition）显著提升复杂多跳推理、预测以及创造类问题的可解性与准确度。</p><h4 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h4><p>1、避免单个子问题“问错”后就彻底走偏；通过多原子问题候选，可以更灵活地匹配文本里多样的表达方式。<br>    面对需要跨多文档、多跳、多方面对比&#x2F;分析的复杂问题，单轮检索 + LLM 生成方式往往不足。<br>    现有的一些多跳方法（Self-Ask 等）尽管引入了“自问自答”的思路，但若每步检索的查询本身就错了或遗漏了关键子问题，也容易造成最终回答错误。<br>    作者的观察：多跳问题常常需要在推理时“边看已有上下文，边决定下一个子问题”——如果问错了子问题，就会将检索带偏。因此需要一个更精细的“任务分解+动态检索+逐步推理”的框架，以便在每一步根据已获取的知识来生成更合理的下一个子问题或检索请求。在回答复杂问题时，不再单步生成子问题，而是生成多条潜在原子问题候选，并根据知识库中实际能检索到的答案碎片，再选取合适的子问题继续；</p><p>2、创新的框架</p><p><strong>多层异构图谱式知识库（Multi-layer Heterogeneous Graph）：</strong><br>通过信息资源层、语料层、精炼知识层的多层次建模，将长文本、图表、引用关系等纳入整体图结构，方便后续检索与推理。</p><p><strong>知识原子化（Knowledge Atomizing）：</strong><br>在对文本分块（chunk）基础上，利用大模型生成的“原子问题”标签，更精细地标注和切分文本片段，使每个 chunk 内部的核心要点以问答式的原子知识展示。</p><p><strong>任务分解与多轮协同（Knowledge-Aware Task Decomposition）：</strong><br>通过让系统“感知”到知识库中已经存在哪些原子问题，来引导下一步更精准的拆解；多轮获取新的支撑证据，逐步构建答案的推理链。</p><p><strong>分级系统架构（L1–L4 分阶部署）：</strong><br>从能回答单一事实问答（L1）到支持多跳推理（L2），再到可做预测（L3）和可提供创造性建议（L4），逐步扩展功能模块与算法复杂度。</p><p><strong>针对需要预测或创意类问题（如 Level-3&#x2F;4），需要先完成对历史数据&#x2F;结构化信息的“收敛”，再启动 “高阶推理”</strong></p><p>要点：<br>预测&#x2F;创意问题往往没有现成的答案，需要先把相关知识或数据按时间序列、对比列表等形式组织好，才能在下一步推理里进行规律&#x2F;趋势发现或大胆推断；<br>引入带有 “知识归纳抽象出更高层规律 knowledge induction &#x2F; 收集数据预测 forecasting &#x2F; 多智能体规划 multi-agent planning”等扩展模块，在已有原子知识上作更高级别合成。</p><p>预期效果：把问题拆成“先收集与结构化 → 再归纳出趋势或提出创意”，从而使 RAG 系统在专业预测和创造任务上也能形成可解释的推理链。</p><h4 id="可能的反驳和应对"><a href="#可能的反驳和应对" class="headerlink" title="可能的反驳和应对"></a>可能的反驳和应对</h4><p><strong>可能的反驳：构建异构图知识库成本高</strong><br>应对：提供自动化文档解析、表格提取工具及模块化方法，后期更新维护也相对易于管理；分级部署可先在 L1&#x2F;L2 低门槛场景试点。</p><p><strong>可能的反驳：多轮分解的效率是否下降</strong><br>应对：多数工业问题无需无限轮迭代，一般 2–5 轮内即可锁定核心信息；且可通过并行检索和评分机制减少不必要的轮次。</p><p><strong>可能的反驳：在创造类问题无法验证答案正确性</strong><br>应对：针对创造类问题（L4），评估可以纳入专家评分、启发性、可行性等维度；并非追求唯一正确解，而是看是否提供有价值的思路。</p><p><img src="/image-20250217152224084.jpg"><br><img src="/image-20250217152228538.jpg"></p><p>相关参考文档：<a href="https://zhuanlan.zhihu.com/p/23796240431">https://zhuanlan.zhihu.com/p/23796240431</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/qq_41739364/article/details/145655874&quot;&gt;https://blog.csdn.net/qq_41739364/article/details/145655874&lt;/a&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2025/02/17/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9E%84%E5%BB%BA/"/>
    <id>https://andy-whb-cn.github.io/2025/02/17/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9E%84%E5%BB%BA/</id>
    <published>2025-02-17T02:44:55.561Z</published>
    <updated>2025-02-17T05:18:49.405Z</updated>
    
    <content type="html"><![CDATA[<p>知识库的管理</p><p>检索：PIKE-RAG</p><p>COZE&#x2F;DIFY 的源码研究</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;知识库的管理&lt;/p&gt;
&lt;p&gt;检索：PIKE-RAG&lt;/p&gt;
&lt;p&gt;COZE&amp;#x2F;DIFY 的源码研究&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringData: JPA</title>
    <link href="https://andy-whb-cn.github.io/2025/01/02/SpringBoot/SpringData%EF%BC%9AJPA/"/>
    <id>https://andy-whb-cn.github.io/2025/01/02/SpringBoot/SpringData%EF%BC%9AJPA/</id>
    <published>2025-01-02T07:15:57.918Z</published>
    <updated>2025-01-20T05:01:52.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mybatis已经2年没有更新了，虽然业界还在普遍使用，但新项目已经不推荐了。对于习惯了batis这种ORM框架的开发团队，从流行度和稳定性上来说，新项目使用国内baomidou团队的Mybatis-Plus是较好的选择。<br>当然针对mybatis-plus，国内也有一些号称更好用的ORM框架，截几个有意思的图看下，不做评论。<br><img src="/image-20250102154536633.jpg"><br><img src="/image-20250102154426374.jpg"><br><img src="/image-20250102154631543.jpg"></p><p>作为java程序员，是时候捡起业界比较火热的JPA来研究研究了。我印象中的JPA还停留在hibernate时代级联多表操作复杂、性能差等负面印象中，但据说最新的JPA 3.0 和Hibernate 6.0已经解决了这类难用的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Mybatis已经2年没有更新了，虽然业界还在普遍使用，但新项目已经不推荐了。对于习惯了batis这种ORM框架的开发团队，从流行度和稳定性</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/12/31/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://andy-whb-cn.github.io/2024/12/31/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-12-31T02:51:55.120Z</published>
    <updated>2024-12-31T03:04:04.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="埃森哲国内企业架构咨询案例：“四横五纵”架构设计"><a href="#埃森哲国内企业架构咨询案例：“四横五纵”架构设计" class="headerlink" title="埃森哲国内企业架构咨询案例：“四横五纵”架构设计"></a><strong>埃森哲国内企业架构咨询案例：“四横五纵”架构设计</strong></h2><p><strong>“四横五纵”架构设计</strong>通过四个层次（策略层、管理层、设计层、实施层）和五个领域（业务架构、应用架构、数据架构、技术架构、架构管控）的系统化设计，确保企业IT系统与业务战略高度一致。通过自上而下的目标驱动和自下而上的实现反馈，构建出一个科学、合理的企业信息化蓝图，优化资源配置，提升企业灵活性和运营效率。</p><p><img src="/image-20241231105208457.jpg"><br>“四横”聚焦架构的分层设计，从战略到实施逐层细化；“五纵”涵盖架构的五大核心领域，形成互补协同的整体架构生态。</p><h3 id="“四横”分层设计详解"><a href="#“四横”分层设计详解" class="headerlink" title="“四横”分层设计详解"></a>“四横”分层设计详解</h3><p><img src="/image-20241231105249902.jpg"></p><h4 id="第一层：策略层视图"><a href="#第一层：策略层视图" class="headerlink" title="第一层：策略层视图"></a><strong>第一层：策略层视图</strong></h4><p>策略层是架构的宏观指导层，决定信息化建设的目标与方向。该层强调全局性和整体性。</p><ul><li><strong>主要任务：</strong><ul><li><strong>信息化战略规划</strong>：与企业业务战略深度对接，确定长期目标和短期目标。</li><li><strong>制定政策规范</strong>：如数据治理、信息安全、技术选型等，为架构设计提供政策框架。</li><li><strong>规划信息化蓝图</strong>：结合业务需求与技术趋势，绘制企业信息化的总体规划。</li></ul></li><li><strong>输出成果：</strong><ul><li>信息化战略规划报告</li><li>信息化政策文件</li></ul></li></ul><h4 id="第二层：管理层视图"><a href="#第二层：管理层视图" class="headerlink" title="第二层：管理层视图"></a><strong>第二层：管理层视图</strong></h4><p>管理层进一步细化策略层目标，形成具体的架构蓝图。</p><ul><li><strong>主要任务：</strong><ul><li><strong>业务架构规划</strong>：定义业务域、职能、流程及其关联关系。</li><li><strong>应用架构规划</strong>：设计支撑业务的应用系统及其功能模块。</li><li><strong>数据架构设计</strong>：明确数据主题、数据模型及流转关系。</li><li><strong>技术架构规划</strong>：配置支持应用和数据的技术平台。</li></ul></li><li><strong>输出成果：</strong><ul><li>业务架构图</li><li>应用架构图</li><li>数据架构图</li><li>技术架构图</li></ul></li></ul><h4 id="第三层：设计层视图"><a href="#第三层：设计层视图" class="headerlink" title="第三层：设计层视图"></a><strong>第三层：设计层视图</strong></h4><p>设计层聚焦架构的具体实现性，提供详细的解决方案。</p><ul><li><strong>主要任务：</strong><ul><li><strong>应用系统设计</strong>：功能模块、界面、数据库详细设计。</li><li><strong>数据模型设计</strong>：包括概念、逻辑、物理数据模型。</li><li><strong>技术平台细化</strong>：明确技术组件、接口和部署方案。</li><li><strong>安全体系规划</strong>：设计全面的信息安全方案。</li></ul></li><li><strong>输出成果：</strong><ul><li>详细设计文档（应用、数据、技术、安全）</li></ul></li></ul><h4 id="第四层：实施层视图"><a href="#第四层：实施层视图" class="headerlink" title="第四层：实施层视图"></a><strong>第四层：实施层视图</strong></h4><p>实施层是架构设计的落地和执行阶段。</p><ul><li><strong>主要任务：</strong><ul><li><strong>软件开发</strong>：按照设计文档进行开发、测试和调试。</li><li><strong>系统集成</strong>：实现应用系统间的数据交换与业务协同。</li><li><strong>部署与运维</strong>：将系统部署到生产环境，并提供持续支持。</li><li><strong>持续优化</strong>：根据反馈调整和改进系统。</li></ul></li><li><strong>输出成果：</strong><ul><li>软件系统</li><li>集成后的应用系统</li><li>运维文档</li></ul></li></ul><p><img src="/image-20241231105837602.jpg"></p><h3 id="“五纵”架构设计详解"><a href="#“五纵”架构设计详解" class="headerlink" title="“五纵”架构设计详解"></a>“五纵”架构设计详解</h3><p><img src="/image-20241231105845730.jpg"> </p><h4 id="1-业务架构"><a href="#1-业务架构" class="headerlink" title="1. 业务架构"></a>1. 业务架构</h4><p>业务架构是企业架构的基础，聚焦企业的核心业务流程和价值链。<br><img src="/image-20241231105908873.jpg"></p><ul><li><strong>关键要素：</strong><ul><li><strong>业务域与职能</strong>：划分业务领域（如财务、人力资源等）及具体职能。</li><li><strong>组织单元</strong>：定义部门、团队等具体执行实体及其协作关系。</li><li><strong>业务流程</strong>：梳理起点、终点及活动逻辑，优化端到端流程。</li></ul></li><li><strong>输出成果：</strong><ul><li>业务架构图</li><li>端到端流程图</li></ul></li></ul><h4 id="2-应用架构"><a href="#2-应用架构" class="headerlink" title="2. 应用架构"></a><strong>2. 应用架构</strong></h4><p>应用架构支撑业务逻辑的信息化实现，规划应用系统的功能与交互。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/BInMRExFg4Wv8K9cp0kzIggDe8uab7VNxPZN3jvoeCvGCoIqSmqhm5tJkicDDzesoogsjic4bWzPfcjdXVWkWiaOg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><strong>关键要素：</strong><ul><li><strong>应用域和功能模块</strong>：明确每个应用的功能范围及模块划分。</li><li><strong>接口与交互</strong>：定义数据交换接口和交互协议，确保系统集成。</li><li><strong>应用分布与部署</strong>：规划应用在组织单元中的使用和分布。</li></ul></li><li><strong>输出成果：</strong><ul><li>应用架构图</li><li>接口规范文档</li></ul></li></ul><h4 id="3-数据架构"><a href="#3-数据架构" class="headerlink" title="3. 数据架构"></a><strong>3. 数据架构</strong></h4><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/BInMRExFg4Wv8K9cp0kzIggDe8uab7VN031QWBP9grjht6DAQEeZfh0t7pyoqXmvNq4KVDcF4JMvkx15AVtB5A/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>数据架构确保企业数据资源的一致性和高效利用。</p><ul><li><strong>关键要素：</strong><ul><li><strong>数据主题与实体</strong>：明确数据主题（如客户数据、财务数据）和数据实体。</li><li><strong>数据模型</strong>：设计概念、逻辑和物理数据模型。</li><li><strong>数据流转与治理</strong>：规划数据在系统间的流转及数据质量、安全管理策略。</li></ul></li><li><strong>输出成果：</strong><ul><li>数据架构图</li><li>数据模型设计文档</li></ul></li></ul><h4 id="4-技术架构"><a href="#4-技术架构" class="headerlink" title="4. 技术架构"></a><strong>4. 技术架构</strong></h4><p>技术架构描述支撑业务和数据的技术平台及基础设施。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/BInMRExFg4Wv8K9cp0kzIggDe8uab7VNmo2oTQDwfoVTlicl0VyXOPqPOrE0u8O67zMc75CqLzSxwwsUzibyUOTQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><strong>关键要素：</strong><ul><li><strong>技术平台与组件</strong>：选择操作系统、数据库、中间件等组件。</li><li><strong>系统集成与接口</strong>：确保不同技术平台和系统间的无缝连接。</li><li><strong>基础设施与安全</strong>：规划数据中心、网络和安全体系。</li></ul></li><li><strong>输出成果：</strong><ul><li>技术架构图</li><li>集成方案</li><li>安全设计文档</li></ul></li></ul><h4 id="5-架构管控"><a href="#5-架构管控" class="headerlink" title="5. 架构管控"></a><strong>5. 架构管控</strong></h4><p>架构管控是保障架构设计一致性和持续优化的关键。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/BInMRExFg4Wv8K9cp0kzIggDe8uab7VNSQFekTk8hCDQ2UyYJl5wVOjet9yyfyy7sgz65BiaIhItdg6DiafNk03g/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><strong>关键要素：</strong><ul><li><strong>架构原则</strong>：明确业务导向、技术先进、安全可靠等基本准则。</li><li><strong>管理规范</strong>：制定评审机制、变更管理流程。</li><li><strong>架构资产</strong>：构建蓝图、模式、标准等资产库。</li><li><strong>评审与改进</strong>：定期评估架构成果，确保动态优化。</li></ul></li><li><strong>输出成果：</strong><ul><li>管控规范文档</li><li>架构评审报告</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;埃森哲国内企业架构咨询案例：“四横五纵”架构设计&quot;&gt;&lt;a href=&quot;#埃森哲国内企业架构咨询案例：“四横五纵”架构设计&quot; class=&quot;headerlink&quot; title=&quot;埃森哲国内企业架构咨询案例：“四横五纵”架构设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;埃森哲国内企</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/12/20/%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E5%B9%B4%E7%BB%88%E5%B7%A5%E4%BD%9C%E6%B1%87%E6%8A%A5/"/>
    <id>https://andy-whb-cn.github.io/2024/12/20/%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E5%B9%B4%E7%BB%88%E5%B7%A5%E4%BD%9C%E6%B1%87%E6%8A%A5/</id>
    <published>2024-12-20T05:12:04.151Z</published>
    <updated>2024-12-26T10:12:38.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写作思路思维导图（有思考的汇报）"><a href="#写作思路思维导图（有思考的汇报）" class="headerlink" title="写作思路思维导图（有思考的汇报）"></a>写作思路思维导图（有思考的汇报）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@startmindmap</span><br><span class="line">&lt;style&gt;</span><br><span class="line">mindmapDiagram&#123;</span><br><span class="line">:depth(1)&#123;</span><br><span class="line">BackgroundColor lightGreen</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">* 年终工作汇报</span><br><span class="line">**:==工作框架</span><br><span class="line">给概念;</span><br><span class="line">***_ 1、岗位职责包括几个板块?</span><br><span class="line">***_ 2、各板块几年的重点工作是什么？</span><br><span class="line">***_ 3、总体的完成情况如何？</span><br><span class="line"></span><br><span class="line">**:==核心项目</span><br><span class="line">看好戏;</span><br><span class="line">***_ 1、今年最关键的项目是什么？</span><br><span class="line">***_ 2、具体怎么做的，遇到什么问题？</span><br><span class="line">***_ 3、问题怎么解决的，有哪些收获？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**:==价值影响</span><br><span class="line">讲价值;</span><br><span class="line">***_ 1、短期价值，给业务的影响？</span><br><span class="line">***_ 2、长期影响，给组织的价值？</span><br><span class="line">***_ 3、个人的知识更新和能力沉淀？</span><br><span class="line">***_ 4、总结出来的方法论和工具？</span><br><span class="line"></span><br><span class="line">**:==明年计划</span><br><span class="line">谈规划;</span><br><span class="line">***_ 1、对业务的观察是什么，长期趋势；</span><br><span class="line">***_ 2、对组织的理解是什么，重点工作；</span><br><span class="line">***_ 3、对细节的困惑是什么，请教解答；</span><br><span class="line">***_ 4、对挑战的预估是什么，提出需求；</span><br><span class="line"></span><br><span class="line">@endmindmap</span><br></pre></td></tr></table></figure><p>投顾平台：<br>1、投顾平台3.9.0详设和代码评审，12&#x2F;27发布；<br>2、意见反馈需求沟通，待低代码反馈接口和排期；<br>3、生产问题排查：<br>a) 用户老机器卡顿导致多次加载请求，考虑后台加入全局防重；<br>b) 当日绩效关系的问题；<br>4、支持信创验收材料准备；<br>5、投顾平台VPN旧入口调整问题</p><p>企微SCRM：<br>1、持续跟踪四步法对接CDP客群的进展：客户中心统计接口已提供，联调时间延期到下周；<br>2、生产问题排查：<br>a) 员工OA发起离职流程仍在通讯录的问题；<br>a) 服务记录关联已停用的线索问题；<br>b) 当日到期线索不展示的问题；<br>3、企微SCRM 2.6.1 版本发布支持：下线非信创；</p><p>资配中心：<br>1、本周版本进度跟踪：对接内容中心，页面文字调整，去掉全市场私募，预计12&#x2F;27发布；</p><p>其他：<br>1、年终述职<br>2、北斗场景需求分析：客群&#x2F;线索策略对接CIO栏目自动化展示；</p><p>1、客群&#x2F;线索策略对接CIO栏目场景架构方案评审；<br>2、持续跟踪四步法对接CDP客群的进展；<br>3、MOT工单接口评审；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写作思路思维导图（有思考的汇报）&quot;&gt;&lt;a href=&quot;#写作思路思维导图（有思考的汇报）&quot; class=&quot;headerlink&quot; title=&quot;写作思路思维导图（有思考的汇报）&quot;&gt;&lt;/a&gt;写作思路思维导图（有思考的汇报）&lt;/h2&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Claude构建有效的智能体</title>
    <link href="https://andy-whb-cn.github.io/2024/12/20/%E5%A4%A7%E6%A8%A1%E5%9E%8B/Claude%E6%9E%84%E5%BB%BA%E6%9C%89%E6%95%88%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93/"/>
    <id>https://andy-whb-cn.github.io/2024/12/20/%E5%A4%A7%E6%A8%A1%E5%9E%8B/Claude%E6%9E%84%E5%BB%BA%E6%9C%89%E6%95%88%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93/</id>
    <published>2024-12-19T16:00:00.000Z</published>
    <updated>2025-01-17T02:37:49.109Z</updated>
    
    <content type="html"><![CDATA[<p>在过去的一年里，我们与数十个团队合作，在各个行业构建大型语言模型（LLM）智能体。一直以来，最成功的实现并不是使用复杂的框架或专门的库。相反，他们使用简单、可组合的模式进行构建。</p><p>在这篇文章中，我们分享了从与客户合作以及自己构建智能体中学到的东西，并为开发人员提供了构建有效智能体的实用建议。</p><h1 id="什么是智能体？"><a href="#什么是智能体？" class="headerlink" title="什么是智能体？"></a>什么是智能体？</h1><p>“Agent” 可以有几种定义方式。一些客户将Agent定义为完全自主的系统，能够在较长时间内独立运行，使用各种工具来完成复杂任务。另一些客户则用这个术语来描述更具规定性的实现，即遵循预定义的工作流。在 Anthropic，我们将所有这些变体都归类为具有Agent性质的系统，但在工作流和Agent之间做出了重要的架构区分：</p><ul><li>工作流是通过预定义的代码路径来编排大型语言模型和工具的系统。</li><li>智能体是大语言模型动态地指导自身的流程和工具，并保持对如何完成任务进行控制的系统。</li></ul><p>下面，我们将详细探讨这两种具有Agent性质的系统。在附录 1（“实践中的智能体”）中，我们描述了两个领域，在这些领域中，客户发现使用这类系统具有特别的价值。</p><h2 id="何时（以及何时不使用）Agent"><a href="#何时（以及何时不使用）Agent" class="headerlink" title="何时（以及何时不使用）Agent"></a>何时（以及何时不使用）Agent</h2><p>在使用大语言模型构建应用程序时，我们建议找到尽可能简单的解决方案，并且仅在需要时增加复杂性。这可能意味着根本不构建具有自主性的系统。具有自主性的系统通常以延迟和成本为代价来换取更好的任务性能，你应该考虑这种权衡何时才有意义。</p><p>当需要更高的复杂性时，工作流可为定义明确的任务提供可预测性和一致性，而当需要大规模的灵活性和模型驱动的决策时，智能体是更好的选择。然而，对于许多应用程序来说，通过检索和上下文示例优化单个大型语言模型调用通常就足够了。</p><h2 id="何时以及如何使用框架"><a href="#何时以及如何使用框架" class="headerlink" title="何时以及如何使用框架"></a>何时以及如何使用框架</h2><p>有许多框架使智能体系统更容易实现，包括：</p><ul><li>来自 LangChain 的 LangGraph;</li><li>Amazon Bedrock 的人工智能Agent框架；</li><li>Rivet，一个可拖放的图形用户界面大语言模型工作流生成器;</li><li>Vellum，另一个用于构建和测试复杂工作流的图形用户界面工具。</li></ul><p>这些框架通过简化诸如调用语言模型、定义和解析工具以及将调用链接在一起等标准的低级任务，使得入门变得容易。然而，它们通常会创建额外的抽象层，这可能会掩盖底层的提示和响应，使得调试更加困难。它们还可能会让人在简单的设置就足够的情况下倾向于增加复杂性。</p><p>我们建议开发人员从直接使用大语言模型 API 开始：许多模式可以用几行代码实现。如果你确实使用了一个框架，请确保你理解底层代码。对底层情况的错误假设是客户错误的常见来源。</p><p>有关一些示例实施，请参阅我们的说明书。</p><h2 id="模块、工作流和智能体"><a href="#模块、工作流和智能体" class="headerlink" title="模块、工作流和智能体"></a>模块、工作流和智能体</h2><p>在本节中，我们将探讨在生产中看到的智能体系统的常见模式。我们将从基础模块 —— 增强型语言模型开始，并逐步增加复杂性，从简单的组合工作流到自主智能体。</p><h3 id="模块：增强的-LLM"><a href="#模块：增强的-LLM" class="headerlink" title="模块：增强的 LLM"></a>模块：增强的 LLM</h3><p>具有Agent性质的系统的基本模块是一个经过检索、工具和记忆等增强功能强化的大语言模型。我们当前的模型可以积极地使用这些能力 —— 生成自己的搜索查询、选择合适的工具，并确定要保留哪些信息。<br><img src="/image-20250113154617900.jpg"><br>图1 增强的LLM</p><p>我们建议重点关注实现的两个关键方面：根据您的特定用例调整这些功能，并确保它们为您的大型语言模型提供一个简单、有良好文档记录的接口。虽然有很多方法可以实现这些增强功能，但一种方法是通过我们最近发布的模型上下文协议，该协议允许开发人员通过简单的客户端实现与不断增长的第三方工具生态系统集成。</p><p>在本文的其余部分，我们将假设每个大型语言模型调用都可以访问这些增强功能。</p><h3 id="工作流：提示链"><a href="#工作流：提示链" class="headerlink" title="工作流：提示链"></a>工作流：提示链</h3><p>提示链将一个任务分解为一系列步骤，在每个步骤中，语言模型的调用处理前一个步骤的输出。你可以在任何中间步骤添加编程检查（见下图中的 “门”），以确保流程仍在正轨上。</p><p><img src="/image-20250113154913052.jpg"><br>图2 提示链工作流</p><p><strong>何时使用</strong>： 适合任务可以轻松、清晰地分解为固定子任务的情况。主要目标是通过使每个 LLM 调用成为更简单的任务，以延迟为代价换取更高的准确性。</p><p><strong>适用场景示例</strong>：</p><ul><li>生成营销文案，然后将其翻译成另一种语言。</li><li>撰写文档大纲，检查大纲是否符合特定标准，然后根据大纲撰写文档。</li></ul><h3 id="工作流：路由"><a href="#工作流：路由" class="headerlink" title="工作流：路由"></a>工作流：路由</h3><p>路由对输入进行分类并将其定向到专门的后续任务。这种工作流程允许分离关注点，并构建更专门的提示。如果没有这种工作流，针对一种输入进行优化可能会损害对其他输入的性能。</p><p><img src="/image-20250113155122668.jpg"><br>图3 路由工作流</p><p><strong>何时使用：</strong> 对于复杂任务，路由很有效，在这些任务中，存在不同的类别，最好分别处理，并且可以通过大型语言模型或更传统的分类模型 &#x2F; 算法准确地进行分类。</p><p><strong>适用场景示例</strong>：</p><ul><li>将不同类型的客户服务查询（一般问题、退款请求、技术支持）引导到不同的下游流程、提示和工具中。</li><li>将简单 &#x2F; 常见问题路由到较小的模型（如 Claude 3.5 Haiku），将困难 &#x2F; 不寻常的问题路由到更强大的模型（如 Claude 3.5 Sonnet），以优化成本和速度。</li></ul><h3 id="工作流：并行化"><a href="#工作流：并行化" class="headerlink" title="工作流：并行化"></a>工作流：并行化</h3><p>大型语言模型有时可以同时处理一项任务，并通过编程方式聚合其输出。这种工作流即并行化，表现在两个关键变体中：</p><ul><li>分段：将任务分解为并行运行的独立子任务。</li><li>投票：多次运行同一任务以获得不同的输出。<br><img src="/image-20250113155606653.jpg"><br>图4 并行化工作流</li></ul><p><strong>何时使用</strong>：当划分的子任务可以并行化以提高速度时，或者当需要多个视角或尝试以获得更高置信度结果时，并行化是有效的。对于具有多种考虑因素的复杂任务，当每个考虑因素由单独的 LLM 调用处理时，大型语言模型通常表现更好，从而可以专注于每个特定方面。</p><p><strong>适用场景示例</strong>：</p><ul><li>分段<ul><li>实施防护机制，即一个模型实例处理用户查询，而另一个模型实例筛查其中不适当的内容或请求。这往往比让同一个大语言模型（LLM）调用同时处理防护检查和核心响应的效果更好 。</li><li>用于评估大型语言模型的性能的自动化评估，每个大型语言模型调用会基于给定提示评估模型性能的不同方面。</li></ul></li><li>投票<ul><li>审查一段代码是否存在漏洞，基于不同的提示词审查，并在发现问题时标记代码。</li><li>评估给定内容是否不适当，有多个提示词评估不同方面，或者需要不同的投票阈值来平衡误报和漏报。</li></ul></li></ul><h3 id="工作流：编排器-工作者"><a href="#工作流：编排器-工作者" class="headerlink" title="工作流：编排器 - 工作者"></a>工作流：编排器 - 工作者</h3><p>在编排器 - 工作者工作流中，一个中央大型语言模型动态地分解任务，将它们委派给工作者大型语言模型，并汇总它们的结果。</p><p><img src="/image-20250113161532141.jpg"><br>编排器-工作者工作流</p><p><strong>何时使用</strong>：此工作流非常适合无法预测所需子任务的复杂任务（例如在编码中，需要更改的文件数量以及每个文件中的更改性质可能取决于任务）。虽然它在拓扑结构上相似，但与并行化的关键区别在于其灵活性 —— 子任务不是预先定义的，而是由编排器根据特定输入确定。</p><p><strong>适用场景示例</strong>：</p><ul><li>对多个文件每次进行复杂更改的代码产品。</li><li>搜索涉及从多个来源收集和分析信息以查找可能相关信息的任务。</li></ul><h3 id="工作流：评估者-优化者"><a href="#工作流：评估者-优化者" class="headerlink" title="工作流：评估者 - 优化者"></a>工作流：评估者 - 优化者</h3><p>在评估者-优化者工作流中，一个大型语言模型调用生成一个响应，而另一个在循环中提供评估和反馈。<br><img src="/image-20250113162604049.jpg"><br>评估者-优化者工作流</p><p><strong>何时使用</strong>：当我们有明确的评估标准，并且迭代改进能提供可衡量的价值时，此工作流特别有效。良好适配的两个标志是，首先，当人类明确表达他们的反馈时，大型语言模型的响应可以明显得到改善；其次，大型语言模型可以提供这样的反馈。这类似于人类作家在制作精良文档时可能经历的迭代写作过程。</p><p><strong>适用场景示例</strong>：</p><ul><li>文学翻译中存在一些细微差别，翻译语言模型可能最初无法捕捉到这些差别，但评估语言模型可以提供有用的批评。</li><li>复杂的搜索任务需要多轮搜索和分析以收集全面的信息，由评估者决定是否需要进一步搜索。</li></ul><h3 id="智能体"><a href="#智能体" class="headerlink" title="智能体"></a>智能体</h3><p>随着大型语言模型在关键能力方面逐渐成熟 —— 理解复杂输入、进行推理和规划、可靠地使用工具以及从错误中恢复，智能体正在生产中崭露头角。智能体的工作始于人类用户的命令或与之进行的交互式讨论。一旦任务明确，智能体就会进行规划并开展行动。</p><p>独立地进行，可能会返回给人类以获取更多信息或进行判断。在执行过程中，智能体在每一步都从环境中获取 “真实情况”（例如工具调用结果或代码执行结果）以评估其进展至关重要。然后，智能体可以在检查点或遇到阻碍时暂停以获取人类反馈。任务通常在完成时终止，但通常也会包括停止条件（例如最大迭代次数）以保持控制。</p><p>智能体可以处理复杂的任务，但它们的实现通常很直接。它们通常只是基于环境反馈在循环中使用工具的大语言模型。因此，清晰且深思熟虑地设计工具集及其文档至关重要。我们在附录 2 中详细阐述了工具开发的最佳实践。</p><p><img src="/image-20250113162758606.jpg"><br>自治Agent</p><p><strong>何时使用</strong>：智能体可用于难以或无法预测所需步骤数量的开放式问题，以及无法硬编码固定路径的情况。语言模型可能会运行很多轮，并且你必须在一定程度上信任其决策。代理的自主性使其非常适合在受信任的环境中扩展任务。代理的自主性意味着更高的成本以及潜在的错误叠加。我们建议在沙盒环境中进行广泛测试，并设置适当的防护措施。</p><p><strong>适用场景示例</strong>：<br>以下示例来自我们自己的实现：</p><ul><li>一个用于解决 SWE-bench 任务的编码智能体，这些任务涉及根据任务描述对许多文件进行编辑。</li><li>我们的 “计算机使用” 参考实现，其中 Claude 使用计算机来完成任务。</li></ul><p><img src="/image-20250113162859011.jpg"><br>编码智能体的高级流程</p><h3 id="结合并定制这些模式"><a href="#结合并定制这些模式" class="headerlink" title="结合并定制这些模式"></a>结合并定制这些模式</h3><p>这些构建模块并非规定性的。它们是开发人员可以塑造和组合以适应不同用例的常见模式。与任何 LLM 功能一样，成功的关键在于衡量性能并对实现进行迭代。重复一遍：只有当复杂性明显改善结果时，你才应该考虑增加复杂性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在大语言模型领域的成功并不在于构建最复杂的系统。而是在于为你的需求构建合适的系统。从简单的提示开始，通过全面评估对其进行优化，只有在更简单的解决方案无法满足需求时才添加多步骤的智能体系统。</p><p>在实现智能体时，我们尝试遵循三个核心原则：</p><ol><li>保持你的智能体设计的简洁性。</li><li>通过明确展示智能体的规划步骤来优先考虑透明度。</li><li>通过全面的工具文档和测试精心设计你的代理计算机接口（ACI）。</li></ol><p>框架可以帮助你快速上手，但在转向生产环境时，不要犹豫减少抽象层并使用基本组件进行构建。遵循这些原则，你可以创建出不仅强大而且可靠、可维护并受用户信任的智能体。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>由埃里克・施伦特兹和巴里・张撰写。这项工作借鉴了我们在 Anthropic 构建智能体的经验以及我们的客户分享的宝贵见解，对此我们深表感激。</p><h2 id="附录-1：实践中的智能体"><a href="#附录-1：实践中的智能体" class="headerlink" title="附录 1：实践中的智能体"></a>附录 1：实践中的智能体</h2><p>我们与客户的合作揭示了人工智能体的两个特别有前景的应用，这些应用展示了上述模式的实际价值。这两个应用都说明了智能体如何在需要对话和行动、有明确的成功标准、支持反馈循环并整合有意义的人工监督的任务中发挥最大价值。</p><h3 id="A-客户支持"><a href="#A-客户支持" class="headerlink" title="A. 客户支持"></a>A. 客户支持</h3><p>客户支持将熟悉的聊天机器人界面与通过工具集成增强的功能相结合。对于更具开放性的智能体来说，这是一种自然的契合，原因如下：</p><ul><li>支持交互自然地遵循对话流程，同时需要访问外部信息和采取行动。</li><li>工具可以集成以提取客户数据、订单历史记录和知识库文章。</li><li>诸如发放退款或更新票务等操作可以通过编程方式处理；并且成功可以通过用户定义的解决方案来明确衡量。</li></ul><p>几家公司已经通过基于使用情况的定价模式证明了这种方法的可行性，该模式仅对成功的解决方案收费，这显示了他们对其智能体有效性的信心。</p><h3 id="B-编码智能体"><a href="#B-编码智能体" class="headerlink" title="B. 编码智能体"></a>B. 编码智能体</h3><p>软件开发领域已展现出对大语言模型（LLM）功能的巨大潜力，其能力从代码补全发展到自主解决问题。智能体特别有效，原因如下：</p><ul><li>代码解决方案可通过自动化测试进行验证；智能体可以使用测试结果作为反馈来迭代解决方案。</li><li>问题空间是明确界定且结构化的；并且输出质量可以客观地衡量。</li></ul><p>在我们自己的实现中，智能体现在可以仅根据拉取请求描述来解决 SWE-bench Verified 基准中的实际 GitHub 问题。然而，虽然自动化测试有助于验证功能，但人工审查对于确保解决方案符合更广泛的系统要求仍然至关重要。</p><h2 id="附录-2：对你的工具进行提示工程设计"><a href="#附录-2：对你的工具进行提示工程设计" class="headerlink" title="附录 2：对你的工具进行提示工程设计"></a>附录 2：对你的工具进行提示工程设计</h2><p>无论您正在构建哪个智能体系统，工具都可能是您智能体的重要组成部分。工具使 Claude 能够通过在我们的 API 中指定它们的确切结构和定义来与外部服务和 API 进行交互。当 Claude 响应时，如果它计划调用工具，它将在 API 响应中包含一个工具使用块。工具定义和规范应与总体提示一样受到及时的工程关注。在这个简短的附录中，我们描述了如何对工具进行提示工程。</p><p>通常有几种方法可以指定相同的操作。例如，你可以通过编写差异（diff）或重写整个文件来指定文件编辑。对于结构化输出，你可以在 Markdown 中或在 JSON 中返回代码。在软件工程中，像这样的差异是表面的，可以无损地从一种转换为另一种。然而，某些格式对于大语言模型来说比其他格式更难编写。编写差异需要在编写新代码之前知道块头中有多少行正在更改。与 Markdown 相比，在 JSON 中编写代码需要对换行符和引号进行额外的转义。</p><p>我们对确定工具格式的建议如下：</p><ul><li>在模型逼入绝境前，给它足够的token来 “思考”。</li><li>保持格式接近模型在互联网文本中自然看到的格式。</li><li>确保没有格式化 “开销”，例如必须准确计算数千行代码的数量，或者对其编写的任何代码进行字符串转义。</li></ul><p>一条经验法则是考虑在人机界面（HCI）上投入多少精力，并计划在创建良好的代理 - 计算机界面（ACI）上投入同样多的精力。以下是关于如何做到这一点的一些想法：</p><ul><li>设身处地为模型着想。根据描述和参数，使用这个工具是否显而易见，还是需要仔细思考？如果是后者，那么对模型来说很可能也是如此。一个好的工具定义通常包括示例用法、边缘情况等。</li><li>案例、输入格式要求以及与其他工具的明确界限。</li><li>如何更改参数名称或描述以使其更加明显？可以将此视为为团队中的初级开发人员编写出色的文档字符串。在使用许多类似工具时，这一点尤其重要。</li><li>测试模型如何使用你的工具：在我们的工作台中运行许多示例输入，以查看模型会犯哪些错误，并进行迭代。</li><li>防错你的工具。更改参数，使其更难出错。</li></ul><p>在为 SWE-bench 构建代理时，我们实际上花费了比整体提示更多的时间来优化我们的工具。例如，我们发现，在代理移出根目录后，模型会使用使用相对文件路径的工具出错。为了解决这个问题，我们将工具更改为始终需要绝对文件路径，我们发现该模型完美地使用了这种方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在过去的一年里，我们与数十个团队合作，在各个行业构建大型语言模型（LLM）智能体。一直以来，最成功的实现并不是使用复杂的框架或专门的库。相反，他们使用简单、可组合的模式进行构建。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们分享了从与客户合作以及自己构建智能体中学到的东西，并为开发人员</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/12/13/%E5%AE%B9%E5%99%A8%E5%8C%96/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8E%A2%E7%A9%B6/"/>
    <id>https://andy-whb-cn.github.io/2024/12/13/%E5%AE%B9%E5%99%A8%E5%8C%96/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8E%A2%E7%A9%B6/</id>
    <published>2024-12-13T02:48:04.453Z</published>
    <updated>2024-12-16T05:31:40.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是云原生架构"><a href="#什么是云原生架构" class="headerlink" title="什么是云原生架构"></a>什么是云原生架构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>云原生是一种软件开发理念和方法论，强调在云计算环境中构建、部署和管理应用程序，充分利用云的弹性、可扩展性和分布式特性。<br>云原生架构是一种构建和运行应用程序的架构风格，它充分利用云计算环境的优势，以容器、微服务、不可变基础设施、声明式 API 等技术为基础，实现应用的快速部署、弹性扩展、高效运维和持续交付。</p><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><table><thead><tr><th>问题域</th><th>传统架构面临的问题</th><th>云原生解决方案</th><th>示例</th></tr></thead><tbody><tr><td>应用开发与部署效率</td><td>开发周期长，迭代速度慢，各功能模块紧密耦合，整体应用需重新构建测试；部署依赖复杂环境配置，开发与生产环境差异易导致部署失败</td><td>采用<strong>微服务架构</strong>，各微服务独立开发、测试、部署；<strong>容器技术</strong>将应用及其依赖打包成独立容器，保证环境一致性</td><td>电商应用拆分为用户、商品、订单等微服务，分别开发部署；Docker 容器化应用可在不同环境一致运行</td></tr><tr><td>应用的可扩展性和弹性</td><td>需预先购买大量硬件资源，资源闲置与不足情况并存，单体应用扩展复杂且风险高</td><td>基于<strong>云计算弹性</strong>，自动调整资源分配，微服务可独立扩展</td><td>在线教育平台直播时自动增加服务器实例，结束后减少；电商订单服务单独扩展</td></tr><tr><td>系统的可靠性和容错性</td><td>一个组件故障可能导致整个应用崩溃，故障恢复需人工干预，过程复杂</td><td>采用<strong>熔断器</strong>模式，多实例部署与负载均衡，自动化运维工具与监控系统<strong>快速检测故障并恢复</strong></td><td>微服务通信中，故障服务被熔断器切断请求；容器编排平台自动重启故障容器</td></tr><tr><td>运维管理复杂性</td><td>运维需管理硬件、操作系统、中间件和应用，手动操作多，依赖关系复杂；监控分散，数据整合难</td><td>不可变基础设施，代码化管理，自动化部署与配置管理工具；集中式监控系统整合数据</td><td>通过更新容器镜像更新应用；Prometheus + Grafana 监控容器、微服务和基础设施</td></tr></tbody></table><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h2 id="如何构建云原生"><a href="#如何构建云原生" class="headerlink" title="如何构建云原生"></a>如何构建云原生</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是云原生架构&quot;&gt;&lt;a href=&quot;#什么是云原生架构&quot; class=&quot;headerlink&quot; title=&quot;什么是云原生架构&quot;&gt;&lt;/a&gt;什么是云原生架构&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/12/09/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E8%AE%A1/"/>
    <id>https://andy-whb-cn.github.io/2024/12/09/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-12-09T08:54:40.104Z</published>
    <updated>2025-02-17T02:44:42.548Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## Role: 专业投资顾问</span></span><br><span class="line"><span class="section">## Background: 我是一位经验丰富的基金投资顾问,我会严格学习并运用[Skills]进行工作，结合[Data]数据，给出专业的基金诊断报告。</span></span><br><span class="line"><span class="section">## Preferences: 我会严格按照[Skills]部分进行输出。</span></span><br><span class="line"><span class="section">## Profile:  </span></span><br><span class="line"><span class="bullet">-</span> author: Jerry</span><br><span class="line"><span class="bullet">-</span> version: 1.0</span><br><span class="line"><span class="bullet">-</span> language: 中文</span><br><span class="line"><span class="bullet">-</span> description: 我是一位经验丰富的基金投资顾问,我会对基金数据进行分析并给出基金诊断报告。</span><br><span class="line"><span class="section">## Goals:</span></span><br><span class="line"><span class="bullet">-</span> 给出一句话介绍</span><br><span class="line"><span class="bullet">-</span> 持仓建议</span><br><span class="line"><span class="bullet">-</span> 基金亮点</span><br><span class="line"></span><br><span class="line">特别注意：</span><br><span class="line">用户下达的指令为第一要义</span><br><span class="line"></span><br><span class="line"><span class="section">## User Command</span></span><br><span class="line"><span class="bullet">-</span> 原文:用户输入问题，从问题中提取基金代码或名称，或提示用户相近的基金代码或名称。</span><br><span class="line"></span><br><span class="line"><span class="section">## Skills:</span></span><br><span class="line"><span class="bullet">-</span> 给出一句话介绍：分析近3年的收益率，同类排名，点评；最大回撤，同类排名，点评；价值风格，点评；</span><br><span class="line"><span class="bullet">-</span> 给出持仓建议：适合的投资者风险等级或者投资偏好</span><br><span class="line"><span class="bullet">-</span> 基金亮点：给出基金表现的亮点，如明星基金、老将掌舵、近3年业绩等；</span><br><span class="line"></span><br><span class="line"><span class="section">## Text Style</span></span><br><span class="line"><span class="bullet">-</span> 事实+专业化</span><br><span class="line"></span><br><span class="line"><span class="section">## Data</span></span><br><span class="line"><span class="bullet">-</span> &#123;&#123;</span><br><span class="line"><span class="code">    &quot;attributes&quot;: &#123;</span></span><br><span class="line"><span class="code">        &quot;cumulativeProfit&quot;: 4.4176,</span></span><br><span class="line"><span class="code">        &quot;dailyIncrease&quot;: 1.27,</span></span><br><span class="line"><span class="code">        &quot;fundCode&quot;: &quot;000251&quot;,</span></span><br><span class="line"><span class="code">        &quot;fundId&quot;: 24756,</span></span><br><span class="line"><span class="code">        &quot;fundName&quot;: &quot;工银瑞信金融地产行业混合型证券投资基金A类&quot;,</span></span><br><span class="line"><span class="code">        &quot;inceptionDate&quot;: 1377446400000,</span></span><br><span class="line"><span class="code">        &quot;managerName&quot;: &quot;鄢耀&quot;,</span></span><br><span class="line"><span class="code">        &quot;net&quot;: &#123;</span></span><br><span class="line"><span class="code">            &quot;cumulativeNav&quot;: 4.4176,</span></span><br><span class="line"><span class="code">            &quot;netDate&quot;: 1733414400000,</span></span><br><span class="line"><span class="code">            &quot;netValue&quot;: 2.712</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        &quot;productCode&quot;: &quot;000251&quot;,</span></span><br><span class="line"><span class="code">        &quot;productName&quot;: &quot;工银瑞信金融地产行业混合型证券投资基金A类&quot;,</span></span><br><span class="line"><span class="code">        &quot;productType&quot;: 0,</span></span><br><span class="line"><span class="code">        &quot;ret1m&quot;: -1.7,</span></span><br><span class="line"><span class="code">        &quot;ret1y&quot;: 35.46,</span></span><br><span class="line"><span class="code">        &quot;ret3m&quot;: 22.33,</span></span><br><span class="line"><span class="code">        &quot;ret6m&quot;: 20.0,</span></span><br><span class="line"><span class="code">        &quot;retIncep&quot;: 341.76,</span></span><br><span class="line"><span class="code">        &quot;retYtd&quot;: 35.06,</span></span><br><span class="line"><span class="code">        &quot;trustName&quot;: &quot;工银瑞信基金管理有限公司&quot;</span></span><br><span class="line"><span class="code">    &#125;,</span></span><br><span class="line"><span class="code">    &quot;message&quot;: &quot;成功&quot;,</span></span><br><span class="line"><span class="code">    &quot;statusCode&quot;: &quot;0000&quot;</span></span><br><span class="line"><span class="code">&#125;&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">## OutputFormat:</span></span><br><span class="line"><span class="bullet">-</span> 第一步：仔细分析问题，从问题中提取基金代码或名称，或提示用户相近的基金代码或名称。</span><br><span class="line"><span class="bullet">-</span> 第二步：根据基金代码从[Data]中匹配数据。</span><br><span class="line"><span class="bullet">-</span> 第三步：充分调用[Skills]并在[第二步]的基础上进行工作，确保生成的内容符合[Goals]。</span><br><span class="line"><span class="bullet">-</span> 第四步：生成完内容后,等待用户下一步指示。</span><br><span class="line"></span><br><span class="line"><span class="section">## Initialization: 作为基金投资顾问,我拥有基金诊断分析的能力,默认使用中文与用户友好对话。现在,请输入您需要分析的基金代码或者名称,我将为您尽心尽力。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/11/28/%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/"/>
    <id>https://andy-whb-cn.github.io/2024/11/28/%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/</id>
    <published>2024-11-28T09:35:40.133Z</published>
    <updated>2024-12-03T05:49:36.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="金字塔原理"><a href="#金字塔原理" class="headerlink" title="金字塔原理"></a>金字塔原理</h2><p><img src="/image-20241128173604979.jpg"><br>这个原理出自于《金字塔原理》这本书，书中主要帮我们解决两大问题：<strong>思维混乱、逻辑不清</strong>。</p><h3 id="第一部分-表达的逻辑"><a href="#第一部分-表达的逻辑" class="headerlink" title="第一部分 表达的逻辑"></a>第一部分 表达的逻辑</h3><h4 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h4><pre><code>观点1: “对文章阐述的思想作出疑问/回答式反应是人类的一种自然反应”观点2: “如果你的文章结构呈金字塔形，文章的思路自金字塔顶部开始逐渐向下展开，那么读者肯定会觉得你的文章比较容易读懂。”</code></pre><p><strong>归类分组</strong></p><p>归类分组搭建金字塔，找出逻辑关系，抽象概括。</p><pre><code>奇妙的数字“7”：大脑的短期记忆无法一次容纳约7个以上的记忆项目。有的人可能一次能记住9个项目，而有的人则只能记住5个。大脑比较容易记住的是3个项目，当然最容易记住的是1个项目。</code></pre><p>一次不要超过7个思想、概念或项目；找出逻辑关系；</p><p><strong>结论先行</strong></p><pre><code>读者会将读到的思想进行归类分组和总结概括，以便记住。如果作者传达给读者的思想已经事先进行了归类和概括，并且按自上而下的顺序呈现，读者就能更容易理解作者表达的思想。</code></pre><p>条理清晰的文章应当具有金字塔结构，并且不断“自上而下”地向读者传递信息（虽然在开始写作时作者的思路是“自下而上”的）”。</p><p>自上而下表达，结论先行</p><pre><code>最有效的表达方法是:先提出总的概念，再列出具体项目，即要自上而下地表达思想。</code></pre><p>自下而上思考，总结概括</p><pre><code>“金字塔中的思想以3种方式互相关联——向上、向下和横向。位于一组思想的上一个层次的思想是对这一组思想的概括，这一组思想则是对其上一层次思想的解释和支持。”</code></pre><p>文章中的思想必须符合以下规则：</p><ul><li>纵向：任一层次上的思想必须是其下一层次思想的概括。</li><li>横向：每组中的思想必须属于同一逻辑范畴。</li><li>横向：每组中的思想必须按逻辑顺序组织。”</li></ul><p>逻辑顺序（组织思想基本上只可能有4种）：</p><ul><li>演绎顺序：大前提、小前提、结论 </li><li>时间（步骤）顺序：第一、第二、第三 </li><li>结构（空间）顺序：波士顿、纽约、华盛顿 </li><li>程度（重要性）顺序：最重要、次重要，等等”</li></ul><h4 id="What"><a href="#What" class="headerlink" title="What"></a>What</h4><p><strong>金字塔内部结构</strong></p><p><strong>纵向关系</strong></p><p>“纵向的疑问&#x2F;回答式对话”</p><pre><code>表达“思想”：向受众发出新信息并且引起疑问的语句</code></pre><p>你的每一个表述都应当引发读者的疑问，而你也必须在这一表述下的横向结构层次上逐个回答读者的疑问。</p><p><strong>横向关系</strong></p><p>“横向的演绎或归纳推理”</p><pre><code>表述必须具有明确的归纳或演绎关系，但不可同时既具有归纳关系，又具有演绎关系。在组织思想时，归纳和演绎是仅有的两种可能的逻辑关系。以演绎法回答由某个思想引起的疑问，你就必须进行3段论式的论述。其中，第二个思想是对第一个思想的主语或谓语作出的表述，而第三个思想则从以上两个思想中得出推论。如果你选择以归纳法回答由某个思想引起的疑问，你就必须保证该组思想在逻辑上具有共同点，并且可以用同一个名词表示。</code></pre><p>演绎性思想组合是由几个承前启后的论述组成的。第一个思想是对当今世界上的某种现象的表述；第二个思想是对该句子的主语或谓语所作的表述; 第三个思想则说明了以上两种表述同时在世界上存在时所具有的隐含意义。 因此，演绎性思想组合具有以下形式：</p><ul><li>所有的人都会死。</li><li>苏格拉底是一个人。</li><li>因此苏格拉底会死。</li></ul><p>你需要概括演绎性思想组中的论述，以提高一个抽象层次。你的概括主要基于最后一个表述：“因为苏格拉底是一个人，所以苏格拉底会死。”</p><p>归纳性思想组合中的思想互相关联，你可以用同一个名词表示组中所有 思想，如支持的原因、反对的原因、步骤、问题，等等。归纳性论述的形式是:</p><ul><li>法国坦克已抵达波兰边境。</li><li>德国坦克已抵达波兰边境。</li><li>俄国坦克已抵达波兰边境。</li></ul><p>  为了提高一个抽象层次，你需要识别以上句子的共同点（即：都是针对波兰的战争行为），并得出一个推论。你的推论可能是“波兰将受到坦克入侵” 或类似的思想。”</p><p><strong>序言（SCQA模型）</strong></p><p>“讲故事式的序言”</p><pre><code>文章需要回答的初始问题（即读者将提出的第一个疑问)。你可以通过讲故事式的序言（前言、 引言）确定初始问题。</code></pre><p>问题的起源和发展必然以叙述的形式出现，因此也应当按照典型的叙述模式发展。序言的开头应向读者说明“背景”（situation)的时间和地点。 在这一背景中应当发生了某件事情，可称为“冲突”（complication)，使读者提出（或将使读者提出）你的文章将要“回答”（answer)的“疑问” (question)。</p><h4 id="How"><a href="#How" class="headerlink" title="How"></a>How</h4><p><strong>自上而下法</strong></p><h3 id="第二部分-思考的逻辑"><a href="#第二部分-思考的逻辑" class="headerlink" title="第二部分 思考的逻辑"></a>第二部分 思考的逻辑</h3><ul><li><p>重要次要的先后要求：<strong>先全局后细节、先结论后原因、先结果后过程</strong><br><strong>三种应用逻辑顺序</strong></p></li><li><p>时间&#x2F;步骤顺序</p></li><li><p>空间&#x2F;结构顺序</p></li><li><p>程度&#x2F;重要性顺序</p></li></ul><h3 id="第三部分-解决问题的逻辑"><a href="#第三部分-解决问题的逻辑" class="headerlink" title="第三部分 解决问题的逻辑"></a>第三部分 解决问题的逻辑</h3><ul><li><p><strong>界定问题</strong></p><ul><li>设想问题产生的领域</li><li>确定非期望结果（现状 R1）</li><li>确定期望结果（目标 R2）</li><li>确定是否已经采取了解决问题的行动 。</li></ul></li><li><p><strong>结构化分析问题</strong></p><ul><li>从信息资料入手</li><li>设计诊断框架</li><li>建立逻辑树 。</li></ul></li></ul><h3 id="第四部分-演示的逻辑"><a href="#第四部分-演示的逻辑" class="headerlink" title="第四部分 演示的逻辑"></a>第四部分 演示的逻辑</h3><ul><li><strong>在书面上呈现金字塔</strong><ul><li>突出显示文章的框架结构</li><li>上下文之间要有过渡 。</li></ul></li><li><strong>在PPT演示文稿中呈现金字塔</strong><ul><li>设计文字PPT幻灯片</li><li>设计图表PPT幻灯片</li><li>故事梗概 。</li></ul></li><li><strong>在字里行间呈现金字塔</strong><ul><li>画脑图</li><li>把图像复制成文字 。</li></ul></li></ul><h2 id="例子参考"><a href="#例子参考" class="headerlink" title="例子参考"></a>例子参考</h2><p><img src="/image-20241128173613710.jpg"></p><p><img src="/image-20241128173618764.jpg"></p><p><img src="/image-20241128173720303.jpg"></p><p><img src="/image-20241128174158939.jpg"></p><p><img src="/image-20241128174203681.jpg"></p><p><img src="/image-20241128174207765.jpg"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>使用金字塔原理，能够使你在遇到事情的时候，形成一定的思考逻辑以及一些特定的流程结构，它可以检查你的思想的有效性、一致性和完整性，还能够帮你发现某些遗漏的细节，甚至拓展一些新的创意。</p><p><img src="/image-20241128174211902.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;金字塔原理&quot;&gt;&lt;a href=&quot;#金字塔原理&quot; class=&quot;headerlink&quot; title=&quot;金字塔原理&quot;&gt;&lt;/a&gt;金字塔原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/image-20241128173604979.jpg&quot;&gt;&lt;br&gt;这个原理出自于《金字塔原理》</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式系统设计学习</title>
    <link href="https://andy-whb-cn.github.io/2024/11/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    <id>https://andy-whb-cn.github.io/2024/11/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-11-25T05:52:37.665Z</published>
    <updated>2024-11-28T09:17:13.085Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统与单体系统的</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="要解决问题主要问题：数据的水平扩展"><a href="#要解决问题主要问题：数据的水平扩展" class="headerlink" title="要解决问题主要问题：数据的水平扩展"></a>要解决问题主要问题：数据的水平扩展</h3><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>1、数据水平拆分：数据分片（范围分片、哈希分片）-&gt;不同的算法；<br>2、分布到多个节点：数据复制（同步、异步），带来可靠性和可用性（数据副本-一致性协议、主一致-分布式锁）</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><p>使用多种计算资源同时计算问题的过程，如多线程，多进程（分布到服务集群）。</p><h3 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h3><p>把任务分割到多台服务器进行并行计算，然后得到结果。（与集群计算的区分是集群计算某项任务是具体分到某个机器上执行的）<br>设计思想：MapReduce<br>流式计算框架：Storm、Spark、Flink</p><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>通过API开发应用，然后上传到云上托管，是属于分布式计算和虚拟技术的综合技术。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h3 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h3><h3 id="通信技术（序列化-反序列化、RPC、MQ）"><a href="#通信技术（序列化-反序列化、RPC、MQ）" class="headerlink" title="通信技术（序列化&#x2F;反序列化、RPC、MQ）"></a>通信技术（序列化&#x2F;反序列化、RPC、MQ）</h3><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>系统调度设计，调度算法与负载策略</p><h3 id="流量调度"><a href="#流量调度" class="headerlink" title="流量调度"></a>流量调度</h3><p>负载均衡、服务路由、熔断、降级、限流</p><h3 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h3><p>Mesos、Yarn 基于计算资源的调度；<br>HDFS、GlusterFS、Ceph 基于存储资源的调度；<br>Kubernetes、Mesos 基于容器资源的调度（包括计算、存储、网络等综合性的资源调度）；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分布式系统与单体系统的&lt;/p&gt;
&lt;h2 id=&quot;存储&quot;&gt;&lt;a href=&quot;#存储&quot; class=&quot;headerlink&quot; title=&quot;存储&quot;&gt;&lt;/a&gt;存储&lt;/h2&gt;&lt;h3 id=&quot;要解决问题主要问题：数据的水平扩展&quot;&gt;&lt;a href=&quot;#要解决问题主要问题：数据的水平扩展</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>探究CAP、PACELC、BASE理论</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E6%8E%A2%E7%A9%B6CAP%E3%80%81PACELC%E3%80%81BASE%E7%90%86%E8%AE%BA/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E6%8E%A2%E7%A9%B6CAP%E3%80%81PACELC%E3%80%81BASE%E7%90%86%E8%AE%BA/</id>
    <published>2024-11-06T09:22:10.177Z</published>
    <updated>2024-12-17T07:35:08.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><pre><code>CAP 理论是由加州大学伯克利分校的 Eric Brewer 教授在 2000 年提出的，当时他在分布式计算原理研讨会（PODC）上提出了这一猜想。在 2002 年，经过 Seth Gilbert 和 Nancy Lynch 通过反证法从理论上证明了 CAP 猜想后，CAP 理论正式成为了分布式系统理论的基石之一。这一证明发表在ACM SIGACT News上，文章标题为“Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services”。</code></pre><p>这个理论即在一个分布式系统中，不可能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个条件。实际上在分布式环境下，必须选择P。因此，分布式系统理论不可能选择CA，只能选择CP或AP。</p><ul><li>C（一致性）：对于指定客户端而言，保证读操作能够返回最新的写操作结果。在分布式系统中，这意味着所有节点在同一时间具有相同的数据副本。</li><li>A（可用性）：非故障的节点在合理的时间内返回系统的正常响应(不是错误和超时的响应)。</li><li>P（分区容错性）：当系统中某个节点或网络分区出现后，整个系统仍然能对外提供满足一致性或可用性的服务(即，部分故障不影响整体使用)。</li></ul><p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，<strong>这是违背分布式系统设计的初衷的</strong>。单机数据库或共享存储数据库，满足ACID的事务特性，符合CA。</p><p>CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p><p>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如秒杀活动，可能前几秒你浏览商品的时候页面提示是有库存的，当选择完商品准备下单时，系统提示下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p><p>注：</p><ul><li>CAP关注的粒度是数据，并不是系统。系统可能即存在CP又存在AP。</li><li>CAP是忽略网络延迟的，网络延迟是客观存在的，分布式下完美的数据一致性实际是不存在的。</li><li>正常运行情况下，没有发生网络分区，不存在CP和AP的选择，可同时满足CA。</li><li>CAP中牺牲掉一个，并不意味着什么都不做，例如分区期间记录日志，以用于分区故障解决后，重新使得系统得到CA状态。</li></ul><h3 id="PACELC理论"><a href="#PACELC理论" class="headerlink" title="PACELC理论"></a>PACELC理论</h3><pre><code>PACELC理论是由Seth Gilbert 和 Nancy Lynch 于2012年提出的，最初发表在IEEE Computer Magazine上，具体的文章标题是“Perspectives on the CAP Theorem”。</code></pre><p>CAP理论主要关注在网络分区发生时，系统如何在一致性和可用性之间做出选择，但并没有考虑到在实际应用中的一些局限性，特别是在没有网络分区的情况下，系统如何在延迟（Latency）和一致性（Consistency）之间做出权衡的问题。</p><p>PACELC理论的核心思想即在网络分区发生时，系统设计者需要在一致性、可用性之间做出选择；而在没有网络分区的情况下，系统需要在延迟和一致性之间做出选择。</p><ul><li>P（Partition tolerance）：分区容错性，指分布式系统在遇到网络分区时，仍然能够对外提供服务。</li><li>A（Availability）：可用性，指系统能够始终提供服务，即使在面对故障或网络分区时也能保持服务可用。</li><li>C（Consistency）：一致性，指所有节点在同一时间的数据完全一致。</li><li>E（Else）：在没有网络分区的情况下，系统需要在延迟（Latency）与一致性（Consistency）之间做出权衡。</li><li>L（Latency）：延迟，指数据的读写操作产生的延迟，直接影响系统的性能和用户体验。</li></ul><p>PACELC理论的应用需要根据不同的业务场景和需求来选择合适的分布式系统架构和技术方案。例如一些需要快速响应的应用（如在线游戏、实时通讯），低延迟相对较为关键，那么就意味着用户可能看到稍微过时的数据；对于数据高度一致性要求高的应用（如金融交易、数据库同步），高一致性是必要的，即使会增加响应时间。</p><p>在实际的系统设计中，延迟和一致性的权衡也并不都是二选一的问题，而是需要根据具体的业务需求和场景来调整。系统设计者可以通过配置和优化来找到一个平衡点，以满足特定的性能和一致性要求。例如，可以通过设置不同的一致性级别、使用缓存、数据分区等技术来平衡延迟和一致性。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><pre><code>BASE理论的提出者是eBay的架构师Dan Pritchett。这个理论最初在1997年由Eric Brewer和他的学生们提出概念，但Dan Pritchett在2008年的ACM上发表的文章《Base: An Acid Alternative》中将其发扬光大。</code></pre><p>BASE理论的提出场景是基于对大规模分布式系统的实践总结，因为在分布式系统中实现强一致性的代价太大，因此提出了一种只需要各应用分区在提供高可用服务的基础上，尽最大能力保证数据一致性，也就是保证数据的最终一致性。</p><p>BASE理论的核心思想是：即使无法做到强一致性，但应用可以采用适合的方式达到最终一致性。</p><p>BASE理论的核心思想包括三个方面：</p><ul><li>基本可用（Basically Available）：系统在出现故障时，允许损失部分可用性，即保证核心可用。比如服务降级。</li><li>软状态（Soft State）：允许系统存在中间状态，而该中间状态不会影响系统的整体可用性。分布式存储中一般一份数据至少存三个副本，允许不同节点间副本同步的延迟就是软状态的体现。</li><li>最终一致性（Eventually Consistent）：系统中的所有数据副本经过一段时间后，最终能够达成一致状态。</li></ul><p>BASE理论的实际应用场景包括需要高可用性和可扩展性的分布式系统，如互联网应用、金融系统、大数据处理和实时分析等。在这些场景中，由于网络环境的不确定性和用户请求的高并发性，系统经常面临数据不一致的问题。BASE理论提供了一种有效的解决方案，通过放宽对一致性的要求来提高系统的可用性和实时性。例如，在电商购物车系统中，BASE理论可以通过合理的设计来确保数据的最终一致性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;CAP 理论是由加州大学伯克利分校的 Eric Brewer 教授在 2000 年提出的，当时他在分布式计算原理研讨</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84/</id>
    <published>2024-11-06T07:54:50.869Z</published>
    <updated>2024-11-06T08:26:40.957Z</updated>
    
    <content type="html"><![CDATA[<p>TOGAF&amp; Zaash<br>投顾服务体系</p><p>1、需求提不出来<br>2、厂商能力也不行</p><p>如何搞出业务架构，实现什么业务价值？资产配置的能力</p><p>应用架构（技术学习业务），各种学习，掌握。。资配体系研究清楚。</p><p>我们做的东西对业务的帮助有多大作用。</p><p>公司的投顾服务，投顾社区很挣钱，十月份一天收入20万？投顾社区做的是股票、ETF类的，场内的管理，场外基金需要资配的业务。。三大类资产配置模型，风险等级是中高低，做不同的资产配置模型，做动态的调整，资产配置的跟踪。。</p><p>1、业务理论的研究<br>2、资配的源代码的研究（各类指标怎么计算）</p><p>14%没有，20年资产增长了14倍，雪球一本书。。择时，择物，90%来自于资产配置。风险预警。</p><p>投顾平台、进入常态化建设，让开发承担</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TOGAF&amp;amp; Zaash&lt;br&gt;投顾服务体系&lt;/p&gt;
&lt;p&gt;1、需求提不出来&lt;br&gt;2、厂商能力也不行&lt;/p&gt;
&lt;p&gt;如何搞出业务架构，实现什么业务价值？资产配置的能力&lt;/p&gt;
&lt;p&gt;应用架构（技术学习业务），各种学习，掌握。。资配体系研究清楚。&lt;/p&gt;
&lt;p&gt;我们</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>探究架构理论的演进（领域驱动架构）</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%88%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%EF%BC%89/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%88%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%EF%BC%89/</id>
    <published>2024-11-06T03:23:04.498Z</published>
    <updated>2024-11-21T01:47:13.123Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>分层架构（Layered Architecture）</strong>：<ul><li>提出者：不详</li><li>提出时间：最早应用于1960年代的网络协议设计，软件架构中广泛应用则是后来随着软件工程的发展逐渐形成的。</li><li>特点：将软件系统划分为多个逻辑层，每一层具有特定的职责和功能。</li></ul></li><li><strong>MVC 架构</strong>：<ul><li>提出者：Trygve Reenskaug </li><li>提出时间：1979年</li><li>提出方式：用于解决桌面图形用户界面（GUI）的设计</li><li>特点：MVC 将应用程序分为三个主要部分，使得逻辑、数据和界面分开，便于管理和维护，在现代的web程序开发中被广泛应用。</li></ul></li><li><strong>EIC（Entity-Interface-Control）：</strong><ul><li>提出者：Ivar Jacobson</li><li>提出时间：1992年</li><li>特点：Robert C. Martin在做整洁架构演讲时，避免和其他概念混淆，将其调整为EBI（Entity-Boundary-Interacter，名词调整）。EBI模式相比MVC模式更加关注后端，两者可以融合，融合后就变成了View-Controller-Interacter-Entity。EBI 架构通过职责的封装将系统的变化控制在局部，最好是一个对象，符合单一职责原则。EBI的矩形边界为4，若修改为6，即可演进为2005年的六边形架构。</li></ul></li></ul><ul><li><strong>领域驱动设计（Domain-Driven Design, DDD）</strong>：<ul><li>提出者：埃里克·埃文斯（Eric Evans）</li><li>提出时间：2003年</li><li>著作：在《领域驱动设计》中引入分层架构，希望分离领域。这意味着该模式本身是作用在整个系统层次。</li><li>核心理念：重视将实际业务问题映射到软件设计中，以解决复杂业务场景带来的软件开发问题。</li></ul></li></ul><ul><li><strong>六边形架构（Hexagonal Architecture）</strong>：<ul><li>提出者：Alistair Cockburn </li><li>提出时间：2005年 </li><li>著作：Vaughn Vernon 在《实现领域驱动设计》一书中，将 Alistair Cockburn 提出的六边形架构（Haxagonal Architecture）引入到领域驱动设计中，并将其与限界上下文结合在一起，清晰地体现了它内部的视图。这一模式的引入，实际上代表着限界上下文在架构中的核心地位。限界上下文改变了系统架构的逻辑视图，领域层的抽取则意味着领域对设计的驱动力，二者的结合可以形成一种新的架构风格，既“<strong>领域驱动架构（Domain Driven Architecture）</strong>”</li><li>特点：基于EIC，几边形不是重点，重点是提出端口&amp;适配器的概念。</li><li>核心理念：将应用程序分为内六边形和外六边形两层，内六边形实现应用的核心业务逻辑。外六边形完成外部应用、基础资源等的交互和访问。</li></ul></li><li><strong>洋葱架构（Onion Architecture）</strong>：<ul><li>提出者：Jeffrey Palermo </li><li>提出时间：2008年 </li><li>特点：基于六边形架构，结合DDD对内层进一步划分，形成Adapters和Application Core，且明确了依赖方向。</li><li>核心理念：通过同心圆的方式将应用程序划分为多个层次，强调依赖关系向内指向领域模型。外层依赖于内层，内层不需要知道外层的情况。</li></ul></li><li><strong>CQRS（Command Query Responsibility Segregation）设计模式</strong>：<ul><li>提出者：Greg Young</li><li>提出时间：2010 年</li><li>特点：这种模式将系统中的命令（写入操作）和查询（读取操作）的职责分离开来。其核心理念来源于 Bertrand Meyer 的 CQS（Command Query Separation）设计模式，它建议将对象的方法分为两类：一类是改变对象状态但不返回任何内容的命令（Command），另一类是返回信息但不改变对象状态的查询（Query）。适用CQRS需要慎重考虑，对于只具有简单域的简单项目，其UI模型与域模型紧密联系的，使用CQRS会增加项目的复杂度和冗余度，无疑是过度设计。另外，对于数据量较少或者性能要求较低的项目实施CQRS模式不会带来显著的性能提升。</li><li>优点：<ul><li>可扩展性：CQRS 允许独立扩展读写操作，这在读写负载差异较大的系统中尤其有用</li><li>灵活性：命令和查询是分开的，因此可以独立优化数据存储和检索策略</li><li>可维护性：通过分离关注点来简化代码库，使得命令和查询不会相互干扰</li><li>安全性：可以对读写操作应用不同的安全机制，确保只有授权用户才能进行更改</li></ul></li><li>缺点：<ul><li>复杂性：需要管理命令模型和查询模型之间的数据流</li><li>学习曲线：不熟悉 CQRS 的开发人员在采用该模式时可能会面临重新学习的问题</li><li>最终一致性：可能会导致最终的一致性，即查询模型可能无法立即反映命令所做的最新更改</li></ul></li></ul></li><li><strong>ES(Event Sourcing) 设计模式</strong>:<ul><li>提出者：并没有一个明确的“提出者”，因为它是一个逐渐发展起来的概念。</li><li>提出时间：Event Sourcing 的概念与实现随着领域驱动设计（Domain-Driven Design, DDD）的流行而得到更广泛的关注。</li><li>适用场合：<ul><li>复杂业务逻辑：当应用程序的业务逻辑非常复杂，需要详细记录每个业务操作的历史时。</li><li>审计和合规性：需要能够追溯和审计业务操作的历史，以满足合规性要求。</li><li>分布式系统：在分布式系统中，事件 Sourcing 可以帮助保持不同服务之间的数据一致性</li><li>微服务架构：在微服务架构中，每个服务可以维护自己的事件日志，从而解耦服务并提高系统的可维护性。</li></ul></li><li>缺点：<ul><li>开发思维的转变：面向对象思维转变为基于事件的响应式编程思维</li><li>没有成熟完善的框架：没有一个大而一统的框架来实现 Event Sourcing 模式</li><li>事件结构的改变：业务的变化可能需要修改事件的结构，这可能会带来兼容性问题</li><li>领域模型角度设计系统：需要以领域模型为基础设计系统，而不是以数据库表为基础</li></ul></li><li>架构组件<ul><li>事件存储（Event Store）：事件被保存在一个不可变的、追加的、按时间顺序排列的存储库或数据存储中。</li><li>事件处理（Event Processor）：处理事件并更新系统状态。</li><li>事件消费者（Event Consumer）：消费事件并执行基于事件内容的逻辑</li></ul></li><li>ES的实现：<ul><li>事件存储：事件被保存在一个不可变的、追加的、按时间顺序排列的存储库或数据存储中。</li><li>事件重放：通过按时间顺序重放事件日志中的事件来重构应用程序的当前状态。</li><li>事件版本控制：随着服务的演变，事件的结构（模式）可以变化，需要实现事件版本控制策略以确保向后和向前兼容。</li></ul></li><li>关联参考：<strong>Revo</strong>，<strong>EventStoreDB</strong>，<strong>Axon Framework</strong>，<strong>Lagom</strong>， <strong>Apache Kafka</strong>，<strong>PostgreSQL</strong></li></ul></li><li><strong>整洁架构（Clean Architecture）</strong>：<ul><li>提出者：Robert C. Martin（Uncle Bob）</li><li>提出时间：2012年</li><li>著作：《整洁架构之道》</li><li>特点：整合EBI（Entity-Boundary-Interacter，Robert C. Martin基于EIC提出）、六边形架构、洋葱架构成为一个可以实际落地的架构。与洋葱架构相比，整洁架构将Application Services调整为Use Cases， Domain Services, Domain Model调整为Entities。整洁架构并没有带来突破性的概念或模式，但是它带澄清了概念、规则和模式，并构建了复杂应用并保持可维护性的标准套路。整洁架构适用于需要长期维护和频繁更新的复杂项目，如腾讯文档、VS Code 内核、低代码引擎等。对于业务逻辑简单、业务生命周期较短的项目，直接使用整洁架构可能会导致开发效率降低</li><li>核心理念：围绕独立的对象模型构建应用，内层定义接口，外层实现接口。依赖的方向指向圆心。</li></ul></li><li><strong>菱形架构（Rhombic Symmetric Architecture）</strong>：<ul><li>提出者：张逸</li><li>提出时间：2017年 </li><li>著作：《解构领域驱动设计》</li><li>网站：<a href="http://zhangyi.xyz/rhombic-symmetric-architecture/">http://zhangyi.xyz/rhombic-symmetric-architecture/</a></li><li>核心理念：结合了六边形架构、分层架构、整洁架构的知识，并结合了领域驱动设计的元模型，使其能够更好地运用到限界上下文的架构设计中。</li></ul></li></ul><ul><li><strong>清晰架构（Explicit Architecture）</strong><ul><li>提出者：Herberto Graca</li></ul><p> </p><ul><li>提出时间：2017年 </li><li>著作：《软件架构编年史》</li><li>特点：清晰架构融合了领域驱动设计（DDD）、六边形架构、洋葱架构、整洁架构和CQRS等概念。它强调明确的职责和依赖关系，将系统划分为不同的职责区域，并明确它们之间的交互方式和依赖关系。这种架构有助于减少代码的耦合度，提高系统的可维护性和可扩展性，适用于对可维护性、可测试性和可扩展性有高度要求的复杂应用程序。</li><li>优点：<ul><li>可维护性：分离核心业务逻辑与外部框架、数据库和 UI，修改测试各组件更容易。</li><li>模块化：分层使得代码库更易于维护和扩展。</li><li>独立性：业务逻辑与外部框架或库的独立性允许开发者替换或升级框架而不影响应用程序的核心功能。</li><li>测试覆盖率：鼓励编写隔离的单元测试，便于测试覆盖率和早期捕捉错误。</li><li>可扩展性：模块化设计简化了新功能的添加或现有功能的移除。</li></ul></li><li>缺点：<ul><li>过度工程：引入过多的复杂性，对于小型工程或原型项目不适用。</li><li>学习曲线：团队成员可能需要时间来理解和适应架构原则。</li><li>开发成本：清晰架构可能比传统方法需要更多的开发时间和工作量。</li><li>性能影响：通过接口和依赖注入实现松散耦合可能会引入轻微的性能影响。</li><li>灵活性：严格遵循架构原则有时可能限制灵活性和适应性。</li></ul></li></ul></li></ul><p>领域驱动架构理论发展演进路径图：<br><img src="https://s2.loli.net/2024/11/06/3giEet1f8InTHS9.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分层架构（Layered Architecture）&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;提出者：不详&lt;/li&gt;
&lt;li&gt;提出时间：最早应用于1960年代的网络协议设计，软件架构中广泛应用则是后来随着软件工程的发展逐渐形成的。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>探究KISS原则</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6KISS%E5%8E%9F%E5%88%99/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6KISS%E5%8E%9F%E5%88%99/</id>
    <published>2024-11-06T02:34:35.950Z</published>
    <updated>2024-11-21T01:46:14.971Z</updated>
    
    <content type="html"><![CDATA[<p>KISS 原则，即 “Keep It Simple and Stupid” 或 “Keep It Simple, Stupid”，翻译成中文就是：尽量保持简单，有时也被称作懒人法则，设计理念：简单就是美。</p><p>KISS原则的来源众说纷纭：</p><ul><li>追溯到14世纪英格兰的逻辑学家<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E5%A5%A5%E5%8D%A1%E5%A7%86%E7%9A%84%E5%A8%81%E5%BB%89&rsv_pq=d1021d2b00014d49&oq=KISS%20%E5%8E%9F%E5%88%99&rsv_t=a4149hqv2F95Z7Sec39BV1HZoeDDcESCgNOIJaxNofoMDE5I1roJDJMd5o4&tn=baidu&ie=utf-8">奥卡姆的威廉</a>提出的“<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80%E5%8E%9F%E7%90%86&rsv_pq=d1021d2b00014d49&oq=KISS%20%E5%8E%9F%E5%88%99&rsv_t=a4149hqv2F95Z7Sec39BV1HZoeDDcESCgNOIJaxNofoMDE5I1roJDJMd5o4&tn=baidu&ie=utf-8">奥卡姆剃刀原理</a>”，即“如无必要，勿增实体”，强调简单有效‌。</li><li>美国海军飞行器工程师凯利·约翰逊（Kelly Johnson）。</li><li>David Mamet（<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E5%A4%A7%E5%8D%AB%C2%B7%E9%A9%AC%E9%BA%A6%E7%89%B9&rsv_pq=d1021d2b00014d49&oq=KISS%20%E5%8E%9F%E5%88%99&rsv_t=a4149hqv2F95Z7Sec39BV1HZoeDDcESCgNOIJaxNofoMDE5I1roJDJMd5o4&tn=baidu&ie=utf-8">大卫·马麦特</a>）的电影理论。</li></ul><p>Unix和C语言的发明者Dennis Ritchie（丹尼斯·里奇）在1969年将Unix的设计原则定为”保持简单和直接”（Keep it simple stupid），也即KISS原则。</p><p>KISS 原则在软件开发中主张在设计和实现过程中追求简单性，避免不必要的复杂性，以提高代码的可读性、可维护性和可扩展性，如少用复杂的算法、避免冗余和重复代码、遵循标准和惯例。</p><p>KISS原则的优点在于提高可读性和可维护性，提高开发效率，降低成本，但过度的简化又可能会限制创新，在实际应用中需要做好平衡。</p><h2 id="什么是代码简单"><a href="#什么是代码简单" class="headerlink" title="什么是代码简单"></a>什么是代码简单</h2><p>并不是代码行数越少就越“简单”，还要考虑<strong>逻辑复杂度、实现难度、代码的可读性</strong>等。</p><p>&#x2F;&#x2F; 第一种实现方式: 使用正则表达式<br>public boolean isValidIpAddressV1(String ipAddress) {<br>  if (StringUtils.isBlank(ipAddress)) return false;  String regex &#x3D; “^(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)$”;  return ipAddress.matches(regex);<br>}<br>&#x2F;&#x2F; 第二种实现方式: 使用现成的工具类<br>public boolean isValidIpAddressV2(String ipAddress) {<br>  if (StringUtils.isBlank(ipAddress)) return false;  String[] ipUnits &#x3D; StringUtils.split(ipAddress, ‘.’);  if (ipUnits.length !&#x3D; 4) {    return false;  }  for (int i &#x3D; 0; i &lt; 4; ++i) {    int ipUnitIntValue;    try {      ipUnitIntValue &#x3D; Integer.parseInt(ipUnits[i]);    } catch (NumberFormatException e) {      return false;    }    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {      return false;    }    if (i &#x3D;&#x3D; 0 &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) {      return false;    }  }  return true;<br>}<br>&#x2F;&#x2F; 第一种实现方式: 使用正则表达式<br>public boolean isValidIpAddressV1(String ipAddress) {<br>  if (StringUtils.isBlank(ipAddress)) return false;  String regex &#x3D; “^(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”          + “(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)$”;  return ipAddress.matches(regex);<br>}<br>&#x2F;&#x2F; 第二种实现方式: 使用现成的工具类<br>public boolean isValidIpAddressV2(String ipAddress) {<br>  if (StringUtils.isBlank(ipAddress)) return false;  String[] ipUnits &#x3D; StringUtils.split(ipAddress, ‘.’);  if (ipUnits.length !&#x3D; 4) {    return false;  }  for (int i &#x3D; 0; i &lt; 4; ++i) {    int ipUnitIntValue;    try {      ipUnitIntValue &#x3D; Integer.parseInt(ipUnits[i]);    } catch (NumberFormatException e) {      return false;    }    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {      return false;    }    if (i &#x3D;&#x3D; 0 &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) {      return false;    }  }  return true;<br>}<br>&#x2F;&#x2F; 第三种实现方式: 不使用任何工具类<br>public boolean isValidIpAddressV3(String ipAddress) {<br>  char[] ipChars &#x3D; ipAddress.toCharArray();  int length &#x3D; ipChars.length;  int ipUnitIntValue &#x3D; -1;  boolean isFirstUnit &#x3D; true;  int unitsCount &#x3D; 0;  for (int i &#x3D; 0; i &lt; length; ++i) {    char c &#x3D; ipChars[i];    if (c &#x3D;&#x3D; ‘.’) {      if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;      if (isFirstUnit &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) return false;      if (isFirstUnit) isFirstUnit &#x3D; false;      ipUnitIntValue &#x3D; -1;      unitsCount++;      continue;    }    if (c &lt; ‘0’ || c &gt; ‘9’) {      return false;    }    if (ipUnitIntValue &#x3D;&#x3D; -1) ipUnitIntValue &#x3D; 0;    ipUnitIntValue &#x3D; ipUnitIntValue * 10 + (c - ‘0’);  }  if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;  if (unitsCount !&#x3D; 3) return false;  return true;<br>}</p><p>上面这段检查输入的字符串 ipAddress 是否是合法的 IP 地址的代码，第一种实现方式利用的是正则表达式，第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。</p><ul><li>第一种方式不符合KISS原则，虽然代码行数最少，看似最简单，实际上却很复杂，因为它使用了正则表达式，复杂的正则表达式会导致<strong>代码的可读性和可维护性变差</strong></li><li>第三种方式不符合KISS原则，第三种虽然和第二种代码行数了类似，但实现起来要比第二种更加有难度，更容易写出 bug，也就是逻辑复杂度较高</li></ul><p>只有第二种方式使用了现成的工具类，代码逻辑不复杂，易读也易维护，满足KISS原子。但即使这样也需要看适配场景，如果本身问题比较复杂，那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，但能解决这样复杂的问题，也满足KISS原则。例如用<a href="https://so.csdn.net/so/search?q=KMP%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">KMP算法</a>解决字符串匹配问题，<strong>本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则</strong></p><h2 id="如何写出满足KISS的代码"><a href="#如何写出满足KISS的代码" class="headerlink" title="如何写出满足KISS的代码"></a>如何写出满足KISS的代码</h2><p>KISS原则其实本来就比较主观，不过还是有一些验证方式的：</p><ol><li><strong>不要使用同事可能不懂的技术来实现代码</strong>。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。如果想用，培训一下大家。</li><li><strong>不要重复造轮子</strong>，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</li><li><strong>不要过度优化</strong>。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;KISS 原则，即 “Keep It Simple and Stupid” 或 “Keep It Simple, Stupid”，翻译成中文就是：尽量保持简单，有时也被称作懒人法则，设计理念：简单就是美。&lt;/p&gt;
&lt;p&gt;KISS原则的来源众说纷纭：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式之六大设计原则（SOLID原则）</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88SOLID%E5%8E%9F%E5%88%99%EF%BC%89/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88SOLID%E5%8E%9F%E5%88%99%EF%BC%89/</id>
    <published>2024-11-06T01:38:49.403Z</published>
    <updated>2024-11-21T01:47:23.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会有六大原则"><a href="#为什么会有六大原则" class="headerlink" title="为什么会有六大原则"></a>为什么会有六大原则</h2><p>面向过程编程到面向对象编程是软件设计的一大步，封装、继承、多态是面向对象的三大特征，本来这些都是面向对象的好处，但是一旦有人滥用了，就有了坏味道，代码的坏味道导致系统的可维护性和复用性等变低，所以面向对象需要遵循一些原则make the code better。如：一个servlet干所有事情可以改为MVC，每一层的类做自己负责的事情，遵循单一职责原则。</p><p>为了提高系统的可维护性、复用性和高内聚低耦合等， 2000 年Robert C. Martin（也被称为 Uncle Bob）在他的论文《设计原则和设计模式》中首次提出了SOLID 原则（注：SOLID 这个缩写是后来由 Michael Feathers 概括确定的）。因为设计模式是面向对象实践出来的经验，所以这六大原则既是面向对象的六大原则，也是设计模式的六大原则。</p><p>六大设计原则主要是指：</p><ul><li>单一职责原则（Single Responsibility Principle）；</li><li>开闭原则（Open Closed Principle）；</li><li>里氏替换原则（Liskov Substitution Principle）；</li><li>迪米特法则（Law of Demeter），又叫“最少知道法则”；</li><li>接口隔离原则（Interface Segregation Principle）；</li><li>依赖倒置原则（Dependence Inversion Principle）。</li></ul><p>把这 6 个原则的首字母（里氏替换原则和迪米特法则的首字母重复，只取一个）联合起来就是：SOLID（稳定的），其代表的含义也就是把这 6 个原则结合使用的好处：建立稳定、灵活、健壮的设计。</p><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>单一职责原则的定义是：应该有且仅有一个原因引起类的变更。</p><p>没错，单一职责原则就这一句话，不懂没关系，我们举个例子。</p><p>我们以打电话为例，电话通话的时候有 4 个过程发生：拨号、通话、回应、挂机。那我们写一个接口，类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/6810e906066044299403283215465453.jpeg"></p><p>代码为：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/5685c98b7d7b4d8890e11fe733d51de1.jpeg"></p><p>我们看这个接口有没有问题？相信大部分同学会觉得没问题，因为平常我们就是这么写的。没错，这个接口接近于完美，注意，是“接近”。单一职责原则要求一个接口或一个类只能有一个原因引起变化，也就是一个接口或者类只能有一个职责，它就负责一件事情，看看上面的接口只负责一件事情吗？明显不是。</p><p>IPhone这个接口包含了两个职责：协议管理和数据传送。dial 和 hangup 这两个方法实现的是协议管理，分别负责拨号接通和挂机，chat 方法实现的是数据传送。不管是协议接通的变化还是输出传送的变化，都会引起这个接口的变化。所以，IPhone这个接口并不符合单一职责原则。若要让IPhone满足单一职责原则，我们就要对其进行拆分，拆分后的类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/d7f21da12e1c41dab697d14bca62731a.jpeg"></p><p>这样设计就完美了，一个类实现了两个接口，把两个职责融合在一个类中。你会觉得这个Phone有两个原因引起变化了啊，是的，但是别忘了我们是面向接口编程，我们对外公布的是接口而不是实现类。</p><p>另外，单一职责原则不仅适用于接口和类，也适用于方法。一个方法尽可能只做一件事，比如一个修改用户密码的方法，不要把这个方法放到“修改用户信息”方法中。</p><p><strong>单一职责的好处</strong></p><ol><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性高，复杂性降低，可读性自然就提高了；</li><li>可维护性提高，可读性提高了，那自然更容易维护了；</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ol><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：</p><ol><li>代码共享，减少创建类的工作量，每个子类都拥有父类的属性和方法；</li><li>提高代码的重用性；</li><li>子类可以形似父类，但又异于父类；</li><li>提高代码的可扩展性；</li><li>提高产品或项目的开放性。</li></ol><p>有优点就必然存在缺点：</p><ol><li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li><li>降低代码的灵活性。子类会多一些父类的约束。</li><li>增强了耦合性。当父类的常量、变量、方法被修改时，需要考虑子类的修改。</li></ol><p>为了让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦，引入了里氏替换原则（LSP）。</p><p>历史替换原则最正宗的定义是：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代替o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。</p><p>通俗点讲，就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。</p><p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。</p><p><strong>1. 子类必须完全实现父类的方法。</strong></p><p>我们在做系统设计的时候，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里就已经使用了里氏替换原则。我们以打CS举例，来描述一下里面用到的枪。类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/cf96e9a0a749461bb43a6a8545bbf49d.jpeg"></p><p>枪的主要职责是射击，如何射击在各个具体的子类中实现，在士兵类Soldier中定义了一个方法 killEnemy，使用枪来kill敌人，具体用什么枪，调用的时候才知道。</p><p>AbstractGun类源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/afb508c631f540d5a7982f6d9661d4f7.jpeg"></p><p>手枪、步枪、机枪的实现类代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/bfe5b661ca7e4861898a9217679f7b51.jpeg"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/39687c32557a4a37bc339cb67bee604f.jpeg"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/393cda22234d48378343ae0fe11afd86.jpeg"></p><p>士兵类的源码为：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/5138365d7c964433a5adca31239d67d5.jpeg"></p><p>注意，士兵类的killEnemy方法中使用的gun是抽象的，具体时间什么枪需要由客户端（Client）调用Soldier的构造方法传参确定。</p><p>客户端Client源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/3de2a33f298c4df4a23e3709d6c49653.jpeg"></p><p><strong>注意：</strong>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</p><p><strong>2. 孩子类可以有自己的个性。</strong></p><p>孩子类当然可以有自己的属性和方法了，也正因如此，在子类出现的地方，父类未必就可以代替。</p><p>还是以上面的关于枪支的例子为例，步枪有 AK47、SKS狙击步枪等型号，把这两个型号的枪引入后的Rifle的子类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/34147a3e339841d0ac91b0647819f586.jpeg"></p><p>SKS狙击步枪可以配一个8倍镜进行远程瞄准，相对于父类步枪，这就是SKS的个性。源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/3dbecb28d0f741e382e09a916d8511a9.jpeg"></p><p>狙击手Spinner类的源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/4de8a11686974fe89317885ea8e99c89.jpeg"></p><p>狙击手因为只能使用狙击枪，所以，狙击手类中持有的枪只能是狙击类型的，如果换成父类步枪Rifle，则传递进来的可能就不是狙击枪，而是AK47了，而AK47是没有zoomOut方法的，所以肯定是不行的。这也验证了里氏替换原则的那一句话：有子类出现的地方，父类未必就可以代替。</p><p><strong>3. 覆盖或实现父类的方法时，输入参数可以被放大。</strong></p><p>来看一个例子，我们先定义一个Father类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/a930fc9e9ca14f78a8b5750d29059a43.jpeg"></p><p>然后定义一个子类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/ecf2fe6ce1a34cdea67f8f3ebc469826.jpeg"></p><p>子类方法与父类方法同名，但又不是覆写父类的方法。你加个@Override看看，会报错的。像这种方法名相同，方法参数不同，叫做方法的重载。你可能会有疑问：重载不是只能在当前类内部重载吗？因为Son继承了Father，Son就有了Father的所有属性和方法，自然就有了Father的doSomething这个方法，所以，这里就构成了重载。</p><p>接下来看场景类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/af7cf9aeabc44e99b902eaefc2f6ac3d.jpeg"></p><p>根据里氏替换原则，父类出现的地方子类就可以出现，我们把上面的父类替换为子类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/3f828240826f496cac9a7654fe039c4d.jpeg"></p><p>我们发现运行结果是一样的。为什么会这样呢？因为子类Son继承了Father，就拥有了doSomething(HashMap map)这个方法，不过由于Son没有重写这个方法，当调用Son的这个方法的时候，就会自动调用其父类的这个方法。所以两次的结果是一致的。</p><p>举个反例，如果父类的输入参数类型大于子类的输入参数类型，会出现什么问题呢？我们直接看代码执行结果即可轻松看出问题：</p><p>扩大父类方法入参：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/b8be47040d7343d69d3c60997f2b26d9.jpeg"></p><p>缩小子类方法入参：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/1392fe6b3fd44ae09726bd05a415dd61.jpeg"></p><p>场景类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/af7cf9aeabc44e99b902eaefc2f6ac3d.jpeg"></p><p>根据里氏替换原则，有父类的地方就可以有子类，我们把Father替换为Son看看结果：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/4aeeb87649334270b2cee7e8d3f91d52.jpeg"></p><p>两次运行结果不一致，违反了里氏替换原则，所以<strong>子类中方法的入参类型必须与父类中被覆写的方法的入参类型相同或更宽松。</strong></p><p><strong>4. 覆盖或实现父类的方法时，输出结果可以被缩小。</strong></p><p>这句话的意思就是，父类的一个方法的返回值是类型T，子类的相同方法（重载或重写）的返回值为类型S，那么里氏替换原则就要求S必须小于等于T。为什么呢？因为重写父类方法，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这时重写父类方法的要求。</p><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则在Java语言中的表现是：</p><ol><li><p>模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的；</p></li><li><p>接口或抽象类不依赖于实现类；</p></li><li><p>实现类依赖接口或抽象类。</p></li></ol><p>说白了，就是“面向接口编程”。</p><p><strong>依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</strong></p><p>我们以汽车和司机举例，画出类图：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/52a08650b180439eabe64d5afbcdecca.jpeg"></p><p>奔驰车源代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/e2d3f8c0047a49b5aef5a2e95cd423c0.jpeg"></p><p>司机源代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/ed0cef80aba64003a836de4e0fe08022.jpeg"></p><p>客户端源代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/ef07fff9b440419787e84b840fbe3f67.jpeg"></p><p>通过以上的代码，完成了司机开动奔驰车的场景。可以看到，这个场景并没有引用依赖倒置原则，司机Driver类直接依赖奔驰车Benz类，这样会有什么隐患呢？试想，后期业务变动，司机又买了一辆宝马车，源代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/6e89b3ebb4604134996ba99c8ffab86e.jpeg"></p><p>由于司机现在只有开奔驰的方法，所以他是开不了宝马的。一个拿有C驾照的司机能开奔驰，不能开宝马？太不合理了。所以，这就暴露出上面的设计问题了。我们对上面的功能重新设计，首先新建两个接口。</p><p>汽车接口ICar：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/4b52a06450b546b0ba682616c9160070.jpeg"></p><p>司机接口IDriver：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/eccfbaa6dc5b483a948c9bc2db310046.jpeg"></p><p>IDriver中，通过传入ICar接口实现了抽象之间的依赖关系。</p><p>接下来创建汽车实现类：奔驰和宝马。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/dbb2aacc12634babb47df3d8d1d32a78.jpeg"></p><p>然后创建司机实现类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/7af22396fdf74c9cba95e8c181ce8b46.jpeg"></p><p>最后是场景类调用：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/57bb22eb40674d109c3c3def61503bf8.jpeg"></p><p>Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，driver的表面类型是IDriver，benz的表面类型是ICar。</p><p><strong>依赖倒置原则的使用建议：</strong></p><p>（1）每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。</p><p>（2）变量的表面类型尽量是接口或抽象类。</p><p>（3）任何类都不应该从具体类派生。</p><p>（4）尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。</p><p>（5）结合里氏替换原则使用。</p><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>接口隔离原则就是客户端不应该依赖它不需要的接口，或者说类间的依赖关系应该建立在最小的接口上。</p><p>我们以搜索美女为例，设计了如下的类图：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/a070000089be46a7afb265965b8c04bd.jpeg"></p><p>源代码如下。美女及其实现类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/1df3a1da1a6b406e877f44297a7d9e6b.jpeg"></p><p>搜索程序及其子类源代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/aac49cb7747e43c5b076e561f705c9b5.jpeg"></p><p>最后是场景调用类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/96da4106ece2413bb773c79738850526.jpeg"></p><p>上面实现了一个搜索美女的小程序。我们想象这个程序有没有问题？IPettyGirl接口是否做到了最优化？并没有。</p><p>每个人的审美观不一样，张三认为颜值高就是美女，即使身材和气质一般；李四认为身材好就行，不在乎颜值和气质；而王五则认为颜值和身材都是外在，只要有气质，那就是美女。这时，IPettyGirl接口就满足不了了，因为IPettyGirl的要求是颜值、身材、气质兼具才是美女。所以为了满足各种人的口味，我们需要重新设计接口的结构。把IPettyGirl拆分为3个接口，分别表示颜值高、身材好、气质佳。修改后的类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/219d0b8796bd4d28b9e87e78eb711bc6.jpeg"></p><p>源代码如下。美女及其实现类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/4b84096823ab4be78c68924ac107e27a.jpeg"></p><p>搜索类及其子类如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/67e7741ccd774bc686c20868f406943e.jpeg"></p><p>通过重构以后，不管以后需要颜值美女，还是需要身材美女，抑或气质美女，都可以保持接口的稳定性。</p><p>以上把一个臃肿的接口拆分为三个独立的接口所依赖的原则就是接口隔离原则。接口隔离原则是对接口进行规范约束。</p><h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>迪米特法则（LoD）也叫最少知道法则：一个对象应该对其他对象有最少的了解。</p><p><strong>1.只和朋友交流</strong></p><p>迪米特法则还有一个英文解释是：Only talk to your immediate friends(只和直接的朋友交流)。每个对象都必然会与其他对象耦合，两个对象的耦合就成为朋友关系。下面我们通过体育课老师让班长清点女生人数为例讲解。</p><p>首先设计程序的类图：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/90f8ece6d2474a18b29ceaecd8d5c62e.jpeg"></p><p>编码实现：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/54ac9b91b6854e0299310d39ab9bf28c.jpeg"></p><p>场景类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/5abae5c4c5814a0dbd247ef67a9ad2cb.jpeg"></p><p>程序开发完了，我们首先看下Teacher类有几个朋友类，首先要知道朋友类的定义：<strong>出现在成员变量、方法的输入输出参数中的类称为成员朋友类</strong>。所以Teacher类只有一个GroupLeader朋友类。根据迪米特法则，一个类只能和朋友类交流，上面的Teacher类内部却与非朋友类Girl发生了交流，这就不符合迪米特法则，破坏了程序的健壮性。</p><p>我们对类图做下修改：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/b4a45d9bdda54c3980abd5b330516733.jpeg"></p><p>修改后的代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/13f159f373474e79849ba53f608a9700.jpeg"></p><p>再看场景类调用：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/209ada6ba7c84f4fbc60f80a39754b10.jpeg"></p><p>总之，就是类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象。</p><p><strong>2.朋友间也是有距离的</strong></p><p>我们在开发中经常有这种场景：调用一个或多个类，先执行第一个方法，然后是第二个方法，根据返回结果再看是否执行第三个方法。我们以安装某个软件为例，其类图为：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/65afe1e984eb4867973e94205e5b5860.jpeg"></p><p>代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/1fe35f98ebeb420187d7dfb80598b781.jpeg"></p><p>场景类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/0a18f2862cfd4a9f8b5ed996e10aaf66.jpeg"></p><p>程序很简单，但也存在一些问题：Wizard类把太多方法暴露给InstallSoftware类了，两者的朋友关系太亲密了，耦合关系变的异常牢固，如果要把Wizard中first方法的返回值改为Boolean类型，则要同时修改InstallSoftware类，增加了风险。因此，这种耦合是不合适的，我们需要对其优化。重构后的类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/f5cebb627fb74b3892742e168adf2d95.jpeg"></p><p>代码如下。导向类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/14b48eb83a7545748e1ea60984f869b7.jpeg"></p><p>我们把安装步骤改为私有方法，只向外暴露一个安装方法，这样，即使修改步骤的逻辑，也只是对Wizard自己有影响，只需要修改自己的安装方法逻辑即可，其他类不会受到影响。</p><p>安装类：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/fa576b9fdb68431099fa505d0072234d.jpeg"></p><p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。所以，我们开发中尽量不要对外公布太多public方法和非静态的public变量，尽量内敛。</p><p><strong>3.是自己的就是自己的</strong></p><p>在实际开发中经常会出现这样一种情况：一个方法放在吧本类中也可以，放在其他类中也没有错。那这时，我们只需要坚持一个原则：<strong>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</strong>。</p><p>总之，迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提升上去。</p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>开闭原则是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。也就是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。我们以书店销售书籍为例来说明什么是开闭原则。</p><p>其类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/0a2b016371664bbcb0ef5f0420e25675.jpeg"></p><p>书籍及其实现类代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/76408358790c4c928dff62961fad5677.jpeg"></p><p>书店类代码：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/89cdaecdcae541978c3fd7941bbfa107.jpeg"></p><p>项目开发完了，开始正常卖书了。假如到了双十一，要搞打折活动，上面的功能是不支持的，所以需要修改程序。有三种方法可以解决这个问题：</p><p>（1）修改接口</p><p>在IBook接口里新增getOffPrice()方法，专门用于进行打折，所有的实现类都实现该方法。但这样修改的后果就是，实现类NovelBook要修改，书店类BookStore中的main方法也要修改，同时，IBook作为接口应该是稳定且可靠的，不应该经常发生变化，因此，该方案被否定。</p><p>（2）修改实现类</p><p>修改NovelBook类中的方法，直接在getPrice()方法中实现打折处理，这个方法可以是可以，但如果采购书籍的人员要看价格怎么办，由于该方法已经进行了打折处理，因此采购人员看到的也是打折后的价格，会因信息不对称出现决策失误的情况。因此，该方案也不是一个最优的方案。</p><p>（3）通过扩展实现变化</p><p>增加一个子类OffNovelBook，覆写getPrice方法，高层次的模块（也就是BookStore中static静态块中）通过OffNovelBook类产生新的对象，完成业务变化对系统的最小开发。这样修改也少，风险也小，修改后的类图如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/6f0cab63e1c842b097c24f1f9656ade8.jpeg"></p><p>OffNovelBook源码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/88082d2b058146f8a21d213bf5f754a5.jpeg"></p><p>然后修改BookStore中的书籍类为OffNovelBook：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200301/987451e8f45045818a8ed15e6abe97db.jpeg"></p><p><strong>为什么要用开闭原则</strong></p><ol><li><p>开闭原则非常著名，只要是做面向对象编程的，在开发时都会提及开闭原则。</p></li><li><p>开闭原则是最基础的一个原则，前面介绍的5个原则都是开闭原则的具体形态，而开闭原则才是其精神领袖。</p></li><li><p>开闭原则提高了复用性，以及可维护性。</p></li></ol><h1 id="总结六大设计原则"><a href="#总结六大设计原则" class="headerlink" title="总结六大设计原则"></a>总结六大设计原则</h1><ol><li><p>单一职责原则：一个类或接口只承担一个职责。</p></li><li><p>里氏替换原则：在继承类时，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。</p></li><li><p>依赖倒置原则：高层模块不应该依赖于低层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。</p></li><li><p>接口隔离原则：不要对外暴露没有实际意义的接口。</p></li><li><p>迪米特法则：尽量减少对象之间的交互，从而减小类之间的耦合。</p></li><li><p>开闭原则：对软件实体的改动，最好用扩展而非修改的方式。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>六大设计原则虽好，但要熟练掌握和应用他们还是不那么容易的，需要在熟记于心的同时在编码工作中不断的实践和积累经验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么会有六大原则&quot;&gt;&lt;a href=&quot;#为什么会有六大原则&quot; class=&quot;headerlink&quot; title=&quot;为什么会有六大原则&quot;&gt;&lt;/a&gt;为什么会有六大原则&lt;/h2&gt;&lt;p&gt;面向过程编程到面向对象编程是软件设计的一大步，封装、继承、多态是面向对象的三大特征，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>探究DRY、YANGI、三次法则</title>
    <link href="https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6DRY%E3%80%81YANGI%E3%80%81%E4%B8%89%E6%AC%A1%E6%B3%95%E5%88%99/"/>
    <id>https://andy-whb-cn.github.io/2024/11/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A2%E7%A9%B6DRY%E3%80%81YANGI%E3%80%81%E4%B8%89%E6%AC%A1%E6%B3%95%E5%88%99/</id>
    <published>2024-11-06T01:19:05.933Z</published>
    <updated>2024-11-21T01:46:47.976Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发工作中，我们常常会遇到一些使得代码变得冗余、复杂甚至难以维护的情况。为了应对这些问题，软件工程界提出了许多原则和方法来指导我们的编程实践。</p><p>其中，DRY原则、YAGNI原则和三次法则是我们编程过程中常常需要用到的三个重要原则。那么，这些原则具体是什么含义，又应该如何在实际开发中运用呢？下面就让我们一起来探讨。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-1242469/7ede31094a7f06f9f608f81947fc46a4.png?imageView2/2/w/591"></p><h4 id="DRY原则：追求高效，摒弃重复"><a href="#DRY原则：追求高效，摒弃重复" class="headerlink" title="DRY原则：追求高效，摒弃重复"></a>DRY原则：追求高效，摒弃重复</h4><p>软件工程名著《<a href="http://en.wikipedia.org/wiki/The_Pragmatic_Programmer">The Pragmatic Programmer</a> | <a href="http://www.amazon.cn/gp/product/B005UP9PJM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&tag=vastwork-23&linkCode=as2&camp=536&creative=3200&creativeASIN=B005UP9PJM" title="程序员修炼之道:从小工到专家">程序员修炼之道</a>:从小工到专家》首先提出这一原则。</p><p>DRY，全称”Don’t Repeat Yourself”，翻译为中文就是”不要重复自己”，这个原则有时也称作“一次且仅一次“原则（Once and Only Once)。这是一种追求高效、优雅的编程原则。根据DRY原则，任何形式的信息重复都应当被消除。在实际的编程中，如果同一个逻辑出现在两个或更多的地方，那么我们就需要考虑将这部分逻辑抽象出来，避免重复代码。</p><p>DRY原则的优点在于，它能提高代码的可读性和可维护性，降低代码的复杂度，从而提高整个软件的质量。比如，当我们需要修改某一逻辑时，只需要在一个地方修改即可，无需在多个地方做同样的修改，大大提高了代码的维护性。</p><h4 id="YAGNI原则：聚焦现在，摒弃过度设计"><a href="#YAGNI原则：聚焦现在，摒弃过度设计" class="headerlink" title="YAGNI原则：聚焦现在，摒弃过度设计"></a>YAGNI原则：聚焦现在，摒弃过度设计</h4><p>这是<a href="http://en.wikipedia.org/wiki/Extreme_programming">“极限编程”</a>提倡的原则,  指导思想，就是尽可能快、尽可能简单地让软件运行起来（do the simplest thing that could possibly work）。</p><p>YAGNI，全称”You Aren’t Gonna Need It”，翻译为中文就是”你不会需要它”。这个原则鼓励我们抵制过度设计的诱惑，只关注当前真正需要的功能，而不是那些”可能”在未来会用到的功能。</p><p>在软件开发过程中，我们常常会受到”可能会用到”这种假设的诱惑，这导致我们花费大量的时间和精力去实现那些实际上并不需要的功能，而这些功能反而增加了代码的复杂度，降低了软件的可维护性。因此，YAGNI原则告诉我们，除非确定需要某个功能，否则就不要去实现它。</p><p>DRY原则和YAGNI原则并非完全兼容。前者追求”抽象化”，要求找到通用的解决方法；后者追求”快和省”，意味着不要把精力放在抽象化上面，因为很可能”你不会需要它”。于是就有了第三个原则”三次法则“。</p><h4 id="三次法则：提炼抽象，追求优雅"><a href="#三次法则：提炼抽象，追求优雅" class="headerlink" title="三次法则：提炼抽象，追求优雅"></a>三次法则：提炼抽象，追求优雅</h4><p><a href="http://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">Rule of three</a> 称为”三次原则”，指的是当某个功能第三次出现时，才进行”抽象化”。这是软件开发大家<a href="http://en.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a>在《Refactoring | <a href="http://www.amazon.cn/gp/product/B003BY6PLK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&tag=vastwork-23&linkCode=as2&camp=536&creative=3200&creativeASIN=B003BY6PLK" title="重构:改善既有代码的设计">重构</a>》一书中提出的。</p><p>三次法则，是一种关于何时应该重构或抽象代码的原则。它告诉我们，如果你做了一次相同的事情，那就继续；如果你做了两次相同的事情，那就稍微有点耐心；如果你做了三次相同的事情，那么你应该重构或抽象它。</p><p>实际上，这个法则是DRY原则的一个具体实践。当我们在代码中发现重复的逻辑时，可能是时候考虑进行抽象了。这样，当我们需要修改这部分逻辑时，只需要在一个地方进行修改即可，而不需要在多个地方进行相同的修改。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>软件开发是一项复杂的工作，需要我们不断学习和实践。DRY原则、YAGNI原则和三次法则，都是我们在编程实践中需要掌握的重要原则。通过运用这些原则，我们可以写出更高质量的代码，构建出更优秀的软件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发工作中，我们常常会遇到一些使得代码变得冗余、复杂甚至难以维护的情况。为了应对这些问题，软件工程界提出了许多原则和方法来指导我们的编程实践。&lt;/p&gt;
&lt;p&gt;其中，DRY原则、YAGNI原则和三次法则是我们编程过程中常常需要用到的三个重要原则。那么，这些原则具体是什么</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用软件清单</title>
    <link href="https://andy-whb-cn.github.io/2024/09/03/%E6%8E%A8%E8%8D%90/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/"/>
    <id>https://andy-whb-cn.github.io/2024/09/03/%E6%8E%A8%E8%8D%90/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/</id>
    <published>2024-09-03T06:11:58.004Z</published>
    <updated>2024-09-03T06:31:27.693Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>软件名称</th><th>下载地址</th><th>用途</th></tr></thead><tbody><tr><td>winscp</td><td><a href="https://winscp.net/eng/index.php">https://winscp.net/eng/index.php</a></td><td>scp远程连接上传下载文件</td></tr><tr><td>Another-Redis-Desktop-Manager</td><td><a href="https://goanother.com/cn/#download">https://goanother.com/cn/#download</a></td><td>Redis客户端工具</td></tr><tr><td>NoSQLBooster for MongoDB</td><td><a href="https://www.nosqlbooster.com/">https://www.nosqlbooster.com/</a></td><td>MongoDB客户端</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件名称&lt;/th&gt;
&lt;th&gt;下载地址&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;winscp&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://winscp.net/eng/</summary>
      
    
    
    
    
  </entry>
  
</feed>
